<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林中小屋</title>
  
  
  <link href="http://antipassion.github.io/atom.xml" rel="self"/>
  
  <link href="http://antipassion.github.io/"/>
  <updated>2022-11-20T03:20:28.456Z</updated>
  <id>http://antipassion.github.io/</id>
  
  <author>
    <name>Nayon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从转储lsass学习Windows安全</title>
    <link href="http://antipassion.github.io/2022/11/19/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://antipassion.github.io/2022/11/19/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2022-11-19T07:42:25.000Z</published>
    <updated>2022-11-20T03:20:28.456Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;0x1-前置理论&quot;&gt;&lt;a href=&quot;#0x1-前置理论&quot; class=&quot;headerlink&quot; title=&quot;0x1 前置理论&quot;&gt;&lt;/a&gt;0x1 前置理论&lt;/h4&gt;&lt;h5 id=&quot;访问令牌-Access-Token&quot;&gt;&lt;a href=&quot;#访问令牌-Access-Token&quot; class=&quot;headerlink&quot; title=&quot;访问令牌(Access Token)&quot;&gt;&lt;/a&gt;访问令牌(Access Token)&lt;/h5&gt;&lt;p&gt;​    &lt;code&gt;Access Token&lt;/code&gt;是描述进程或线程的安全上下文的对象。其中包括进程或线程关联的用户账户的身份和权限。&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;Access Token&lt;/code&gt;分为授权令牌(Delegation Token)、模拟令牌(Impersonation token)两种。&lt;/p&gt;
&lt;p&gt;Access Token包含以下信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户帐户的&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/secauthz/security-identifiers&quot;&gt;安全标识符&lt;/a&gt;(SID)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户所属组的 SID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标识当前&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/desktop/SecGloss/l-gly&quot;&gt;&lt;em&gt;登录会话&lt;/em&gt;&lt;/a&gt;的&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/desktop/SecGloss/l-gly&quot;&gt;&lt;em&gt;登录 SID&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户或用户组拥有的&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/secauthz/privileges&quot;&gt;权限&lt;/a&gt;列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有者 SID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主要组的 SID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly&quot;&gt;&lt;em&gt;用户在未指定安全描述符&lt;/em&gt;&lt;/a&gt;的情况下创建安全对象时系统使用的默认&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists&quot;&gt;DACL&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问令牌的来源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令牌是&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/desktop/SecGloss/p-gly&quot;&gt;&lt;em&gt;主要&lt;/em&gt;&lt;/a&gt;令牌还是&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/secauthz/client-impersonation&quot;&gt;模拟&lt;/a&gt;令牌&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可选的&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/secauthz/restricted-tokens&quot;&gt;限制 SID列表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前模拟级别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他统计&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://antipassion.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>通过WebDav进行NTLM Relay</title>
    <link href="http://antipassion.github.io/2022/10/30/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay/"/>
    <id>http://antipassion.github.io/2022/10/30/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay/</id>
    <published>2022-10-30T02:51:43.000Z</published>
    <updated>2022-11-20T03:20:41.551Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;​    NTLM Relay大家已经不再陌生了，很多时候我们通过NTLM Relay进行攻击时，会受到协议签名(ldap/s、smb等协议签名)的影响从而导致攻击失败，并且随着时间的流逝，我们想要遇到忽略签名的smb等服务也变得越来越困难了，我们有哪些方法来忽略服务端验证签名的影响从而达到我们relay攻击的目的呢？&lt;/p&gt;
&lt;p&gt;​    我们可以寻找不支持签名的服务，来避免服务端的签名校验。若客户端不支持签名验证的话，服务端在与客户端通信时是不会强制要求签名认证的。因此我们可以使用HTTP服务中的WebDav来尝试Relay攻击了。&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hell&#39;s Gate的一次尝试入门</title>
    <link href="http://antipassion.github.io/2022/08/03/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>http://antipassion.github.io/2022/08/03/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8/</id>
    <published>2022-08-03T14:25:27.000Z</published>
    <updated>2022-10-30T02:52:09.986Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;接触安全已经一年多了，在实习工作中跟进项目的时候，以前我的弱项也逐步暴露出来，并越发明显，我不懂&lt;strong&gt;免杀与工具开发&lt;/strong&gt;，钓鱼、下马的工作无法顺利进行，几乎就是面向google的渗透测试工程。&lt;/p&gt;
&lt;p&gt;我想，如果想要进一步的发展提升，便要开展这方面的学习了，遂有此篇博文。&lt;/p&gt;
&lt;p&gt;Hell’s Gate，也就是地狱之门，算是一项经典的底层绕过AV或EDR的技术手段，利用syscall技术调用NTDLL内函数,从而绕过杀软对函数的检测。&lt;/p&gt;</summary>
    
    
    
    
    <category term="红队渗透" scheme="http://antipassion.github.io/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-42287/CVE-2021-42278分析复现</title>
    <link href="http://antipassion.github.io/2022/03/01/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/"/>
    <id>http://antipassion.github.io/2022/03/01/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-01T15:04:11.000Z</published>
    <updated>2022-03-03T04:54:39.015Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;距离漏洞披露已经过了许久，现在终于有些空余时间用于学习复现这两个漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CVE-2021-42278，机器账户的名称一般用&lt;code&gt;$&lt;/code&gt;结尾，但AD并未对域内机器账户名进行验证。&lt;/li&gt;
&lt;li&gt;CVE-2021-42287， 结合上述42278漏洞，创建一个与DC机器账户名称相同的机器账户(不以$结尾)，使用该账户请求一个TGT后，修改账户名，然后通过S4U2Self申请TGS Ticket，然后DC进行在&lt;code&gt;TGS_REP&lt;/code&gt;阶段加密&lt;code&gt;TGS Ticket&lt;/code&gt;时，无法找到该账户利用机器账户hash加密，DC便使用自己的hash加密&lt;code&gt;TGS Ticket&lt;/code&gt;，提供一个属于该账户的&lt;code&gt;PAC&lt;/code&gt;，我们便可得到一个高权限的ST。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;攻击流程&quot;&gt;&lt;a href=&quot;#攻击流程&quot; class=&quot;headerlink&quot; title=&quot;攻击流程:&quot;&gt;&lt;/a&gt;攻击流程:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先创建一个机器账户&lt;/li&gt;
&lt;li&gt;清除机器账户的&lt;code&gt;servicePrincipalName&lt;/code&gt;属性&lt;/li&gt;
&lt;li&gt;将机器账户的&lt;code&gt;sAMAccountName&lt;/code&gt;修改为DC的机器账户名，但不带$&lt;/li&gt;
&lt;li&gt;使用机器账户的身份请求TGT&lt;/li&gt;
&lt;li&gt;将机器账户的&lt;code&gt;sAMAccountName&lt;/code&gt;修改为其他值，不能与DC的机器账户名重复。&lt;/li&gt;
&lt;li&gt;通过S4U2Self向KDC申请ST&lt;/li&gt;
&lt;li&gt;拿到高权限ST票据，完成利用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用原理：如果域内存在一台域控名为DC(机器账户为DC$)的域控机，此时攻击者可利用CVE-2021-42287漏洞去申请一个机器账户，再将机器账户的&lt;code&gt;sAMAccountName&lt;/code&gt;修改为DC。然后再利用这个机器账户去申请一个TGT票据，再将DC的&lt;code&gt;sAMAccountName&lt;/code&gt;修改为其他。修改结束后再利用这个TGT通过S4U2Self去申请ST票据，此时KDC识别TGT票据内用户名为DC，检索到域内并未存在DC用户，但存在DC$用户(检索的依据为sAMAccountName值)，于是KDC通过DC机器的hash加密票据，我们便可成功拿到DC的权限。&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用机器账户进行域提权</title>
    <link href="http://antipassion.github.io/2022/02/19/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83/"/>
    <id>http://antipassion.github.io/2022/02/19/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83/</id>
    <published>2022-02-19T14:40:56.000Z</published>
    <updated>2022-03-01T15:05:04.103Z</updated>
    
    
    <summary type="html">&lt;p&gt;pass the hash攻击，除去常见的使用本地管理员账户进行hash传递外，还可以使用机器账户进行提权。&lt;/p&gt;
&lt;p&gt;如果在主机上授予了本地管理员访问权限，并且计算机本身为&lt;code&gt;Domain admins&lt;/code&gt;组的成员，那我们在进行渗透测试时，可以利用该计算机账户进行提权。以机器账户来使用hash传递来进行提权。&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用机器账户进行域维权</title>
    <link href="http://antipassion.github.io/2022/02/15/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83/"/>
    <id>http://antipassion.github.io/2022/02/15/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83/</id>
    <published>2022-02-15T14:54:20.000Z</published>
    <updated>2022-03-09T14:42:00.947Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;机器账户在许多技术中可以用于提权或横向移动，如使用机器账户的委派进行dcsync，使用机器账户也可进行维权操作。我们可以将任意计算机账户添加到高权限组(例如Domain Admin、Domain Controllers、Enterprise Admins) 或对计算机账户的userAccountControl属性进行修改。使用这两种方式，我们可以通过机器账户在域内进行身份认证（因为密码已知）并进行提权操作，例如Dcsync拖取域内hash。&lt;/p&gt;
&lt;p&gt;除了上述作用，使用机器账户也可进行域维权操作。我们可以将任意计算机账户添加到高权限组(例如Domain Admin、Domain Controllers、Enterprise Admins) 或对计算机账户的&lt;code&gt;userAccountControl&lt;/code&gt;属性进行修改。使用这两种方式，我们可以通过机器账户在域内进行身份认证（因为密码已知）并进行提权操作，例如Dcsync拖取域内hash。&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于资源的约束委派</title>
    <link href="http://antipassion.github.io/2022/01/30/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/"/>
    <id>http://antipassion.github.io/2022/01/30/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</id>
    <published>2022-01-30T04:44:17.000Z</published>
    <updated>2022-03-02T10:32:23.033Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;基于资源的约束委派利用&quot;&gt;&lt;a href=&quot;#基于资源的约束委派利用&quot; class=&quot;headerlink&quot; title=&quot;基于资源的约束委派利用&quot;&gt;&lt;/a&gt;基于资源的约束委派利用&lt;/h3&gt;&lt;p&gt;基于资源的约束委派，(Resource-based constrained delegation)，与前文提到的约束委派不同，它在信任的传递关系上是不同的，这也是它工作方向相反的一个因素。&lt;/p&gt;
&lt;p&gt;在约束委派中，账户A到账户B的约束委派在账户A的 msDS-AllowedToDelegateTo 属性中配置，并且定义了A到B的传出&lt;code&gt;信任&lt;/code&gt;,而在基于资源的约束委派当中，委派在账户B的msDS-AllowedToActOnBehalfOfOtherIdentity 属性中配置，并定义了A到B的&lt;code&gt;传入&lt;/code&gt;信任。&lt;/p&gt;
&lt;p&gt;一图概括。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220204202427514.png&quot; alt=&quot;image-20220204202427514&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图为在Elad师傅中的文章中所得的导图，通过此图，我们可以看出基于资源的约束委派与传统约束委派的工作方式有何不同。&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>约束委派攻击</title>
    <link href="http://antipassion.github.io/2022/01/09/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/"/>
    <id>http://antipassion.github.io/2022/01/09/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</id>
    <published>2022-01-09T15:21:05.000Z</published>
    <updated>2022-02-25T14:33:15.941Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;约束委派&quot;&gt;&lt;a href=&quot;#约束委派&quot; class=&quot;headerlink&quot; title=&quot;约束委派&quot;&gt;&lt;/a&gt;约束委派&lt;/h2&gt;&lt;p&gt;接上述的非约束委派，由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能。约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。这里包括一组名为S4U2Self（Service for User to  Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109233827841.png&quot; alt=&quot;    &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>非约束委派攻击</title>
    <link href="http://antipassion.github.io/2022/01/06/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/"/>
    <id>http://antipassion.github.io/2022/01/06/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</id>
    <published>2022-01-06T15:18:28.000Z</published>
    <updated>2022-02-06T06:14:03.665Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;委派&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在域中如果出现A使用Kerberos身份验证访问域中的服务B,而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220106232045335.png&quot; alt=&quot;image-20220106232045335&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;例&quot;&gt;&lt;a href=&quot;#例&quot; class=&quot;headerlink&quot; title=&quot;例:&quot;&gt;&lt;/a&gt;例:&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;User访问主机S2上的HTTP服务，此时要想完整的使用HTTP服务，需再访问S3主机上的SQL数据库，但S2并不知道域用户是否拥有权限访问S3上的数据库服务权限，这时为了验证权限，S2会带着User的访问权限去申请访问SQL数据库，若User拥有权限才可进行访问。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;非约束委派&quot;&gt;&lt;a href=&quot;#非约束委派&quot; class=&quot;headerlink&quot; title=&quot;非约束委派&quot;&gt;&lt;/a&gt;非约束委派&lt;/h3&gt;&lt;p&gt;非约束委派Kerberos中实现时，User会将自KDC拿到的TGT发送给访问的服务机器Service1,Service1再通过拿到手的TGT票据去申请访问其他域内服务，Service1在拿到用户的TGT票据后，会对其留存，以便下次备用，这时，我们便可在拿下的Service1机器中拿到域用户的TGT票据，从而访问域内的可访问服务(域管用户可访问任意服务)&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>PE结构-DOS头</title>
    <link href="http://antipassion.github.io/2021/11/19/PE%E7%BB%93%E6%9E%84-DOS%E5%A4%B4/"/>
    <id>http://antipassion.github.io/2021/11/19/PE%E7%BB%93%E6%9E%84-DOS%E5%A4%B4/</id>
    <published>2021-11-19T11:40:13.000Z</published>
    <updated>2022-08-07T10:03:31.291Z</updated>
    
    
    <summary type="html">&lt;p&gt;PE结构-DOS头，本部分为参照吾爱破解论坛lyl610abc师傅&lt;a href=&quot;https://www.52pojie.cn/thread-1403011-1-1.html&quot;&gt;PE文件笔记&lt;/a&gt;所整理的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;DOS部首&quot;&gt;&lt;a href=&quot;#DOS部首&quot; class=&quot;headerlink&quot; title=&quot;DOS部首&quot;&gt;&lt;/a&gt;DOS部首&lt;/h3&gt;&lt;h4 id=&quot;DOS部首结构&quot;&gt;&lt;a href=&quot;#DOS部首结构&quot; class=&quot;headerlink&quot; title=&quot;DOS部首结构&quot;&gt;&lt;/a&gt;DOS部首结构&lt;/h4&gt;</summary>
    
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/categories/PE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/tags/PE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PE结构-PE文件的两种状态</title>
    <link href="http://antipassion.github.io/2021/11/16/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://antipassion.github.io/2021/11/16/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81/</id>
    <published>2021-11-16T06:50:09.000Z</published>
    <updated>2022-01-28T04:40:15.231Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文的是学习复现自吾爱破解dalao &lt;a href=&quot;https://www.52pojie.cn/thread-1393291-1-1.html&quot;&gt;lyl610abc&lt;/a&gt;的PE文件解析系列，非本人原创，属于学习笔记(大佬yyds!)。&lt;/p&gt;
&lt;h3 id=&quot;PE文件的两种状态&quot;&gt;&lt;a href=&quot;#PE文件的两种状态&quot; class=&quot;headerlink&quot; title=&quot;PE文件的两种状态&quot;&gt;&lt;/a&gt;PE文件的两种状态&lt;/h3&gt;&lt;p&gt;PE文件处于磁盘中与处于内存中时，两者的结构会稍微发生改变。&lt;/p&gt;</summary>
    
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/categories/PE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/tags/PE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PE结构-VA与FOA的转化</title>
    <link href="http://antipassion.github.io/2021/10/14/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96/"/>
    <id>http://antipassion.github.io/2021/10/14/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96/</id>
    <published>2021-10-14T03:26:38.000Z</published>
    <updated>2022-01-28T04:40:18.132Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;VA转FOA&quot;&gt;&lt;a href=&quot;#VA转FOA&quot; class=&quot;headerlink&quot; title=&quot;VA转FOA&quot;&gt;&lt;/a&gt;VA转FOA&lt;/h3&gt;&lt;p&gt;相应名词概念&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;对应结构体成员&lt;/th&gt;
&lt;th&gt;英文全称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;VA&lt;/td&gt;
&lt;td&gt;_IMAGE_SECTION_HEADER.VirtualAddress&lt;/td&gt;
&lt;td&gt;Virtual Address&lt;/td&gt;
&lt;td&gt;在内存中的虚拟地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RVA&lt;/td&gt;
&lt;td&gt;_IMAGE_SECTION_HEADER.VirtualAddress&lt;/td&gt;
&lt;td&gt;Relative Virtual Address&lt;/td&gt;
&lt;td&gt;相对虚拟地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FOA&lt;/td&gt;
&lt;td&gt;_IMAGE_SECTION_HEADER.PointerToRawData&lt;/td&gt;
&lt;td&gt;File Offset Address&lt;/td&gt;
&lt;td&gt;文件偏移地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/categories/PE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/tags/PE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PE结构-导出表(3)</title>
    <link href="http://antipassion.github.io/2021/10/14/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8(3)/"/>
    <id>http://antipassion.github.io/2021/10/14/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8(3)/</id>
    <published>2021-10-14T03:07:55.000Z</published>
    <updated>2022-08-07T10:03:27.794Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;导出表&quot;&gt;&lt;a href=&quot;#导出表&quot; class=&quot;headerlink&quot; title=&quot;导出表&quot;&gt;&lt;/a&gt;&lt;strong&gt;导出表&lt;/strong&gt;&lt;/h1&gt;&lt;h4 id=&quot;导出表的作用&quot;&gt;&lt;a href=&quot;#导出表的作用&quot;</summary>
        
      
    
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/categories/PE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/tags/PE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PE结构-导入表（2）</title>
    <link href="http://antipassion.github.io/2021/10/13/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2)/"/>
    <id>http://antipassion.github.io/2021/10/13/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2)/</id>
    <published>2021-10-13T06:45:18.000Z</published>
    <updated>2022-01-28T04:40:04.374Z</updated>
    
    
    <summary type="html">&lt;p&gt;首先，PE文件中的数据被载入内存后根据不同页面属性被划分成很多区块(节)，并有区块表（节表）的数据来描述这些区块，这里我们需要注意一点：&lt;strong&gt;一个区块中的数据仅仅知识由于属性相同而放一起，并不一定是同一种用途的内容。例如输入表、输出表等就有可能和只读常量一起被放在同一个区块中。因为他们的属性都是可读不可写的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其次，由于不同用途的数据有可能被放入同一个区块中，因此仅仅依靠区块表是无法确定和定位的。因此还需要通过PE文件头中的IMAGE_OPTIONAL_READER32结构的数据目录表来指出他们的位置，我们可以由数据目录表来定位他们的位置，我们可以由数据目录表来定位的数据包括输入表、输出表、资源、重定位表和TLS等15种数据。&lt;/p&gt;
&lt;h3 id=&quot;导入表&quot;&gt;&lt;a href=&quot;#导入表&quot; class=&quot;headerlink&quot; title=&quot;导入表&quot;&gt;&lt;/a&gt;导入表&lt;/h3&gt;&lt;h4 id=&quot;导入表的作用&quot;&gt;&lt;a href=&quot;#导入表的作用&quot; class=&quot;headerlink&quot; title=&quot;导入表的作用&quot;&gt;&lt;/a&gt;导入表的作用&lt;/h4&gt;&lt;p&gt;当程序运行时，需要多个PE文件共同组成&lt;/p&gt;
&lt;p&gt;PE文件提供哪些功能给其他PE文件是导出表的作用&lt;/p&gt;
&lt;p&gt;PE文件需要依赖的模块以及依赖模块中的哪些函数是导出表的作用&lt;/p&gt;</summary>
    
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/categories/PE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/tags/PE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PE结构-系统解密篇（1）</title>
    <link href="http://antipassion.github.io/2021/10/12/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87(1)/"/>
    <id>http://antipassion.github.io/2021/10/12/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87(1)/</id>
    <published>2021-10-12T02:42:01.000Z</published>
    <updated>2022-01-28T04:40:08.238Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;学习课程-鱼C-小甲鱼【系统篇】《解密系列》单看课程记不住，想着好记性不如烂笔头，特此记录学习加深理解。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;PE结构的概念&quot;&gt;&lt;a href=&quot;#PE结构的概念&quot; class=&quot;headerlink&quot; title=&quot;PE结构的概念&quot;&gt;&lt;/a&gt;PE结构的概念&lt;/h2&gt;&lt;h3 id=&quot;EXE与DLL文件的区别&quot;&gt;&lt;a href=&quot;#EXE与DLL文件的区别&quot; class=&quot;headerlink&quot; title=&quot;EXE与DLL文件的区别&quot;&gt;&lt;/a&gt;EXE与DLL文件的区别&lt;/h3&gt;&lt;p&gt;EXE与DLL文件之间的区别完全是语意上面的，因为他们使用了完全相同的PE格式。唯一的区别在与是用一个字段标示出这个文件是EXE还是DLL文件格式。 &lt;/p&gt;</summary>
    
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/categories/PE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="PE结构" scheme="http://antipassion.github.io/tags/PE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Kerberoasting</title>
    <link href="http://antipassion.github.io/2021/09/27/Kerberoasting%E6%94%BB%E5%87%BB/"/>
    <id>http://antipassion.github.io/2021/09/27/Kerberoasting%E6%94%BB%E5%87%BB/</id>
    <published>2021-09-27T07:22:39.000Z</published>
    <updated>2022-02-06T08:10:17.707Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 简介&quot;&gt;&lt;/a&gt;0x01 简介&lt;/h2&gt;&lt;p&gt;​    &lt;strong&gt;Kerberoasting的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Kerberoasting的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Kerberoasting的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Kerberoasting后门利用&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>WinRM-横向移动</title>
    <link href="http://antipassion.github.io/2021/09/26/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
    <id>http://antipassion.github.io/2021/09/26/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</id>
    <published>2021-09-26T07:08:44.000Z</published>
    <updated>2022-01-28T04:40:47.885Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;WinRM 用于Windows远程管理，他允许管理员远程执行系统命令。通过HTTP(5985) 或 HTTPS SOAP(5986)进行执行，支持Kerberos以及NTLM身份验证以及基本身份验证。使用此服务需要管理员票据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们已经获得一台内网服务器的管理员权限(对端服务器允许此用户登陆即可)，并且开启了WinRM管理服务器，那么我们可以利用凭证进行内网横向移动&lt;/p&gt;</summary>
    
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="域渗透" scheme="http://antipassion.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
